<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AJAX</title>
    <url>/2019/04/14/AJAX/</url>
    <content><![CDATA[<h1 id="什么是AJAX？"><a href="#什么是AJAX？" class="headerlink" title="什么是AJAX？"></a>什么是AJAX？</h1><a id="more"></a>
<p><code>AJAX</code>全称<code>Asynchronous JavaScript and XML</code><br>即异步的JS和XML<br><code>AJAX</code>并不是一种编程语言，而是一种技术，通俗来说就是没用<code>AJAX</code>的网页，每点一个按钮就要刷新一下页面，尽管新页面上只有一行字和当前页面不一样，但你还是要无聊地等待页面刷新。用了<code>AJAX</code>之后，点击之后，页面上的一行字就变化了，而页面本身不需要刷新。<br>在没有<code>AJAX</code>的时代，页面的刷新是同步的<br><img src="/images/微信截图_20190414211530.png" alt><br>当<code>AJAX</code>技术出现之后，网页即做到异步，每进行一项业务请求的时候,都会向服务器发送验证.但是这个验证并不会影响其他的业务.做到了实时更新。<br><img src="/images/微信截图_20190414211934.png" alt></p>
<h1 id="如何应用AJAX"><a href="#如何应用AJAX" class="headerlink" title="如何应用AJAX"></a>如何应用AJAX</h1><ol>
<li>运用<code>HTML</code>和<code>CSS</code>来实现页面,表达信息</li>
<li>运用<code>XMLHttpRequset</code>和<code>web</code>服务器进行数据的异步交换</li>
<li>运用<code>Javascript</code>操作<code>DOM</code>,实现动态局部刷新</li>
</ol>
<h2 id="首先来了解一下HTTP请求与响应"><a href="#首先来了解一下HTTP请求与响应" class="headerlink" title="首先来了解一下HTTP请求与响应"></a>首先来了解一下<code>HTTP</code>请求与响应</h2><p><img src="/images/微信截图_20190414212351.png" alt><br><img src="/images/微信截图_20190414212449.png" alt><br><img src="/images/微信截图_20190414212509.png" alt><br><img src="/images/微信截图_20190414212527.png" alt><br><img src="/images/微信截图_20190414212557.png" alt></p>
<h2 id="XMLHttpRequset发送请求"><a href="#XMLHttpRequset发送请求" class="headerlink" title="XMLHttpRequset发送请求:"></a>XMLHttpRequset发送请求:</h2><p><img src="/images/微信截图_20190414212658.png" alt></p>
<h2 id="XMLHttpRequset取得响应"><a href="#XMLHttpRequset取得响应" class="headerlink" title="XMLHttpRequset取得响应:"></a>XMLHttpRequset取得响应:</h2><p><img src="/images/微信截图_20190414212757.png" alt></p>
<h2 id="如何判断请求响应成功了呢-首次我们要知道有这样一个status"><a href="#如何判断请求响应成功了呢-首次我们要知道有这样一个status" class="headerlink" title="如何判断请求响应成功了呢?首次我们要知道有这样一个status"></a>如何判断请求响应成功了呢?首次我们要知道有这样一个status</h2><p><img src="/images/微信截图_20190414212830.png" alt></p>
<h2 id="通过监听readyState的状态码-来判断是是否请求成功"><a href="#通过监听readyState的状态码-来判断是是否请求成功" class="headerlink" title="通过监听readyState的状态码,来判断是是否请求成功:"></a>通过监听readyState的状态码,来判断是是否请求成功:</h2><p><img src="/images/微信截图_20190414212907.png" alt></p>
<h1 id="原生js来实现AJAX"><a href="#原生js来实现AJAX" class="headerlink" title="原生js来实现AJAX"></a>原生js来实现AJAX</h1><pre><code class="js">myButton.addEventListener(&#39;click&#39;, (e)=&gt;{
    let request = new XMLHttpRequest()
    request.open(&#39;get&#39;, &#39;http://yyyh.info:8001/xxx&#39;)
    request.send()
    request.onreadystatechange = ()=&gt;{
        if(request.readyState === 4){
            if(request.status &gt;= 200 &amp;&amp; request.status &lt; 300){
                let string = request.responseText
                let object = window.JSON.parse(string)
            }
        }
    }
})
</code></pre>
]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>Array</title>
    <url>/2019/03/27/Array/</url>
    <content><![CDATA[<h1 id="什么是Array"><a href="#什么是Array" class="headerlink" title="什么是Array"></a>什么是Array</h1><h2 id="Array-对象是用于构造数组的全局对象，是按次序排列的一组值"><a href="#Array-对象是用于构造数组的全局对象，是按次序排列的一组值" class="headerlink" title="Array 对象是用于构造数组的全局对象，是按次序排列的一组值"></a>Array 对象是用于构造数组的全局对象，是按次序排列的一组值</h2><a id="more"></a>
<h1 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h1><pre><code>let f1 = [&#39;a&#39;,&#39;b&#39;]
let f2 = new Array(&#39;a&#39;,&#39;b&#39;)
f1 === f2
</code></pre><h1 id="Array-用法"><a href="#Array-用法" class="headerlink" title="Array 用法"></a>Array 用法</h1><p><img src="/images/微信截图_20190327141842.png" alt></p>
<p>只有一个参数时，参数表示为length<br>多个参数时，表示第一项和第二项等等的值</p>
<h2 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h2><p>基本类型 number string boolean<br>Number( ) =&gt; 基本类型<br>new Number( ) =&gt; 对象<br>复杂类型 object: array function<br>加不加new没有影响</p>
<h2 id="Array的遍历"><a href="#Array的遍历" class="headerlink" title="Array的遍历"></a>Array的遍历</h2><p><img src="/images/微信截图_20190327152709.png" alt></p>
<h2 id="伪数组-arguments"><a href="#伪数组-arguments" class="headerlink" title="伪数组 arguments"></a>伪数组 arguments</h2><p><img src="/images/微信截图_20190327154113.png" alt></p>
<h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><p><img src="/images/微信截图_20190327163954.png" alt></p>
<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p><img src="/images/微信截图_20190327165124.png" alt></p>
<h2 id="join-concat"><a href="#join-concat" class="headerlink" title="join concat"></a>join concat</h2><p><img src="/images/微信截图_20190327170021.png" alt></p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p><img src="/images/微信截图_20190327170425.png" alt></p>
<h2 id="filter-reduce"><a href="#filter-reduce" class="headerlink" title="filter reduce"></a>filter reduce</h2><p><img src="/images/微信截图_20190327173142.png" alt></p>
<h1 id="Array-自测"><a href="#Array-自测" class="headerlink" title="Array 自测"></a>Array 自测</h1><pre><code>Array(3) 和 new Array(3) 的返回结果有区别吗？
// no

function f(x,y){return x+y} 和 f = new Function(&#39;x&#39;,&#39;y&#39;,&#39;return x+y&#39;) 的值有区别吗？
// no

var a = [1,2,3]
请问 a.__proto__ 指向哪个对象？
// Array.prototype

var a = [1,2,3]
请问 a.push 指向哪个函数？
// Array.prototype.push

for i 循环和 Array.prototype.forEach 都可以遍历数组，请问区别是什么
// for 是关键字，不是函数；Array.prototype.forEach 是一个函数
// for 循环可以 break 和 continue；Array.prototype.forEach 不支持 break 和 continue

var a = [1,3,5,2,4,6] 使用哪个 API 可以使得 a 倒过来，变成 [6,4,2,5,3,1]
// a.reverse()

var students = [&#39;小明&#39;,&#39;小红&#39;,&#39;小花&#39;] 
var scores = { 小明: 59, 小红: 99, 小花: 80 } 
students.sort(???)
填写 ??? 使得 students 按分数的高低从大到小排列
// function(x,y){return scores[y]-scores[x]}

var a = [1,2,3,4,5,6,7,8,9]
a.filter(???).map(???) // [4,16,36,64]
获取所有偶数
得到所有偶数的平方
//  function(value,key){
//  return value%2===0}
//  function(value,key){
//  return value*value}

var a = [1,2,3,4,5,6,7,8,9]
a.reduce(???,???)
计算所有奇数的和
// function(sum,n){
//   if(n%2 !== 0){
//      sum+=n}
//   return sum},0
</code></pre>]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS深入浅出-IFC</title>
    <url>/2019/05/23/CSS%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-IFC/</url>
    <content><![CDATA[<p>图片下面有空隙时<br>vertical-align: top</p>
]]></content>
      <categories>
        <category>CSS深入浅出</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS深入浅出-Icon</title>
    <url>/2019/05/20/CSS%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-Icon/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/58317946" target="_blank" rel="noopener">转到我的知乎</a></p>
]]></content>
      <categories>
        <category>CSS深入浅出</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS深入浅出-Flex布局</title>
    <url>/2019/05/20/CSS%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-Flex%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="Flex布局基本概念"><a href="#Flex布局基本概念" class="headerlink" title="Flex布局基本概念"></a>Flex布局基本概念</h1><a id="more"></a>
<ul>
<li>块级布局侧重垂直方向，行内布局侧重水平方向，flex布局是<code>与方向无关</code>的</li>
<li>flex布局可以实现<code>空间自动分配</code>，<code>自动对齐</code>(flexible：弹性灵活)</li>
<li>flex适用于简单的<code>线性布局</code>，更复杂的布局要交给<code>grid</code>布局<br><img src="/images/微信截图_20190520182609.png" alt><h1 id="Flex-container-的属性"><a href="#Flex-container-的属性" class="headerlink" title="Flex container 的属性"></a>Flex container 的属性</h1></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">flex-direction</td>
<td style="text-align:center">方向</td>
</tr>
<tr>
<td style="text-align:center">flex-wrap</td>
<td style="text-align:center">换行</td>
</tr>
<tr>
<td style="text-align:center">flex-flow</td>
<td style="text-align:center">上两个的简写(少)</td>
</tr>
<tr>
<td style="text-align:center">justify-content</td>
<td style="text-align:center">主轴方向对齐方式</td>
</tr>
<tr>
<td style="text-align:center">align-items</td>
<td style="text-align:center">侧轴方向对齐方式</td>
</tr>
<tr>
<td style="text-align:center">align-content</td>
<td style="text-align:center">多行/列内容对齐方式(少)</td>
</tr>
</tbody>
</table>
<h2 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h2><p><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）</p>
<ul>
<li>row（默认值）：主轴为水平方向，起点在左端</li>
<li>row-reverse：主轴为水平方向，起点在右端</li>
<li>column：主轴为垂直方向，起点在上沿</li>
<li>column-reverse：主轴为垂直方向，起点在下沿</li>
</ul>
<h2 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h2><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行</p>
<ul>
<li>nowrap(默认)：不换行</li>
<li>wrap：换行，第一行在上方</li>
<li>wrap-reverse：换行，第一行在下方</li>
</ul>
<h2 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h2><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code></p>
<h2 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h2><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式</p>
<ul>
<li>flex-start（默认值）：左对齐</li>
<li>flex-end：右对齐</li>
<li>center： 居中</li>
<li>space-between：两端对齐，项目之间的间隔都相等</li>
<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍</li>
</ul>
<p><img src="/images/bg2015071010.png" alt>  </p>
<h2 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h2><p><code>align-items</code>属性定义项目在侧轴上如何对齐</p>
<ul>
<li>flex-start：侧轴的起点对齐</li>
<li>flex-end：侧轴的终点对齐</li>
<li>center：居中</li>
<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度</li>
<li>baseline: 项目的第一行文字的基线对齐</li>
</ul>
<p><img src="/images/bg2015071011.png" alt></p>
<h2 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h2><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用</p>
<ul>
<li>flex-start：与侧轴的起点对齐</li>
<li>flex-end：与侧轴的终点对齐</li>
<li>center：与侧轴的中点对齐</li>
<li>stretch（默认值）：轴线占满整个侧轴</li>
<li>space-between：与侧轴两端对齐，轴线之间的间隔平均分布</li>
<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍</li>
</ul>
<p><img src="/images/bg2015071012.png" alt></p>
<h1 id="Flex-item-的属性"><a href="#Flex-item-的属性" class="headerlink" title="Flex item 的属性"></a>Flex item 的属性</h1><table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">order</td>
<td style="text-align:center">排列顺序</td>
</tr>
<tr>
<td style="text-align:center">flex-grow</td>
<td style="text-align:center">放大</td>
</tr>
<tr>
<td style="text-align:center">flex-shrink</td>
<td style="text-align:center">缩小</td>
</tr>
<tr>
<td style="text-align:center">flex-basis</td>
<td style="text-align:center">占据空间</td>
</tr>
<tr>
<td style="text-align:center">flex</td>
<td style="text-align:center">三个的简写</td>
</tr>
<tr>
<td style="text-align:center">align-self</td>
<td style="text-align:center">单独设置</td>
</tr>
</tbody>
</table>
<h2 id="order"><a href="#order" class="headerlink" title="order"></a>order</h2><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0</p>
<p><img src="/images/bg2015071013.png" alt></p>
<h2 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h2><p><code>flex-grow</code>属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大<br>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）<br>如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍</p>
<p><img src="/images/bg2015071014.png" alt></p>
<h2 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h2><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小<br>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小<br>如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小<br>(负值对该属性无效)</p>
<p><img src="/images/bg2015071015.png" alt></p>
<h2 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h2><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小<br>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间</p>
<h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选<br>该属性有两个快捷值：<code>auto (1 1 auto)</code> 和 <code>none (0 0 auto)</code><br>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值</p>
<h2 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h2><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code><br>该属性可能取<code>6</code>个值，除了<code>auto</code>，其他都与<code>align-items</code>属性完全一致</p>
<h1 id="小游戏"><a href="#小游戏" class="headerlink" title="小游戏"></a>小游戏</h1><p><a href="http://flexboxfroggy.com/#zh-cn" target="_blank" rel="noopener">救救青蛙</a></p>
]]></content>
      <categories>
        <category>CSS深入浅出</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS深入浅出-BFC</title>
    <url>/2019/05/21/CSS%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-BFC/</url>
    <content><![CDATA[<h1 id="什么是BFC"><a href="#什么是BFC" class="headerlink" title="什么是BFC"></a>什么是BFC</h1><a id="more"></a>
<h2 id="CSS规范中对-BFC-的描述"><a href="#CSS规范中对-BFC-的描述" class="headerlink" title="CSS规范中对 BFC 的描述"></a>CSS规范中对 BFC 的描述</h2><p>块格式化上下文</p>
<p>浮动，绝对定位元素，非块盒的块容器（例如，inline-blocks，table-cells和table-captions）和’overflow’不为’visible’的块盒会为它们的内容建立一个新的块格式化上下文</p>
<p>在一个块格式化上下文中，盒在竖直方向一个接一个地放置，从包含块的顶部开始。两个兄弟盒之间的竖直距离由’margin’属性决定。同一个块格式化上下文中的相邻块级盒之间的竖直margin会合并</p>
<p>在一个块格式化上下文中，每个盒的left外边（left outer edge）挨着包含块的left边（对于从右向左的格式化，right边挨着）。即使存在浮动（尽管一个盒的行盒可能会因为浮动收缩），这也成立。除非该盒建立了一个新的块格式化上下文（这种情况下，该盒自身可能会因为浮动变窄）</p>
<h2 id="MDN-对-BFC-的描述"><a href="#MDN-对-BFC-的描述" class="headerlink" title="MDN 对 BFC 的描述"></a>MDN 对 BFC 的描述</h2><p>一个块格式化上下文（block formatting context） 是Web页面的可视化CSS渲染出的一部分。它是块级盒布局出现的区域，也是浮动层元素进行交互的区域。</p>
<p>一个块格式化上下文由以下之一创建：</p>
<ul>
<li>根元素或其它包含它的元素</li>
<li>浮动元素 (元素的 float 不是 none)</li>
<li>绝对定位元素 (元素具有 position 为 absolute 或 fixed)</li>
<li>内联块 (元素具有 display: inline-block)</li>
<li>表格单元格 (元素具有 display: table-cell，HTML表格单元格默认属性)</li>
<li>表格标题 (元素具有 display: table-caption, HTML表格标题默认属性)</li>
<li>具有overflow 且值不是 visible 的块元素，</li>
<li>display: flow-root</li>
<li>column-span: all 应当总是会创建一个新的格式化上下文，即便具有 column-span: all 的元素并不被包裹在一个多列容器中。</li>
<li>一个块格式化上下文包括创建它的元素内部所有内容，除了被包含于创建新的块级格式化上下文的后代元素内的元素。</li>
</ul>
<p>块格式化上下文对于定位 (参见 float) 与清除浮动 (参见 clear) 很重要。定位和清除浮动的样式规则只适用于处于同一块格式化上下文内的元素。浮动不会影响其它块格式化上下文中元素的布局，并且清除浮动只能清除同一块格式化上下文中在它前面的元素的浮动。</p>
<h2 id="张鑫旭对-BFC-的描述"><a href="#张鑫旭对-BFC-的描述" class="headerlink" title="张鑫旭对 BFC 的描述"></a>张鑫旭对 BFC 的描述</h2><p>BFC全称”Block Formatting Context”, 中文为”块级格式化上下文”。啪啦啪啦特性什么的，一言难尽，大家可以自行去查找，我这里不详述，免得乱了主次，总之，记住这么一句话：BFC元素特性表现原则就是，内部子元素再怎么翻江倒海，翻云覆雨都不会影响外部的元素。所以，避免margin穿透啊，清除浮动什么的也好理解了。</p>
<h1 id="BFC功能1"><a href="#BFC功能1" class="headerlink" title="BFC功能1"></a>BFC功能1</h1><p>爸爸管儿子<br><a href="http://js.jirengu.com/rozaxufetu/1/edit?html,css,output" target="_blank" rel="noopener">用 BFC 包住浮动元素</a><br>(这不是清除浮动，.clearfix 才是清除浮动）</p>
<h1 id="BFC功能2"><a href="#BFC功能2" class="headerlink" title="BFC功能2"></a>BFC功能2</h1><p>兄弟之间划清界限<br><a href="http://js.jirengu.com/felikenuve/1/edit?html,css,output" target="_blank" rel="noopener">用 float + div 做左右自适应布局</a></p>
<h1 id="回答面试"><a href="#回答面试" class="headerlink" title="回答面试"></a>回答面试</h1><ol>
<li>不要解释</li>
<li>用代码</li>
</ol>
]]></content>
      <categories>
        <category>CSS深入浅出</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS深入浅出-动态REM</title>
    <url>/2019/05/22/CSS%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-%E5%8A%A8%E6%80%81REM/</url>
    <content><![CDATA[<h1 id="什么是REM"><a href="#什么是REM" class="headerlink" title="什么是REM"></a>什么是REM</h1><h1 id="REM跟EM的区别又是什么"><a href="#REM跟EM的区别又是什么" class="headerlink" title="REM跟EM的区别又是什么"></a>REM跟EM的区别又是什么</h1><a id="more"></a>
<p><code>rem</code>是基于<code>html</code>元素的字体大小来决定，而<code>em</code>则根据使用它的元素的大小决定</p>
<h1 id="手机端方案的特点"><a href="#手机端方案的特点" class="headerlink" title="手机端方案的特点"></a>手机端方案的特点</h1><p>所有手机显示的界面都是一样的，只是大小不同</p>
<pre><code class="js">1 rem == html font-size == viewport width
</code></pre>
<h1 id="使用-JS-动态调整-REM"><a href="#使用-JS-动态调整-REM" class="headerlink" title="使用 JS 动态调整 REM"></a>使用 JS 动态调整 REM</h1><pre><code class="html"> &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;
 &lt;script&gt;
     var pageWidth = window.innerWidth
     document.write(&#39;&lt;style&gt;html{font-size:&#39;+pageWidth+&#39;px;}&lt;/style&gt;&#39;)
 &lt;/script&gt;
</code></pre>
<p><a href="http://js.jirengu.com/xoqadocuqu/2/edit?html,css,output" target="_blank" rel="noopener">示例</a></p>
<h1 id="REM-可以与其他单位同时存在"><a href="#REM-可以与其他单位同时存在" class="headerlink" title="REM 可以与其他单位同时存在"></a>REM 可以与其他单位同时存在</h1><pre><code class="css">{
    font-size: 16px;
    border: 1px solid red;
    width: 0.5rem;
}
</code></pre>
<h1 id="在-SCSS-里使用-PX2REM"><a href="#在-SCSS-里使用-PX2REM" class="headerlink" title="在 SCSS 里使用 PX2REM"></a>在 SCSS 里使用 PX2REM</h1><ul>
<li>npm config set registry <a href="https://registry.npm.taobao.org/" target="_blank" rel="noopener">https://registry.npm.taobao.org/</a></li>
<li>touch ~/.bashrc</li>
<li>echo ‘export SASS_BINARY_SITE=”<a href="https://npm.taobao.org/mirrors/node-sass&quot;&#39;" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/node-sass&quot;&#39;</a> &gt;&gt; ~/.bashrc</li>
<li>source ~/.bashrc</li>
<li>npm i -g node-sass</li>
<li>mkdir ~/Desktop/scss-demo</li>
<li>cd ~/Desktop/scss-demo</li>
<li>mkdir scss css</li>
<li>touch scss/style.scss</li>
<li>start scss/style.scss</li>
<li><p>node-sass -wr scss -o css</p>
</li>
<li><p>编辑 scss 文件就会自动得到 css 文件</p>
</li>
<li><p>在 scss 文件里添加<br><code>`</code>scss<br>@function px( $px ){<br>@return $px/$designWidth*10 + rem;<br>}</p>
</li>
</ul>
<p>$designWidth : 640; // 640 是设计稿的宽度，你要根据设计稿的宽度填写。如果设计师的设计稿宽度不统一，就杀死设计师，换个新的。</p>
<p>.child{<br>  width: px(320);<br>  height: px(160);<br>  margin: px(40) px(40);<br>  border: 1px solid red;<br>  float: left;<br>  font-size: 1.2em;<br>}<br><code>`</code></p>
]]></content>
      <categories>
        <category>CSS深入浅出</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS深入浅出-堆叠上下文</title>
    <url>/2019/05/20/CSS%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-%E5%A0%86%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<p>堆叠上下文是HTML元素的三维概念，这些HTML元素在一条假想的相对于面向（电脑屏幕的）视窗或者网页的用户的z轴上延伸，HTML元素依据其自身属性按照优先级顺序占用层叠上下文的空间。<br><a id="more"></a></p>
<ul>
<li>根元素 (HTML)</li>
<li>z-index 值不为 “auto”的 绝对/相对定位</li>
<li>一个 z-index 值不为 “auto”的 flex 项目 (flex item)，即：父元素 display: flex|- inline-flex</li>
<li>opacity 属性值小于 1 的元素（参考 the specification for opacity）</li>
<li>transform 属性值不为 “none”的元素</li>
<li>mix-blend-mode 属性值不为 “normal”的元素</li>
<li>filter值不为“none”的元素</li>
<li>perspective值不为“none”的元素</li>
<li>isolation 属性被设置为 “isolate”的元素</li>
<li>position: fixed</li>
<li>在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值（参考 这篇文章）</li>
<li>-webkit-overflow-scrolling 属性被设置 “touch”的元素<br><img src="/images/微信截图_20190520121856.png" alt></li>
</ul>
]]></content>
      <categories>
        <category>CSS深入浅出</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS深入浅出-布局套路</title>
    <url>/2019/05/21/CSS%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-%E5%B8%83%E5%B1%80%E5%A5%97%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="浮动布局-float"><a href="#浮动布局-float" class="headerlink" title="浮动布局(float)"></a>浮动布局(float)</h1><ol>
<li>给子类加 <code>float:left</code></li>
<li>给父类加 <code>class=&quot;clearfix&quot;</code><a id="more"></a>
<pre><code class="css">.clearfix::after{
 content: &#39;&#39;;
 display: block;
 clear: both;
}
</code></pre>
<h1 id="Flex布局-flex"><a href="#Flex布局-flex" class="headerlink" title="Flex布局(flex)"></a>Flex布局(flex)</h1>见上一篇</li>
</ol>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><a href="http://js.jirengu.com/qujoyicohu/1/edit?html,css,output" target="_blank" rel="noopener">用 float 做一个左右布局</a><br><a href="http://js.jirengu.com/mociwagaye/1/edit?html,css,output" target="_blank" rel="noopener">用 Flex 实现一遍</a><br><a href="http://js.jirengu.com/cuvazaruti/3/edit" target="_blank" rel="noopener">用 float + 负 margin 做一个平均布局</a><br><a href="http://js.jirengu.com/xivas/2/edit?html,css,output" target="_blank" rel="noopener">用 Flex 实现一遍</a></p>
]]></content>
      <categories>
        <category>CSS深入浅出</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS文档流与盒模型</title>
    <url>/2019/05/19/CSS%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-%E6%96%87%E6%A1%A3%E6%B5%81%E4%B8%8E%E7%9B%92%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h1><p>在CSS里，一个元素的高度是由<code>其内部文档流元素高度总和</code>决定的<br>文档流（<code>Normal Flow</code>）：文档内元素的流动方向<br><a id="more"></a></p>
<ul>
<li>内联元素由左往右流动，遇到阻碍就换行继续流</li>
<li>块级元素由上往下流动，每一块占一行</li>
<li>内联元素的高度是由<code>line-height</code>决定的，它多少像素，内联元素的高度就是多少</li>
<li>块级元素的高度是由其内部文档流元素的总和决定的<h2 id="内联元素"><a href="#内联元素" class="headerlink" title="内联元素"></a>内联元素</h2></li>
<li>内联元素(<code>inline</code>)不会独占一行，相邻的内联元素会排在同一行。其宽度随内容的变化而变化  </li>
<li>宽度：不受<code>width</code>的限制，有文字内容决定的，<code>padding</code>和<code>margin</code>可以改变宽度</li>
<li>高度：不受<code>height</code>的限制，<code>padding</code>和<code>margin</code>也不能改变。可以通过<code>line-height</code>和<code>font-size</code>来改变<h2 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h2></li>
<li>块级元素(<code>block</code>)会独占一行，默认情况下宽度自动填满其父元素宽度 </li>
<li>块级元素可以设置宽高 </li>
<li>块级元素可以设置<code>margin</code>，<code>padding</code><h2 id="内联块状元素inline-block"><a href="#内联块状元素inline-block" class="headerlink" title="内联块状元素inline-block"></a>内联块状元素inline-block</h2>简单来说就是将对象呈现为<code>inline</code>对象，但是对象的内容作为<code>block</code>对象呈现（可以设置宽高和<code>margin</code>值）。之后的内联对象会被排列在同一内联。比如我们可以给<code>a元素</code>一个<code>inline-block</code>属性值，使其既具有<code>block</code>的宽度高度特性又具有<code>inline</code>的同行特性。<h1 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h1><h2 id="内联元素水平居中"><a href="#内联元素水平居中" class="headerlink" title="内联元素水平居中"></a>内联元素水平居中</h2></li>
<li>行内元素 设置 text-align:center</li>
<li>Flex布局 设置 display:flex; justify-content:center<h2 id="块级元素水平居中"><a href="#块级元素水平居中" class="headerlink" title="块级元素水平居中"></a>块级元素水平居中</h2></li>
<li>定宽块状元素 设置左右 margin 值为 auto</li>
<li>不定宽块状元素 设置子元素为 display:inline，然后在父元素上设置 text-align:center<h1 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h1></li>
<li>父元素一定，子元素为单行内联元素：设置父元素的 height 等于行高 line-height</li>
<li>父元素一定，子元素为多行内联元素：设置父元素的 display:table-cell 或 inline-block，再设置 vertical-align:middle</li>
<li>块状元素：设置行高 line-height，加上下 padding</li>
<li>flex布局 align-items: center<h1 id="文字溢出省略"><a href="#文字溢出省略" class="headerlink" title="文字溢出省略"></a>文字溢出省略</h1><h2 id="单行"><a href="#单行" class="headerlink" title="单行"></a>单行</h2><pre><code class="css">{   
  white-space: nowrap; /*超出的空白区域不换行*/
  overflow: hidden; /*超出隐藏*/
  text-overflow: ellipsis; /*文本超出显示省略号*/
}
</code></pre>
<h2 id="多行"><a href="#多行" class="headerlink" title="多行"></a>多行</h2><pre><code class="css">{
  display: -webkit-box; /*将对象作为弹性伸缩盒子模型显示*/
  -webkit-line-clamp: 2; /*用来限制在一个块元素显示的文本的行数*/
  -webkit-box-orient: vertical; /*设置或检索伸缩盒对象的子元素的排列式 */
  overflow: hidden; /*超出隐藏*/
  text-overflow: ellipsis; /*用来多行文本的情况下，用省略号“…”隐藏超范围的文本*/
}
</code></pre>
<h1 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h1>在一个文档中，每一个元素都被抽象成一个盒子，每一个盒子又包括四部分(从内到外):内容(content)，内填充(padding)，边框(border)，外边距(margin)，这就是<code>盒模型</code><br><img src="/images/v2-55c9ea515b2499c4b70d132ce5554734_hd.png" alt="盒模型示意图"></li>
<li>content box：立体盒子的核心</li>
<li>padding box：内边距区域padding area 延伸到包围padding的边框。如果内容区域content area设置了背景、颜色或者图片，这些样式将会延伸到padding上(当然我们可以通过background-clip设置作用区域)</li>
<li>border box：由border和4条border edge组成。若border宽度设置为0，则border edge与padding edge重叠</li>
<li>margin box：由margin和4条margin edge组成。若margin宽度设置为0，则margin edge与border edge重叠<h1 id="1-1-div"><a href="#1-1-div" class="headerlink" title="1:1 div"></a>1:1 div</h1><pre><code class="css">div{
  border: 1px solid red;
  padding-top: 100%;
}
</code></pre>
<h1 id="姓名与联系方式对齐"><a href="#姓名与联系方式对齐" class="headerlink" title="姓名与联系方式对齐"></a>姓名与联系方式对齐</h1><pre><code class="css">span{
  border: 1px solid red;
  display: inline-block;
  width: 5em;
  text-align: justify;
  line-height: 20px;
  overflow: hidden;
  height: 20px;
}
span::after{
  content: &#39;&#39;;
  display: inline-block;
  width: 100%;
}
</code></pre>
<h1 id="页面显示两个空格"><a href="#页面显示两个空格" class="headerlink" title="页面显示两个空格"></a>页面显示两个空格</h1><code>&amp;nbsp;&amp;nbsp;</code>(Non-Breaking Space)</li>
</ul>
]]></content>
      <categories>
        <category>CSS深入浅出</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS深入浅出-移动端页面(响应式)</title>
    <url>/2019/05/20/CSS%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B5%E9%9D%A2-%E5%93%8D%E5%BA%94%E5%BC%8F/</url>
    <content><![CDATA[<p>手机端页面的做法<br><a id="more"></a><br>学会 media query<br>学会要设计图（没图不做）<br>实在要做也行，丑可别怪我<br>学会隐藏元素<br>手机端要加一个 meta</p>
<pre><code class="html">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;
</code></pre>
<p>手机端的交互方式不一样</p>
<p>没有 hover<br>有 touch 事件<br>没有 resize<br>没有滚动条</p>
]]></content>
      <categories>
        <category>CSS深入浅出</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS深入浅出-表单美化</title>
    <url>/2019/05/22/CSS%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-%E8%A1%A8%E5%8D%95%E7%BE%8E%E5%8C%96/</url>
    <content><![CDATA[<p>布满坑的CSS<br><a id="more"></a><br><a href="http://js.jirengu.com/xafucutofi/1/edit?html,css,js,output" target="_blank" rel="noopener">百度搜索</a><br><a href="http://js.jirengu.com/gugegotese/edit?html,css,js,output" target="_blank" rel="noopener">图片上传器</a><br><a href="http://js.jirengu.com/mukidukuqi/edit?html,css,js,output" target="_blank" rel="noopener">涟漪按钮</a></p>
]]></content>
      <categories>
        <category>CSS深入浅出</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>JSONP</title>
    <url>/2019/04/07/JSONP/</url>
    <content><![CDATA[<h1 id="JSONP是什么？"><a href="#JSONP是什么？" class="headerlink" title="JSONP是什么？"></a>JSONP是什么？</h1><a id="more"></a>
<p><strong>请求方：yyyh.info的前端程序员（浏览器）</strong><br><strong>响应方：zzzq.info的后端程序员（服务器）</strong></p>
<ol>
<li>请求方创建<code>script</code>，<code>src</code>指向响应方，同时传入一个查询参数<code>?callbackName=yyy</code></li>
<li>响应方根据查询参数<code>callbackName</code>，构造形如<br> (1). yyy.call(undefined, ‘你要的数据’)<br> (2). yyy(‘你要的数据’)<br> 这样的响应</li>
<li>浏览器接收到响应，就会执行<code>yyy.call(undefined, &#39;你要的数据&#39;)</code></li>
<li>那么请求方就知道了他要的数据</li>
</ol>
<p><strong>这就是JSONP</strong></p>
<p><strong>约定：</strong></p>
<pre><code>callbackName -&gt; callback
yyy -&gt; 随机数 yyyh12321341242134()
</code></pre><p><strong>jQuery实现</strong></p>
<pre><code class="js">$.ajax({
    url: &quot;http://zzzq.info:8001/pay&quot;,
    dataType: &quot;jsonp&quot;,
    success: function( response ){
        if(response === &#39;success&#39;){
            amount.innerText = amount.innerText - 1
        }
    }
})
</code></pre>
<p><strong>面试题</strong><br><strong>请问 JSONP 为什么不支持 POST 请求</strong><br>答：<br>1.因为JSONP是通过动态创建script实现的<br>2.动态创建scrip只能用GET，不能使用POST</p>
]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>Tween.js</title>
    <url>/2019/03/26/Tween-js%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="什么是tween-js呢"><a href="#什么是tween-js呢" class="headerlink" title="什么是tween.js呢"></a>什么是tween.js呢</h1><h3 id="tween-js是一款可生成平滑动画效果的js动画库"><a href="#tween-js是一款可生成平滑动画效果的js动画库" class="headerlink" title="tween.js是一款可生成平滑动画效果的js动画库"></a>tween.js是一款可生成平滑动画效果的js动画库</h3><a id="more"></a>
<p>tween.js允许你以平滑的方式修改元素的属性值。你只需要告诉tween你想修改什么值，以及动画结束时它的最终值是什么，动画花费多少时间等信息，tween引擎就可以计算从开始动画点到结束动画点之间值，来产生平滑的动画效果</p>
<p>它的源代码展示在tweenjs的<a href="https://github.com/tweenjs/tween.js/" target="_blank" rel="noopener">github</a></p>
<p>下面有一个示例</p>
<p><img src="/images/微信截图_20190326114836.png" alt></p>
<p>当需要使用到tween.js时，还需要通过script引用<br>看到图片右上方的 ‘cdnjs’ 了吗<br>点进去</p>
<p><img src="/images/微信截图_20190326115141.png" alt></p>
<p>在js中引用即可</p>
<p><img src="/images/微信截图_20190326115430.png" alt></p>
<p>这是我对于页面窗口滚动的一次引用</p>
]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>前端工具</tag>
      </tags>
  </entry>
  <entry>
    <title>MVC</title>
    <url>/2019/04/20/MVC/</url>
    <content><![CDATA[<p><strong>什么是MVC</strong><br><a id="more"></a><br>Model 操作数据<br>View 表示视图<br>Controller 是控制器</p>
<p>Model 和服务器交互，Model 将得到的数据交给 Controller，Controller 把数据填入 View，并监听 View<br>用户操作 View，如点击按钮，Controller 就会接受到点击事件，Controller 这时会去调用 Model，Model 会与服务器交互，得到数据后返回给 Controller，Controller 得到数据就去更新 View</p>
]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery</title>
    <url>/2019/03/30/jQuery/</url>
    <content><![CDATA[<h1 id="jQuery-官网"><a href="#jQuery-官网" class="headerlink" title="jQuery 官网"></a>jQuery <a href="https://jquery.com/" target="_blank" rel="noopener">官网</a></h1><h1 id="jQuery-中文文档"><a href="#jQuery-中文文档" class="headerlink" title="jQuery 中文文档"></a>jQuery <a href="https://www.jquery123.com/" target="_blank" rel="noopener">中文文档</a></h1><a id="more"></a>
<h1 id="面试题1"><a href="#面试题1" class="headerlink" title="面试题1"></a>面试题1</h1><p>题目：</p>
<pre><code>&lt;ul&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>请写出 $(‘li’) 的结构</p>
<p>答案示例：<br>$(‘li’) 是一个对象，它自身的 key 有 xxx，它的原型（共享属性）为 xxx.prototype，xxx.prototype 的 key 有 xxx、xxx 和 xxx</p>
<p>答案：<br>提示：console.dir($(‘li’))<br>$(‘li’)是一个对象，它自身的key有0、1、length、prevObject、proto,它的原型（共享属性）Object.prototype,Object.prototype的key有constructor、hasOwnProperty、isPrototypeof、propertyIsEnumerable、toLocaleString、valueOf</p>
<h1 id="面试题2"><a href="#面试题2" class="headerlink" title="面试题2"></a>面试题2</h1><p>题目：</p>
<pre><code>&lt;div id=x&gt;&lt;/div&gt;
</code></pre><pre><code>var div = document.getElementById(&#39;x&#39;)
var $div = $(&#39;#x&#39;)
</code></pre><p>请说出 div 和 $div 的联系和区别</p>
<p>参考答题结构：<br>div 和 $div 的联系是：<br>只要这样这样这样就可以把 div 变成 $div<br>只要那样那样那样就可以把 $div 变成 div<br>div 和 $div 的区别是：<br>div 的属性和方法有 xxx xxx xxx<br>$div 的 属性和方法有 xxx xxx xxx</p>
<p>答案：<br>div 和 $div 的联系是：<br>只要$(div)可以把 div 变成 $div<br>只要$div[0]就可以把 $div 变成 div<br>div 和 $div 的区别是：<br>div 的属性和方法有 innerText lastChild classLIst className<br>$div 的 属性和方法有 length add addBack after ajaxComplete</p>
]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>函数</title>
    <url>/2019/03/27/%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="什么是函数"><a href="#什么是函数" class="headerlink" title="什么是函数"></a>什么是函数<hr></h1><h2 id="函数是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值"><a href="#函数是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值" class="headerlink" title="函数是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值"></a>函数是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值</h2><a id="more"></a>
<h1 id="函数的5种声明方式"><a href="#函数的5种声明方式" class="headerlink" title="函数的5种声明方式"></a>函数的5种声明方式<hr></h1><h2 id="具名函数"><a href="#具名函数" class="headerlink" title="具名函数"></a>具名函数</h2><pre><code>function x(input1, input2){return undefined}
</code></pre><ul>
<li><code>function</code> 声明一个函数</li>
<li><code>x</code> 为该函数的名字</li>
<li><code>input</code> 为输入的值</li>
<li>函数必须有终止 即使不写 会自动补上 <code>return undefined</code></li>
</ul>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><pre><code>var x ; x = function(input1, input2){return undefined}
</code></pre><h2 id="垃圾函数"><a href="#垃圾函数" class="headerlink" title="垃圾函数"></a>垃圾函数</h2><pre><code>var x = function(){} console.log(y) //报错× 注意
</code></pre><h2 id="window-Function-函数对象"><a href="#window-Function-函数对象" class="headerlink" title="window.Function 函数对象"></a>window.Function 函数对象</h2><pre><code>new Function(&#39;x&#39;,&#39;y&#39;,&#39;return x+y&#39;)
</code></pre><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><pre><code>var f = (x,y) =&gt; {return x+y}
sum = (x,y) =&gt; x+y //只有一个return
N = n =&gt; n*n //只有一个参数
</code></pre><h2 id="注：函数的name属性"><a href="#注：函数的name属性" class="headerlink" title="注：函数的name属性"></a>注：函数的name属性</h2><pre><code>||匿名函数
var f = function(){}
f.name // f
var f1 = function f2(){}
f1.name // f2

||Function函数
f3 = new Function(&#39;x&#39;,&#39;y&#39;,&#39;x+y&#39;)
f3.name // &quot;anonymous&quot;  匿名
</code></pre><h1 id="如何调用函数"><a href="#如何调用函数" class="headerlink" title="如何调用函数"></a>如何调用函数<hr></h1><pre><code>function f(x,y){return x+y} //函数
f(x,y) //小白调用
f.call(undefined,x,y) //硬核调用
</code></pre><h1 id="什么是”this”和”arguments”"><a href="#什么是”this”和”arguments”" class="headerlink" title="什么是”this”和”arguments”"></a>什么是”this”和”arguments”<hr></h1><pre><code>f.call(undefined,x,y)
</code></pre><ul>
<li>call的第一个参数可以用<code>this</code>得到</li>
<li>call后面的参数可以用<code>arguments</code>得到</li>
</ul>
<h1 id="call-Stack-调用栈"><a href="#call-Stack-调用栈" class="headerlink" title="call Stack  调用栈"></a>call Stack  调用栈</h1><p>先进先出</p>
<pre><code>function a(){
    console.log(&#39;a1&#39;)
    b.call()
    console.log(&#39;a2&#39;)
    return &#39;a&#39;
}
function b(){
    console.log(&#39;b1&#39;)
    c.call()
    console.log(&#39;b2&#39;)
    return &#39;b&#39;
}
function c(){
    console.log(&#39;c&#39;)
    return &#39;c&#39;
}
a.call()
console.log(&#39;end&#39;)
</code></pre><p>过程流程图</p>
<pre><code>a.call() =&gt; function a(){} =&gt; console.log(&#39;a1&#39;) =&gt; b.call() =&gt; function b(){} 
=&gt; console.log(&#39;b1&#39;) =&gt; c.call() =&gt; function c(){} =&gt; console.log(&#39;c&#39;) 
=&gt; return &#39;c&#39; =&gt; console.log(&#39;b2&#39;) =&gt; return &#39;b&#39; =&gt; console.log(&#39;a2&#39;)
=&gt; return &#39;a&#39; =&gt; console.log(&#39;end&#39;)

||调用a函数=&gt;找到a函数=&gt;打出a1=&gt;调用b函数=&gt;找到b函数=&gt;打出b1
=&gt;调用c函数=&gt;打出c=&gt;从c函数出来回到上层b函数=&gt;打出b2
=&gt;从b函数出来回到上层a函数=&gt;打出a2=&gt;返回=&gt;打出end
</code></pre><p><img src="/images/微信截图_20190328133736.png" alt></p>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><pre><code>var a = 1
function f1(){
    var a = 2
    f2.call()
    console.log(a)

    function f2(){
        var a = 3
        console.log(a)
    }
}
f1.call()
console.log(a)
</code></pre><p><img src="/images/scope.jpg" alt></p>
<p>只要有一个函数，就有一个作用域<br>当在函数外写入 <code>a = 2</code> 时，则是给全局作用域赋值<br>当在<code>f1</code>函数中写入 <code>a = 3</code> 时，则是给f1作用域赋值<br>而当<code>f1</code>函数中没有<code>var</code>声明<code>a</code>时，沿作用域数去找<code>a</code>，则同时给上级全局作用域赋值，如果全局作用域也没有声明，则其声明并赋值</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><pre><code>var a = 1
function f2(){
    console.log(a)
}
如果一个函数，使用了它作用域外的变量，那么（这个函数+这个变量）就叫做闭包
</code></pre><h1 id="函数自测"><a href="#函数自测" class="headerlink" title="函数自测"></a>函数自测</h1><pre><code>var f1 = function f2(){}
f1.name //&#39;f2&#39;

var f1 = function f2(){}
f2.name // 报错

var f1 = function f2(){}
console.log(f2)
// f2 is not defined

function f(){
    console.log(this)
}
f.call(1)
// Number 对象 1

function f(){
    &#39;use strict&#39; //严格模式
    console.log(this)
}
f.call(1)
// 1

function f(){
    console.log(this)
}
f.call()
// window

function f(){
    &#39;use strict&#39;
    console.log(this)
}
f.call()
// undefined

var a = console.log(1)
a // undefined

function f(){
    return 1
}
a = f
a // 函数f

function f(){
    return 1
}
var a = f.call()
a // 1

var a = 1,2
a // 报错

var a = (1,2)
a // 2

var a = (1, console.log(2))
a // undefined

function f(){
    return function f2(){}
}
var a = f.call()
a // 函数f2

function f(){
    return function f2(){}
}
var a = f.call()
var b = a.call()
b // undefined

function f(){
    return function f2(){}
}
var a = f.call().call()
b // undefined

function f1(){
    console.log(this)
    function f2(){

    }
}
var obj = {name: &#39;obj&#39;}
f1.call( obj )
// obj对象

function f1(){

    function f2(){
        console.log(this)
    }
    f2.call()
}
var obj = {name: &#39;obj&#39;}
f1.call( obj )
// window对象

function f1(){
    console.log(this) // 第一个 this
    function f2(){
        console.log(this) // 第二个 this
    }
    f2.call()
}
var obj = {name: &#39;obj&#39;}
f1.call( obj )
// 每个函数都有自己的 this，为什么会一样？
// this 就是 call 的第一个参数，第一个 this 对应的 call 是 f1.call(obj)，第二个 this 对应的 call 是 f2.call()
// this 和 arguments 都是参数，参数都要在函数执行（call）的时候才能确定
// 你以为名字一样值就一样吗？
</code></pre>]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>开博大吉</title>
    <url>/2019/03/25/%E5%BC%80%E5%8D%9A%E5%A4%A7%E5%90%89/</url>
    <content><![CDATA[<h1 id="哈哈"><a href="#哈哈" class="headerlink" title="哈哈"></a>哈哈</h1><p>大家好</p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>立即执行函数</title>
    <url>/2019/04/18/%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p><strong>立即执行函数定义</strong><br><a id="more"></a></p>
<ol>
<li>我们不想要全局变量</li>
<li>我们要使用局部变量</li>
<li>ES5中，只有函数有局部变量</li>
<li>于是我们声明一个<code>function xxx</code>, 然后<code>xxx.call()</code></li>
<li>这个时候 <code>xxx</code> 是全局变量</li>
<li>所以我们不能给函数命名</li>
<li>于是 <code>function(){}.call()</code></li>
<li>但是 <code>Chrome</code> 会报错语法错误</li>
<li>有一种方法可以正确使用 <code>!function(){}.call()</code></li>
<li>因为我们不在乎这个匿名函数的返回值，所以加一个<code>!</code>取反没有关系</li>
</ol>
]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>第三篇博客</title>
    <url>/2019/03/25/%E7%AC%AC%E4%B8%89%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="xx"><a href="#xx" class="headerlink" title="xx"></a>xx</h1>]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>第二篇博客</title>
    <url>/2019/03/25/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="第二篇博客-它垒了！"><a href="#第二篇博客-它垒了！" class="headerlink" title="第二篇博客 它垒了！"></a>第二篇博客 它垒了！</h1>]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>详解JSONP</title>
    <url>/2019/04/11/%E8%AF%A6%E8%A7%A3JSONP/</url>
    <content><![CDATA[<p><strong>JSONP</strong><br><a id="more"></a></p>
<h1 id="同源政策"><a href="#同源政策" class="headerlink" title="同源政策"></a>同源政策</h1><p>它的含义是指，A网页的数据，B网页请求不到，除非这两个网页”同源”。所谓”同源”指的是”三个相同”。</p>
<ul>
<li>协议相同</li>
<li>域名相同</li>
<li>端口相同<br>目前，如果非同源，共有三种行为受到限制：</li>
<li>Cookie、LocalStorage 和 IndexDB 无法读取</li>
<li>DOM 无法获得</li>
<li>AJAX 请求不能发送<br>以上只是简略讲解，具体的可以参考<a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">浏览器同源政策及其规避方法</a></li>
</ul>
<h1 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h1><p><strong>JSONP（JSON with Padding）是数据格式的一种“使用模式”，可以让网页从别的网域要数据</strong></p>
<h1 id="JSONP的由来"><a href="#JSONP的由来" class="headerlink" title="JSONP的由来"></a>JSONP的由来</h1><p>因为同源策略，导致无法请求另一个网站的数据，我们只能用form表单进行请求，但是form会刷新页面，用户体验很不好，所以以前的程序员们就开始了疯狂的实验<br>他们发现了link 、img、a、script等可以发送请求。经过种种实验总结出了以下几点：</p>
<ul>
<li>用 form 可以发请求，但是会刷新页面或新开页面</li>
<li>用 a 可以发 get 请求，但是也会刷新页面或新开页面</li>
<li>用 img 可以发 get 请求，但是只能以图片的形式展示</li>
<li>用 link 可以发 get 请求，但是只能以 CSS等形式展示<br><strong>最终他们选用 script 利用脚本语言进行get请求</strong><br><strong>请求方：yyyh.info的前端程序员（浏览器）</strong><br><strong>响应方：zzzq.info的后端程序员（服务器）</strong></li>
</ul>
<ol>
<li>请求方创建<code>script</code>，<code>src</code>指向响应方，同时传入一个查询参数<code>?callbackName=yyy</code></li>
<li>响应方根据查询参数<code>callbackName</code>，构造形如<br> (1). yyy.call(undefined, ‘你要的数据’)<br> (2). yyy(‘你要的数据’)<br> 这样的响应</li>
<li>浏览器接收到响应，就会执行<code>yyy.call(undefined, &#39;你要的数据&#39;)</code></li>
<li>那么请求方就知道了他要的数据<br><strong>这就是JSONP</strong></li>
</ol>
<h1 id="原生js实现JSONP"><a href="#原生js实现JSONP" class="headerlink" title="原生js实现JSONP"></a>原生js实现JSONP</h1><pre><code class="js">//前端
button.addEventListener(&#39;click&#39;, (e)=&gt;{
  let script = document.createElement(&#39;script&#39;)
  let functionName = &#39;frank&#39; + parseInt(Math.random()*10000000 ,10)
  window[functionName] = function({ //每次请求之前搞出一个随机的函数
      amount.innerText = amount.innerText - 0 - 1
  }
  script.src = &#39;/pay?callback=&#39; + functionName
  document.body.appendChild(script)
  script.onload = function(e){ // 状态码是200-299则表示成功
    e.currentTarget.remove()
    delete.window[functionName] //请求完了就干掉这个随机函数
  }
  script.onerror = function(e){  // 状态码大于等于400则表示失败
    e.currentTarget.remove()
    delete.window[functionName]   // 请求完了就干掉这个随机函数
  }
})
//后端
if(path === &#39;/pay&#39;){
  let amount = fs.readFileSync(&#39;./db&#39;,&#39;utf-8&#39;)
  amount -= 1
  fs.writeFileSync(&#39;./db&#39;,amount)
  let callbackName = query.callback
  response.setHeader(&#39;Content-Type&#39;,&#39;application/javasctipt&#39;)
  response.write(`
    $(callbackName).call(undefined,&#39;success&#39;)
  `)
  response.end()
}
</code></pre>
<h1 id="jQuery实现JSONP"><a href="#jQuery实现JSONP" class="headerlink" title="jQuery实现JSONP"></a>jQuery实现JSONP</h1><pre><code class="js">$.ajax({
    url: &quot;http://zzzq.info:8001/pay&quot;,
    dataType: &quot;jsonp&quot;,
    success: function( response ){
        if(response === &#39;success&#39;){
            amount.innerText = amount.innerText - 1
        }
    }
})
</code></pre>
<h1 id="JSONP小知识"><a href="#JSONP小知识" class="headerlink" title="JSONP小知识"></a>JSONP小知识</h1><p>##（一）安全问题<br>使用远程网站的script标签会让远程网站得以注入任何的内容至网站里。如果远程的网站有JavaScript注入漏洞，原来的网站也会受到影响。<br>现在有一个正在进行项目在定义所谓的JSON-P严格安全子集，使浏览器可以对MIME类别是“application/json-p”请求做强制处理。如果回应不能被解析为严格的JSON-P，浏览器可以丢出一个错误或忽略整个回应。</p>
<p>##（二）跨站请求伪造<br>粗略的JSONP部署很容易受到跨站伪造请求（CSRF/XSRF）的攻击。因为HTML script标签在浏览器里不遵守同源策略，恶意网页可以要求并获取属于其他网站的JSON数据。当用户正登录那个其他网站时，上述状况使得该恶意网站得以在恶意网站的环境下操作该JSON数据，可能泄漏用户的密码或是其他敏感数据。</p>
<p>只有在该JSON数据含有不该泄漏给第三方的隐密数据，且服务器仅靠浏览器的同源策略阻挡不正常要求的时候这才会是问题。若服务器自己决定要求的专有性，并只在要求正常的情况下输出数据则没有问题。只靠Cookie并不够决定要求是合法的，这很容易受到跨站请求伪造攻击。</p>
<h1 id="JSONP小问题"><a href="#JSONP小问题" class="headerlink" title="JSONP小问题"></a>JSONP小问题</h1><p><strong>请问 JSONP 为什么不支持 POST 请求</strong><br>答：<br>1.因为JSONP是通过动态创建script实现的<br>2.动态创建scrip只能用GET，不能使用POST</p>
]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象编程</title>
    <url>/2019/04/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p><strong>程序员也不知道什么是面向对象</strong><br><a id="more"></a><br><strong>MDN术语</strong><br>Class 类<br>定义对象的特征。它是对象的属性和方法的模板定义.<br>Object 对象<br>类的一个实例。<br>Property 属性<br>对象的特征，比如颜色。<br>Method 方法<br>对象的能力，比如行走。<br>Constructor 构造函数<br>对象初始化的瞬间, 被调用的方法. 通常它的名字与包含它的类一致.<br>Inheritance 继承<br>一个类可以继承另一个类的特征。<br>Encapsulation 封装<br>一种把数据和相关的方法绑定在一起使用的方法.<br>Abstraction 抽象<br>结合复杂的继承，方法，属性的对象能够模拟现实的模型。<br>Polymorphism 多态<br>多意为‘许多’，态意为‘形态’。不同类可以定义相同的方法或属性。</p>
<p><strong>使用new和构造函数</strong><br>补全下面的代码</p>
<pre><code class="js">function Human(options){


} // 构造函数结束

Human.prototype.______ = ___________ 
Human.prototype.______ = ___________ 
Human.prototype.______ = ___________ 

var human = new Human({name:&#39;Frank&#39;, city: &#39;Hangzhou&#39;})
var human2 = new Human({name:&#39;Jack&#39;, city: &#39;Hangzhou&#39;})
</code></pre>
<p>补全代码，使得 human 对象满足以下条件：</p>
<ol>
<li>human 这个对象本身具有属性 name 和 city</li>
<li>human.<strong>proto</strong> 对应的对象（也就是原型）具有物种（species）、走（walk）和使用工具（useTools）这几个属性</li>
<li>human.<strong>proto</strong>.constructor === Human 为 true</li>
</ol>
<p>human2 和 human 类似。</p>
<p>答：</p>
<pre><code class="js">function Human(options){
    this.name=options.name
    this.city=options.city
} // 构造函数结束

Human.prototype.species =&#39;Human&#39;
Human.prototype.walk=function(){} 
Human.prototype.useTools=function(){} 

var human = new Human({name:&#39;Frank&#39;, city: &#39;Hangzhou&#39;})
var human2 = new Human({name:&#39;Jack&#39;, city: &#39;Hangzhou&#39;})
</code></pre>
]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM常用API</title>
    <url>/2019/03/26/DOM/</url>
    <content><![CDATA[<h1 id="什么是DOM"><a href="#什么是DOM" class="headerlink" title="什么是DOM"></a>什么是DOM</h1><h2 id="DOM-是-JavaScript-操作网页的接口，全称为“文档对象模型”（Document-Object-Model）。它的作用是将网页转为一个-JavaScript-对象，从而可以用脚本进行各种操作（比如增删内容）。"><a href="#DOM-是-JavaScript-操作网页的接口，全称为“文档对象模型”（Document-Object-Model）。它的作用是将网页转为一个-JavaScript-对象，从而可以用脚本进行各种操作（比如增删内容）。" class="headerlink" title="DOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。"></a>DOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。</h2><a id="more"></a>
<p>浏览器会根据 DOM 模型，将结构化文档（比如 HTML 和 XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口。</p>
<p>DOM 只是一个接口规范，可以用各种语言实现。所以严格地说，DOM 不是 JavaScript 语法的一部分，但是 DOM 操作是 JavaScript 最常见的任务，离开了 DOM，JavaScript 就无法控制网页。另一方面，JavaScript 也是最常用于 DOM 操作的语言。后面介绍的就是 JavaScript 对 DOM 标准的实现和用法。</p>
<p>本文整理了 JavaScript 使用DOM时的一些常用API，用于巩固基础知识，加深对原生 js 的认识</p>
<h1 id="Node节点类型"><a href="#Node节点类型" class="headerlink" title="Node节点类型"></a>Node节点类型</h1><p>DOM 的最小组成单位叫做节点（Node）。DOM 定义了一个 Node 接口，该接口由 DOM中所有节点类型实现。这个 Node 接口在 JS 中是作为Node类型实现的。<br>Node 有一个属性 nodeType 表示 Node 的类型，它是一个整数，其数值分别表示相应的 Node 类型，具体如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Node类型</th>
<th style="text-align:center">nodeType数值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Node.ELEMENT_NODE</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:left">Node.TEXT_NODE</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:left">Node.PROCESSING_INSTRUCTION_NODE</td>
<td style="text-align:center">7</td>
</tr>
<tr>
<td style="text-align:left">Node.COMMENT_NODE</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:left">Node.DOCUMENT_NODE</td>
<td style="text-align:center">9</td>
</tr>
<tr>
<td style="text-align:left">Node.DOCUMENT_TYPE_NODE</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td style="text-align:left">Node.DOCUMENT_FRAGMENT_NODE</td>
<td style="text-align:center">11</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">Node类型(已弃用)</th>
<th style="text-align:center">nodeType数值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Node.ATTRIBUTE_NODE</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:left">Node.CDATA_SECTION_NODE</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:left">Node.ENTITY_REFERENCE_NODE</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:left">Node.ENTITY_NODE</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:left">Node.NOTATION_NODE</td>
<td style="text-align:center">12</td>
</tr>
</tbody>
</table>
<p>所以当我们要判断一个Node是不是元素时，我们可以这样做</p>
<p><img src="/images/微信截图_20190326203752.png" alt></p>
<p>下面来认识一下常用类型</p>
<h2 id="Element类型"><a href="#Element类型" class="headerlink" title="Element类型"></a>Element类型</h2><p>Element提供了对元素标签名，子节点和特性的访问，我们常用HTML元素比如div，span，a等标签就是element中的一种。Element有下面几条特性：<br>（1）nodeType为1<br>（2）nodeName为元素标签名，tagName也是返回标签名<br>（3）nodeValue为null<br>（4）parentNode可能是Document或Element<br>（5）子节点可能是Element，Text，Comment，Processing_Instruction，CDATASection或EntityReference</p>
<h2 id="Text类型"><a href="#Text类型" class="headerlink" title="Text类型"></a>Text类型</h2><p>Text表示文本节点，它包含的是纯文本内容，不能包含html代码，但可以包含转义后的html代码。Text有下面的特性：<br>（1）nodeType为3<br>（2）nodeName为#text<br>（3）nodeValue为文本内容<br>（4）parentNode是一个Element<br>（5）没有子节点</p>
<h2 id="Processing-Instruction类型"><a href="#Processing-Instruction类型" class="headerlink" title="Processing_Instruction类型"></a>Processing_Instruction类型</h2><p>一个用于XML文档的 ProcessingInstruction ，例如 <strong><em>&lt;?xml-stylesheet … ?&gt;</em></strong> 声明。</p>
<h2 id="Comment类型"><a href="#Comment类型" class="headerlink" title="Comment类型"></a>Comment类型</h2><p>Comment表示HTML文档中的注释，它有下面的几种特征：<br>（1）nodeType为8<br>（2）nodeName为#comment<br>（3）nodeValue为注释的内容<br>（4）parentNode可能是Document或Element<br>（5）没有子节点</p>
<h2 id="Document类型"><a href="#Document类型" class="headerlink" title="Document类型"></a>Document类型</h2><p>Document表示文档，在浏览器中，document对象是HTMLDocument的一个实例，表示整个页面，它同时也是window对象的一个属性。Document有下面的特性：<br>（1）nodeType为9<br>（2）nodeName为#document<br>（3）nodeValue为null<br>（4）parentNode为null<br>（5）子节点可能是一个DocumentType或Element</p>
<h2 id="Document-Type类型"><a href="#Document-Type类型" class="headerlink" title="Document_Type类型"></a>Document_Type类型</h2><p>表示了一个包含文档类型的节点 Node </p>
<h2 id="Document-Fragment类型"><a href="#Document-Fragment类型" class="headerlink" title="Document_Fragment类型"></a>Document_Fragment类型</h2><p>DocumentFragment是所有节点中唯一一个没有对应标记的类型，它表示一种轻量级的文档，可能当作一个临时的仓库用来保存可能会添加到文档中的节点。DocumentFragment有下面的特性：<br>（1）nodeType为11<br>（2）nodeName为#document-fragment<br>（3）nodeValue为null<br>（4）parentNode为null</p>
<p>认识了节点类型之后，将常用的 DOM 操作 API 分类</p>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="节点创建型api"><a href="#节点创建型api" class="headerlink" title="节点创建型api"></a>节点创建型api</h2><h3 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h3><p>createElement通过传入指定的一个标签名来创建一个元素，如果传入的标签名是一个未知的，则会创建一个自定义的标签，注意：IE8以下浏览器不支持自定义标签。<br>使用如下：</p>
<p><img src="/images/微信截图_20190326211640.png" alt></p>
<p>使用createElement要注意：通过createElement创建的元素并不属于html文档，它只是创建出来，并未添加到html文档中，要调用appendChild或insertBefore等方法将其添加到HTML文档树中。</p>
<h3 id="creatTextNode"><a href="#creatTextNode" class="headerlink" title="creatTextNode"></a>creatTextNode</h3><p>createTextNode用来创建一个文本节点，用法如下：</p>
<p><img src="/images/微信截图_20190326211806.png" alt></p>
<p>createTextNode接收一个参数，这个参数就是文本节点中的文本，和createElement一样，创建后的文本节点也只是独立的一个节点，同样需要appendChild将其添加到HTML文档树中</p>
<h3 id="cloneNode"><a href="#cloneNode" class="headerlink" title="cloneNode"></a>cloneNode</h3><p>cloneNode是用来返回调用方法的节点的一个副本，它接收一个bool参数，用来表示是否复制子元素，使用如下：</p>
<p><img src="/images/微信截图_20190326211949.png" alt></p>
<p>这段代码通过cloneNode复制了一份parent元素，其中cloneNode的参数为true，表示parent的子节点也被复制，如果传入false，则表示只复制了parent节点。</p>
<h3 id="createDocumentFragment"><a href="#createDocumentFragment" class="headerlink" title="createDocumentFragment"></a>createDocumentFragment</h3><p>createDocumentFragment方法用来创建一个DocumentFragment。在前面我们说到DocumentFragment表示一种轻量级的文档，它的作用主要是存储临时的节点用来准备添加到文档中。<br>createDocumentFragment方法主要是用于添加大量节点到文档中时会使用到。假设要循环一组数据，然后创建多个节点添加到文档中，比如</p>
<p><img src="/images/微信截图_20190326212508.png" alt></p>
<p>这段代码将按钮绑定了一个事件，这个事件创建了100个li节点，然后依次将其添加HTML文档中。这样做有一个缺点：每次一创建一个新的元素，然后添加到文档树中，这个过程会造成浏览器的回流。所谓回流简单说就是指元素大小和位置会被重新计算，如果添加的元素太多，会造成性能问题。这个时候，就是使用createDocumentFragment了。<br>DocumentFragment不是文档树的一部分，它是保存在内存中的，所以不会造成回流问题。我们修改上面的代码如下：</p>
<p><img src="/images/微信截图_20190326212552.png" alt></p>
<p>优化后的代码主要是创建了一个fragment，每次生成的li节点先添加到fragment，最后一次性添加到list。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>创建型api主要包括createElement，createTextNode，cloneNode和createDocumentFragment四个方法，需要注意下面几点：<br>（1）它们创建的节点只是一个孤立的节点，要通过appendChild添加到文档中<br>（2）cloneNode要注意如果被复制的节点是否包含子节点以及事件绑定等问题<br>（3）使用createDocumentFragment来解决添加大量节点时的性能问题</p>
<h2 id="页面修改型api"><a href="#页面修改型api" class="headerlink" title="页面修改型api"></a>页面修改型api</h2><p>前面我们提到创建型api，它们只是创建节点，并没有真正修改到页面内容，而是要调用appendChild来将其添加到文档树中。我在这里将这类会修改到页面内容归为一类。<br>修改页面内容的api主要包括：appendChild，insertBefore，removeChild，replaceChild。</p>
<h3 id="appendChild"><a href="#appendChild" class="headerlink" title="appendChild"></a>appendChild</h3><p>appendChild我们在前面已经用到多次，就是将指定的节点添加到调用该方法的节点的子元素的末尾。调用方法如下：</p>
<p><img src="/images/微信截图_20190326215130.png" alt></p>
<p>child节点将会作为parent节点的最后一个子节点。<br>appendChild这个方法很简单，但是还有有一点需要注意：如果被添加的节点是一个页面中存在的节点，则执行后这个节点将会添加到指定位置，其原本所在的位置将移除该节点，也就是说不会同时存在两个该节点在页面上，相当于把这个节点移动到另一个地方。</p>
<p><img src="/images/微信截图_20190326215157.png" alt></p>
<p>这段代码主要是获取页面上的child节点，然后添加到指定位置，可以看到原本的child节点被移动到parent中了。<br>这里还有一个要注意的点：如果child绑定了事件，被移动时，它依然绑定着该事件。</p>
<h3 id="insertBefore"><a href="#insertBefore" class="headerlink" title="insertBefore"></a>insertBefore</h3><p>insertBefore用来添加一个节点到一个参照节点之前，用法如下：</p>
<p><img src="/images/微信截图_20190326215252.png" alt></p>
<p>parentNode表示新节点被添加后的父节点<br>newNode表示要添加的节点<br>refNode表示参照节点，新节点会添加到这个节点之前</p>
<p><img src="/images/微信截图_20190326220207.png" alt></p>
<p>这段代码创建了一个新节点，然后添加到child节点之前。<br>和appendChild一样，如果插入的节点是页面上的节点，则会移动该节点到指定位置，并且保留其绑定的事件。</p>
<h3 id="removeChild"><a href="#removeChild" class="headerlink" title="removeChild"></a>removeChild</h3><p>删除指定的子节点并返回</p>
<p><img src="/images/微信截图_20190327081353.png" alt></p>
<p>deletedChild指向被删除节点的引用，它等于node，被删除的节点仍然存在于内存中，可以对其进行下一步操作。<br>注意：如果被删除的节点不是其子节点，则程序将会报错。我们可以通过下面的方式来确保可以删除：</p>
<p><img src="/images/微信截图_20190327081502.png" alt></p>
<p>通过节点自己获取节点的父节点，然后将自身删除。</p>
<h3 id="replaceChild"><a href="#replaceChild" class="headerlink" title="replaceChild"></a>replaceChild</h3><p>replaceChild用于使用一个节点替换另一个节点</p>
<p><img src="/images/微信截图_20190327081705.png" alt></p>
<p>newChild是替换的节点，可以是新的节点，也可以是页面上的节点，如果是页面上的节点，则其将被转移到新的位置<br>oldChild是被替换的节点</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>页面修改型api主要是这四个接口，要注意几个特点：<br>（1）不管是新增还是替换节点，如果新增或替换的节点是原本存在页面上的，则其原来位置的节点将被移除，也就是说同一个节点不能存在于页面的多个位置<br>（2）节点本身绑定的事件会不会消失，会一直保留着。</p>
<h2 id="节点查询型api"><a href="#节点查询型api" class="headerlink" title="节点查询型api"></a>节点查询型api</h2><h3 id="document-getElementById"><a href="#document-getElementById" class="headerlink" title="document.getElementById"></a>document.getElementById</h3><p>这个接口很简单，根据元素id返回元素，返回值是Element类型，如果不存在该元素，则返回null。<br>使用这个接口有几点要注意：<br>（1）元素的Id是大小写敏感的，一定要写对元素的id<br>（2）HTML文档中可能存在多个id相同的元素，则返回第一个元素<br>（3）只从文档中进行搜索元素，如果创建了一个元素并指定id，但并没有添加到文档中，则这个元素是不会被查找到的</p>
<h3 id="document-getElementsByTagName"><a href="#document-getElementsByTagName" class="headerlink" title="document.getElementsByTagName"></a>document.getElementsByTagName</h3><p>这个接口根据元素标签名获取元素，返回一个即时的HTMLCollection类型</p>
<p><img src="/images/微信截图_20190327082348.png" alt></p>
<h3 id="document-getElementsByName"><a href="#document-getElementsByName" class="headerlink" title="document.getElementsByName"></a>document.getElementsByName</h3><p>getElementsByName主要是通过指定的name属性来获取元素，它返回一个即时的NodeList对象。<br>使用这个接口主要要注意几点：<br>（1）返回对象是一个即时的NodeList，它是随时变化的<br>（2）在HTML元素中，并不是所有元素都有name属性，比如div是没有name属性的，但是如果强制设置div的name属性，它也是可以被查找到的<br>（3）在IE中，如果id设置成某个值，然后传入getElementsByName的参数值和id值一样，则这个元素是会被找到的，所以最好不好设置同样的值给id和name</p>
<h3 id="document-getElementsByClassName"><a href="#document-getElementsByClassName" class="headerlink" title="document.getElementsByClassName"></a>document.getElementsByClassName</h3><p>这个api是根据元素的class返回一个即时的HTMLCollection<br>这个接口有下面几点要注意：<br>（1）返回结果是一个即时的HTMLCollection，会随时根据文档结构变化<br>（2）IE9以下浏览器不支持<br>（3）如果要获取2个以上classname，可传入多个classname，每个用空格相隔</p>
<h3 id="document-querySelector和document-querySelectorAll"><a href="#document-querySelector和document-querySelectorAll" class="headerlink" title="document.querySelector和document.querySelectorAll"></a>document.querySelector和document.querySelectorAll</h3><p>这两个api很相似，通过css选择器来查找元素，注意选择器要符合CSS选择器的规则。<br>首先来介绍一下document.querySelector。<br>document.querySelector返回第一个匹配的元素，如果没有匹配的元素，则返回null。<br>注意，由于返回的是第一个匹配的元素，这个api使用的深度优先搜索来获取元素</p>
<p><img src="/images/微信截图_20190327082603.png" alt></p>
<p>document.querySelectorAll的不同之处在于它返回的是所有匹配的元素，而且可以匹配多个选择符</p>
<p><img src="/images/微信截图_20190327082751.png" alt></p>
<p>这段代码通过querySelectorAll，使用id选择器和class选择器选择了两个元素，并依次输出其内容。要注意两点：<br>（1）querySelectorAll也是通过深度优先搜索，搜索的元素顺序和选择器的顺序无关<br>（2）返回的是一个非即时的NodeList，也就是说结果不会随着文档树的变化而变化</p>
<h2 id="节点关系型api"><a href="#节点关系型api" class="headerlink" title="节点关系型api"></a>节点关系型api</h2><p>在html文档中的每个节点之间的关系都可以看成是家谱关系，包含父子关系，兄弟关系等等</p>
<h3 id="父关系型api"><a href="#父关系型api" class="headerlink" title="父关系型api"></a>父关系型api</h3><p>parentNode：每个节点都有一个parentNode属性，它表示元素的父节点。Element的父节点可能是Element，Document或DocumentFragment。<br>parentElement：返回元素的父元素节点，与parentNode的区别在于，其父节点必须是一个Element，如果不是，则返回null</p>
<h3 id="兄弟关系型api"><a href="#兄弟关系型api" class="headerlink" title="兄弟关系型api"></a>兄弟关系型api</h3><p>previousSibling：节点的前一个节点，如果该节点是第一个节点，则为null。注意有可能拿到的节点是文本节点或注释节点，与预期的不符，要进行处理一下。<br>previousElementSibling：返回前一个元素节点，前一个节点必须是Element，注意IE9以下浏览器不支持。<br>nextSibling：节点的后一个节点，如果该节点是最后一个节点，则为null。注意有可能拿到的节点是文本节点，与预期的不符，要进行处理一下。<br>nextElementSibling：返回后一个元素节点，后一个节点必须是Element，注意IE9以下浏览器不支持。</p>
<h3 id="子关系型api"><a href="#子关系型api" class="headerlink" title="子关系型api"></a>子关系型api</h3><p>childNodes：返回一个即时的NodeList，表示元素的子节点列表，子节点可能会包含文本节点，注释节点等。<br>children：一个即时的HTMLCollection，子节点都是Element，IE9以下浏览器不支持。<br>firstNode：第一个子节点<br>lastNode：最后一个子节点<br>hasChildNodes方法：可以用来判断是否包含子节点。</p>
<h2 id="元素属性型api"><a href="#元素属性型api" class="headerlink" title="元素属性型api"></a>元素属性型api</h2><h3 id="setAttribute"><a href="#setAttribute" class="headerlink" title="setAttribute"></a>setAttribute</h3><p>setAttribute：根据名称和值修改元素的特性</p>
<p><img src="/images/微信截图_20190327085000.png" alt></p>
<p>其中name是特性名，value是特性值。如果元素不包含该特性，则会创建该特性并赋值。<br>如果元素本身包含指定的特性名为属性，则可以直接访问属性进行赋值，比如下面两条代码是等价的：</p>
<p><img src="/images/微信截图_20190327085036.png" alt></p>
<h3 id="getAttribute"><a href="#getAttribute" class="headerlink" title="getAttribute"></a>getAttribute</h3><p>getAttribute返回指定的特性名相应的特性值，如果不存在，则返回null或空字符串</p>
<p><img src="/images/微信截图_20190327085124.png" alt></p>
<h1 id="DOM-自测"><a href="#DOM-自测" class="headerlink" title="DOM 自测"></a>DOM 自测</h1><pre><code>如何获取一个元素的爸爸节点：
var divParent = div._?_
// parentNode
// parentElement

如何检测一个元素是文字还是标签？
var isElement = div.__?__  === 1
// nodeType

如何获取一个元素的所有子代标签（标签不包含文本）
let children = div.____?____
// children

如何获取一个元素的所有子代节点（节点包括标签和文字）
let children = div.____?____
// childNodes

如何获取一个div标签的下一个标签？
// div.nextSibling 获取的有可能是文字，需要不停访问 nextSibling 直到获取到一个 nodeType 为 1 的节点才行

如何获取一个div标签的所有同级（兄弟）标签？
// 声明空数组 siblings，遍历 div.parentNode.children，将 div 以外的元素 push 到数组里
</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要总结了原生js中常用的操作DOM的api接口，主要为了复习基础知识。平时开发用多了jQuery等类库，对基础知识的了解可能就渐渐地遗忘，但这些基础知识才是我们立足的根本，只有掌握原生的js，才能真正做好js的开发。</p>
]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>初探jQuery</title>
    <url>/2019/04/01/%E5%88%9D%E6%8E%A2jQuery/</url>
    <content><![CDATA[<h1 id="想要用好jQuery，就得知道它的原理，下面来试着一步步的自己封装一个jQuery函数api"><a href="#想要用好jQuery，就得知道它的原理，下面来试着一步步的自己封装一个jQuery函数api" class="headerlink" title="想要用好jQuery，就得知道它的原理，下面来试着一步步的自己封装一个jQuery函数api"></a>想要用好jQuery，就得知道它的原理，下面来试着一步步的自己封装一个jQuery函数api</h1><a id="more"></a>
<h1 id="封装函数1"><a href="#封装函数1" class="headerlink" title="封装函数1"></a>封装函数1</h1><p>首先在<code>html</code>里写入一组列表</p>
<pre><code class="html">&lt;ul&gt;
  &lt;li id=&quot;item1&quot;&gt;选项1&lt;/li&gt;
  &lt;li id=&quot;item2&quot;&gt;选项2&lt;/li&gt;
  &lt;li id=&quot;item3&quot;&gt;选项3&lt;/li&gt;
  &lt;li id=&quot;item4&quot;&gt;选项4&lt;/li&gt;
  &lt;li id=&quot;item5&quot;&gt;选项5&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>试着获取一下<code>item3</code>的兄弟姐妹</p>
<pre><code class="JavaScript">var allChildren = item3.parentNode.children
var array = { length: 0 }
for (let i = 0; i &lt; allChildren.length; i++) {
    if (allChildren[i] !== item3) {
        array[array.length] = allChildren[i]
        array.length += 1
    }
}
console.log(array)
</code></pre>
<p>获取其父节点的所有子节点，<code>children</code>只获取元素节点，不获取文本节点，建立一个空的伪数组，遍历，如果不是<code>item3</code>，则数组就为其兄弟姐妹 这里<code>array[]</code>中不能写<code>i</code> 否则会空过<code>3</code>，循环结束后加<code>1</code> </p>
<p>于是获得数组 </p>
<pre><code>{0: li#item1, 1: li#item2, 2: li#item4, 3: li#item5, length: 4}
0: li#item1
1: li#item2
2: li#item4
3: li#item5
length: 4
__proto__: Object
</code></pre><p>接着对代码做一个封装</p>
<pre><code class="JavaScript">function getSiblings(node) {
    var allChildren = node.parentNode.children
    var array = { length: 0 }
    for (let i = 0; i &lt; allChildren.length; i++) {
        if (allChildren[i] !== node) {
            array[array.length] = allChildren[i]
            array.length += 1
        }
    }
    return array
}
getSiblings(item3)
</code></pre>
<p>命名一个函数<code>function</code>为<code>getSiblings</code>，设定参数为<code>node</code>，则将原来的<code>item3</code>全部换成<code>node</code>，最后返回<code>array</code>数组</p>
<h1 id="封装函数2"><a href="#封装函数2" class="headerlink" title="封装函数2"></a>封装函数2</h1><p>添加<code>class</code></p>
<pre><code class="JavaScript">function addClass(node, classes){
    for(let key in classes){
        var value = classes[key]
        if(value){
            node.classList.add(key)
        }else{
            node.classList.remove(key)
        }
    }
}
addClass(item3, {a:true, b:false, c:true})
</code></pre>
<p>命名函数为addClass，并给定两个参数node，classes，用for…in循环，当value为true时则添加key，反之不添加</p>
<p>对以上代码做一个优化</p>
<pre><code class="JavaScript">function addClass(node, classes){
    for(let key in classes){
        var value = classes[key]
        var methodName = value ? &#39;add&#39; : &#39;remove&#39;
        node.classList[methodName](key)
    }
}
addClass(item3, {a:true, b:false, c:true})
</code></pre>
<h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><pre><code class="JavaScript">window.yhdom = {}
yhdom.getSiblings = getSiblings
yhdom.addClass = addClass

yhdom.getSiblings(item3)
yhdom.addClass(item3, {a:true, b:false, c:true})
</code></pre>
<p>优化全部代码</p>
<pre><code class="JavaScript">window.yhdom = {}
yhdom.getSiblings = function (node) {
    var allChildren = node.parentNode.children
    var array = { length: 0 }
    for (let i = 0; i &lt; allChildren.length; i++) {
        if (allChildren[i] !== node) {
            array[array.length] = allChildren[i]
            array.length += 1
        }
    }
    return array
}
yhdom.addClass = function (node, classes){
    for(let key in classes){
        var value = classes[key]
        var methodName = value ? &#39;add&#39; : &#39;remove&#39;
        node.classList[methodName](key)
    }
}
yhdom.getSiblings(item3)
yhdom.addClass(item3, {a:true, b:false, c:true})
</code></pre>
<h1 id="公有属性"><a href="#公有属性" class="headerlink" title="公有属性"></a>公有属性</h1><pre><code class="JavaScript">Node.prototype.getSiblings = function(){
    var allChildren = this.parentNode.children
    var array = { length: 0 }
    for (let i = 0; i &lt; allChildren.length; i++) {
        if (allChildren[i] !== this) {
            array[array.length] = allChildren[i]
            array.length += 1
        }
    }
    return array
}
console.log(item3.getSiblings())
</code></pre>
<p>将之前的<code>node</code>改为<code>this</code>，<code>this</code>就表示调用函数的第一个参数也就是<code>item3</code><br>同理修改第二个代码</p>
<pre><code class="JavaScript">Node.prototype.addClass = function(classes){
    for(let key in classes){
        var value = classes[key]
        var methodName = value ? &#39;add&#39; : &#39;remove&#39;
        this.classList[methodName](key)
    }
}
item3.addClass({a:true, b:false, c:true})
</code></pre>
<h1 id="不修改公有属性，自己设置属性"><a href="#不修改公有属性，自己设置属性" class="headerlink" title="不修改公有属性，自己设置属性"></a>不修改公有属性，自己设置属性</h1><pre><code class="JavaScript">window.Node2 = function (node) {
    return {
        getSiblings: function () {
            var allChildren = node.parentNode.children
            var array = { length: 0 }
            for (let i = 0; i &lt; allChildren.length; i++) {
                if (allChildren[i] !== node) {
                    array[array.length] = allChildren[i]
                    array.length += 1
                }
            }
            return array
        },
        addClass: function (classes) {
            for (let key in classes) {
                var value = classes[key]
                var methodName = value ? &#39;add&#39; : &#39;remove&#39;
                node.classList[methodName](key)
            }
        }
    }
}
var node2 = Node2(item3)
node2.getSiblings()
node2.addClass({ a: true, b: false, c: true })
</code></pre>
<p>如果不是<code>node</code>，而是一个字符串或者选择器，贼需要更改代码</p>
<pre><code class="JavaScript">window.jQuery = function (nodeOrSelector) {
    let node
    if(typeof nodeOrSelector === &#39;string&#39;){
        node = document.querySelector(nodeOrSelector)
    }else{
        node = nodeOrSelector
    }

    return {
        getSiblings: function () {
            var allChildren = node.parentNode.children
            var array = { length: 0 }
            for (let i = 0; i &lt; allChildren.length; i++) {
                if (allChildren[i] !== node) {
                    array[array.length] = allChildren[i]
                    array.length += 1
                }
            }
            return array
        },
        addClass: function (classes) {
            for (let key in classes) {
                var value = classes[key]
                var methodName = value ? &#39;add&#39; : &#39;remove&#39;
                node.classList[methodName](key)
            }
        }
    }
}
var node2 = jQuery(&#39;#item3&#39;)
node2.getSiblings()
node2.addClass({ red: true, b: false, c: true })
</code></pre>
<h1 id="获取全部节点"><a href="#获取全部节点" class="headerlink" title="获取全部节点"></a>获取全部节点</h1><pre><code class="JavaScript">window.jQuery = function(nodeOrSelector){
    let nodes = {}
    if(typeof nodeOrSelector === &#39;string&#39;){
        let temp = document.querySelectorAll(nodeOrSelector)
        for(let i=0; i&lt;temp.length; i++){
            nodes[i] = temp[i]
        }
        nodes.length = temp.length
    }else if(nodeOrSelector instanceof Node){
        nodes = { 0: nodeOrSelector, length: 1 }
    }
    nodes.addClass = function(classes){
        classes.forEach((value) =&gt; {
            for(let i=0; i&lt;nodes.length; i++){
                nodes[i].classList.add(value)
            }
        })
    }
    nodes.getText = function(){
        var texts = []
        for(let i=0; i&lt;nodes.length; i++){
            TextMetrics.PushManager(nodes[i].textContent)
        }
        return texts
    }
    nodes.setText = function(text){
        for(let i=0; i&lt;nodes.length; i++){
            nodes[i].textContent = text
        }
    }
    return nodes
}

var node2 = jQuery(&#39;ul&gt;li&#39;)
node2.addClass([&#39;red&#39;])
node2.setText(&#39;hi&#39;)
</code></pre>
<p>优化代码</p>
<pre><code class="JavaScript">nodes.text = function(text){
    if(text === undefined){
        var texts = []
    for(let i=0; i&lt;nodes.length; i++){
        TextMetrics.PushManager(nodes[i].textContent)
    }
    return texts
    }else{
        for(let i=0; i&lt;nodes.length; i++){
            nodes[i].textContent = text
        }
      }
    }
    return nodes
}

var node2 = jQuery(&#39;ul&gt;li&#39;)
var text = node2.text()
node2.text(&#39;hi&#39;)
</code></pre>
<p>不给参数就是获取，给参数就是设置</p>
<h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><pre><code class="JavaScript">window.jQuery = ???
window.$ = jQuery

var $div = $(&#39;div&#39;)
$div.addClass(&#39;red&#39;) // 可将所有 div 的 class 添加一个 red
$div.setText(&#39;hi&#39;) // 可将所有 div 的 textContent 变为 hi
</code></pre>
<pre><code class="JavaScript">window.jQuery = function (nodeOrSelector) {
    let nodes = {}
    if (typeof nodeOrSelector === &#39;string&#39;) {
        let temp = document.querySelectorAll(nodeOrSelector)
        for (let i = 0; i &lt; temp.length; i++) {
            nodes[i] = temp[i]
        }
        nodes.length = temp.length
    } else if (nodeOrSelector instanceof Node) {
        nodes = { 0: nodeOrSelector, length: 1 }
    }
    nodes.addClass = function (classes) {
        classes.forEach((value) =&gt; {
            for (let i = 0; i &lt; nodes.length; i++) {
                nodes[i].classList.add(value)
            }
        })
    }
    nodes.text = function (text) {
        if (text === undefined) {
            var texts = []
            for (let i = 0; i &lt; nodes.length; i++) {
                TextMetrics.PushManager(nodes[i].textContent)
            }
            return texts
        } else {
            for (let i = 0; i &lt; nodes.length; i++) {
                nodes[i].textContent = text
            }
        }
    }
    return nodes
}
window.$ = jQuery

var $div = $(&#39;div&#39;)
$div.addClass([&#39;red&#39;])
$div.text(&#39;hi&#39;)
</code></pre>
]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>面试小结Ⅰ</title>
    <url>/2019/04/05/%E9%9D%A2%E8%AF%95%E5%B0%8F%E7%BB%931/</url>
    <content><![CDATA[<p><strong>总结一些面试需要准备的知识点</strong><br><a id="more"></a></p>
<h1 id="第-1-题"><a href="#第-1-题" class="headerlink" title="第 1 题"></a>第 1 题</h1><h2 id="请写出一个符合-W3C-规范的-HTML-文件，要求："><a href="#请写出一个符合-W3C-规范的-HTML-文件，要求：" class="headerlink" title="请写出一个符合 W3C 规范的 HTML 文件，要求："></a>请写出一个符合 W3C 规范的 HTML 文件，要求：</h2><p>页面标题为「我的页面」<br>页面中引入了一个外部 CSS 文件，文件路径为 /style.css<br>页面中引入了另一个外部 CSS 文件，路径为 /print.css，该文件仅在打印时生效<br>页面中引入了另一个外部 CSS 文件，路径为 /mobile.css，该文件仅在设备宽度小于 500 像素时生效<br>页面中引入了一个外部 JS 文件，路径为 /main.js<br>页面中引入了一个外部 JS 文件，路径为 /gbk.js，文件编码为 GBK<br>页面中有一个 SVG 标签，SVG 里面有一个直径为 100 像素的圆圈，颜色随意<br>注意题目中的路径</p>
<h2 id="答："><a href="#答：" class="headerlink" title="答："></a>答：</h2><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;zh-hans&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1, minimum-scale=1&#39;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;我的页面&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;./style.css&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;./print.css&quot; media=&quot;print&quot; &gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;./style.css&quot; media=&quot;(max=width: 500px)&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;svg version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
        &lt;circle cx=&quot;100&quot; cy=&quot;100&quot; r=&quot;50&quot;  fill=&quot;red&quot;/&gt;
    &lt;/svg&gt;
    &lt;scripe type=&quot;text/javascript&quot; src=&quot;./main.js&quot;&gt;&lt;/script&gt;
    &lt;scripe type=&quot;text/javascript&quot; src=&quot;./gbk.js&quot; charset=&quot;GBK&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h1 id="第-2-题"><a href="#第-2-题" class="headerlink" title="第 2 题"></a>第 2 题</h1><h2 id="移动端是怎么做适配的？"><a href="#移动端是怎么做适配的？" class="headerlink" title="移动端是怎么做适配的？"></a>移动端是怎么做适配的？</h2><p>回答要点：<br>1.meta viewport<br>2.媒体查询<br>3.动态 rem 方案</p>
<h2 id="答：-1"><a href="#答：-1" class="headerlink" title="答："></a>答：</h2><h3 id="1-meta-viewport"><a href="#1-meta-viewport" class="headerlink" title="1.meta viewport"></a>1.meta viewport</h3><p>什么是<code>viewport</code>？手机浏览器会把页面放入到一个虚拟的“视口”（viewpoint）中，但viewport又不局限于浏览器可视区域的大小，它可能比浏览器的可视区域大，也可能比浏览器的可视区域小。通常这个虚拟的“视口”比屏幕宽，会把网页挤到一个很小的窗口，以此来适配屏幕较小的移动端。</p>
<pre><code class="html">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;&gt;
</code></pre>
<ul>
<li><code>width</code>：设置viewport 的宽度，默认视口宽度</li>
<li><code>initial-scale</code>：设置页面的初始缩放值</li>
<li><code>maximum-scale</code>：允许用户的最大缩放值</li>
<li><code>minimum-scale</code>：允许用户的最小缩放值</li>
<li><code>user-scalable</code>：是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes代表允许</li>
</ul>
<h3 id="2-媒体查询"><a href="#2-媒体查询" class="headerlink" title="2.媒体查询"></a>2.媒体查询</h3><p>一个媒体查询由一个可选的媒体类型和零个或多个使用媒体功能的限制了样式表范围的表达式组成，例如宽度、高度和颜色。媒体查询，添加自<code>CSS3</code>，允许内容的呈现针对一个特定范围的输出设备而进行裁剪，而不必改变内容本身。</p>
<pre><code class="html">&lt;!-- link元素中的CSS媒体查询 --&gt;
&lt;link rel=&quot;stylesheet&quot; media=&quot;(max-width: 375px)&quot; href=&quot;./phone.css&quot; /&gt;

&lt;!-- 样式表中的CSS媒体查询 --&gt;
&lt;style&gt; @media (max-width: 375px) {...} &lt;/style&gt;
</code></pre>
<p>当媒体查询为<code>true</code>时，其对应的样式表或样式规则就会遵循正常的级联规则进行应用。也就是说当满足所设定的条件时，后面的css样式就会生效。</p>
<h3 id="3-动态rem方案"><a href="#3-动态rem方案" class="headerlink" title="3.动态rem方案"></a>3.动态rem方案</h3><p><code>rem</code>是CSS3新增的相对长度单位，是指相对于根元素<code>html</code>的<code>font-size</code>计算值的大小。<br><code>rem</code>既可以等比例缩放根元素以外的元素字体大小，又可以对屏幕宽度进行适配。</p>
<pre><code class="css">html { font-size: 14px; }
p { font-size: 2rem; } // 相当于2* 14px = 28px
</code></pre>
<pre><code class="html"> &lt;script&gt;
     var pageWidth = window.innerWidth
     document.write(&#39;&lt;style&gt;html{font-size:&#39;+pageWidth+&#39;px;}&lt;/style&gt;&#39;)
 &lt;/script&gt; //使用 JS 动态调整 REM
</code></pre>
<pre><code class="js">@function px( $px ){
  @return $px/$designWidth*10 + rem;
}

$designWidth : 640; // 640 是设计稿的宽度。

.child{ width: px(320); height: px(160); margin: px(40) px(40); border: 1px solid red; float: left; font-size: 1.2em; } //scss中实现px自动转rem
</code></pre>
<h1 id="第-3-题"><a href="#第-3-题" class="headerlink" title="第 3 题"></a>第 3 题</h1><h2 id="用过CSS3吗-实现圆角矩形和阴影怎么做"><a href="#用过CSS3吗-实现圆角矩形和阴影怎么做" class="headerlink" title="用过CSS3吗? 实现圆角矩形和阴影怎么做?"></a>用过CSS3吗? 实现圆角矩形和阴影怎么做?</h2><h2 id="答：-2"><a href="#答：-2" class="headerlink" title="答："></a>答：</h2><h3 id="圆角矩形的实现"><a href="#圆角矩形的实现" class="headerlink" title="圆角矩形的实现"></a>圆角矩形的实现</h3><p>css3中使用<code>border-radius</code>来设置边框圆角</p>
<pre><code class="css">border-radius: 5px;
</code></pre>
<p>只设置一个值则表示将四个角都变为圆角<br>也可以单独设置一个或多个角<br>顺序是<code>top-left</code> <code>top-right</code> <code>bottom-right</code> <code>bottom-left</code></p>
<h3 id="阴影实现"><a href="#阴影实现" class="headerlink" title="阴影实现"></a>阴影实现</h3><pre><code class="css">box-shadow:inset offset-x offset-y blur-radius spread-radius color
</code></pre>
<p>参数</p>
<ul>
<li><code>inset</code> 默认阴影由内向外，设置<code>inset</code>后阴影在边框内</li>
<li><code>offset-x offset-y</code> x,y的偏移量，正值则向右向下，负值则向左向上</li>
<li><code>blur-radius</code> 默认为0，值越大，模糊面积越大，没有负值</li>
<li><code>spread-radius</code> 默认为0，正值，阴影扩大，负值，阴影收缩</li>
<li><code>color</code> 阴影颜色</li>
</ul>
<h1 id="第-4-题"><a href="#第-4-题" class="headerlink" title="第 4 题"></a>第 4 题</h1><h2 id="什么是闭包，闭包的用途是什么？"><a href="#什么是闭包，闭包的用途是什么？" class="headerlink" title="什么是闭包，闭包的用途是什么？"></a>什么是闭包，闭包的用途是什么？</h2><h2 id="答：-3"><a href="#答：-3" class="headerlink" title="答："></a>答：</h2><h3 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h3><pre><code class="js">var a = 1
function f(){
    console.log(a)
}
</code></pre>
<p>上面三行代码处于一个立即执行函数中<br>声明一个局部变量<code>a</code>，一个函数<code>f</code>，在函数<code>f</code>中打印出<code>a</code>的值<br>函数<code>f</code>可以调用到函数外的<code>a</code>的值<br>ok 这就是一个闭包<br>如果一个函数，使用了它作用域外的变量，那么（这个函数+这个变量）就叫做闭包</p>
<h3 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h3><ul>
<li><p>在函数外部读取内部的变量</p>
<pre><code class="js">function f1() {
var a = 5
function f2() {
  console.log(a)
}
return f2
} 
var price = f1()
price() // 5
</code></pre>
<p>函数f1的返回值是f2，f2与a形成闭包，即可以在外部读取f1的变量值</p>
</li>
<li><p>让变量暂时保存在内存中</p>
<pre><code class="js">function f(i) {
return function () {
  return i++
}
}
var a = f(1)
a() // 1
a() // 2
a() // 3
</code></pre>
<p>闭包使内部变量记住上一次调用时的运算结果</p>
</li>
</ul>
<h1 id="第-5-题"><a href="#第-5-题" class="headerlink" title="第 5 题"></a>第 5 题</h1><h2 id="call、apply、bind-的用法分别是什么？"><a href="#call、apply、bind-的用法分别是什么？" class="headerlink" title="call、apply、bind 的用法分别是什么？"></a>call、apply、bind 的用法分别是什么？</h2><h2 id="答：-4"><a href="#答：-4" class="headerlink" title="答："></a>答：</h2><pre><code class="js">function reduce(a,b){
    return a-b }
</code></pre>
<p><code>call</code>: <code>call</code>是函数的正常调用方式，指定上下文<code>this</code>，括号内第一个参数为<code>this</code>，第二个参数接受连续参数<br><code>reduce.call(reduce, 3, 2) //1</code></p>
<p><code>apply</code>: <code>apply</code>的作用和<code>call</code>一样，区别在于<code>apply</code>接受的是数组参数<br><code>reduce.apply(reduce, [3, 2]) //1</code></p>
<p><code>bind</code>：<code>bind</code>接受的参数跟<code>call</code>一致，只是<code>bind</code>不会立即调用，它会生成一个新的函数，想什么时候调就什么时候调<br><code>var f = reduce.bind(reduce, 3,2)</code> <code>f() //1</code></p>
<h1 id="第-6-题"><a href="#第-6-题" class="headerlink" title="第 6 题"></a>第 6 题</h1><h2 id="请说出至少-8-个-HTTP-状态码，并描述各状态码的意义"><a href="#请说出至少-8-个-HTTP-状态码，并描述各状态码的意义" class="headerlink" title="请说出至少 8 个 HTTP 状态码，并描述各状态码的意义"></a>请说出至少 8 个 HTTP 状态码，并描述各状态码的意义</h2><h2 id="答：-5"><a href="#答：-5" class="headerlink" title="答："></a>答：</h2><h3 id="1xx-信息响应"><a href="#1xx-信息响应" class="headerlink" title="1xx 信息响应"></a>1xx 信息响应</h3><p><code>100 Continue</code><br>这个临时响应表明，迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。<br><code>101 Switching Protocol</code><br>该代码是响应客户端的 Upgrade 标头发送的，并且指示服务器也正在切换的协议。</p>
<h3 id="2xx-成功响应"><a href="#2xx-成功响应" class="headerlink" title="2xx 成功响应"></a>2xx 成功响应</h3><p><code>200 OK</code><br>请求成功。<br><code>201 Created</code><br>该请求已成功，并因此创建了一个新的资源。这通常是在PUT请求之后发送的响应。<br><code>202 Accepted</code><br>请求已经接收到，但还未响应，没有结果。</p>
<h3 id="3xx-重定向"><a href="#3xx-重定向" class="headerlink" title="3xx 重定向"></a>3xx 重定向</h3><p><code>300 Multiple Choice</code><br>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。<br><code>302 Found</code><br>请求的资源现在临时从不同的 URI 响应请求。</p>
<h3 id="4xx-客户端响应"><a href="#4xx-客户端响应" class="headerlink" title="4xx 客户端响应"></a>4xx 客户端响应</h3><p><code>400 Bad Request</code><br>1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。<br>2、请求参数有误。<br><code>401 Unauthorized</code><br>当前请求需要用户验证。<br><code>403 Forbidden</code><br>服务器已经理解请求，但是拒绝执行它。<br><code>404 Not Found</code><br>请求失败，请求所希望得到的资源未被在服务器上发现。</p>
<h3 id="5xx-服务端响应"><a href="#5xx-服务端响应" class="headerlink" title="5xx 服务端响应"></a>5xx 服务端响应</h3><p><code>500 Internal Server Error</code><br>服务器遇到了不知道如何处理的情况。<br><code>501 Not Implemented</code><br>此请求方法不被服务器支持且无法被处理。<br><code>502 Bad Gateway</code><br>此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应。<br><code>503 Service Unavailable</code><br>服务器没有准备好处理请求。 </p>
<h1 id="第-7-题"><a href="#第-7-题" class="headerlink" title="第 7 题"></a>第 7 题</h1><h2 id="请写出一个-HTTP-post-请求的内容，包括四部分。"><a href="#请写出一个-HTTP-post-请求的内容，包括四部分。" class="headerlink" title="请写出一个 HTTP post 请求的内容，包括四部分。"></a>请写出一个 HTTP post 请求的内容，包括四部分。</h2><p>其中<br>第四部分的内容是 username=ff&amp;password=123<br>第二部分必须含有 Content-Type 字段<br>请求的路径为 /path</p>
<h2 id="答：-6"><a href="#答：-6" class="headerlink" title="答："></a>答：</h2><blockquote>
<p>1 POST /path HTTP/1.1<br>  2 Host: <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a><br>  2 User-Agent: curl/7.54.0<br>  2 Accept: <em>/</em><br>  2 Content-Length: 24<br>  2 Content-Type: application/x-www-form-urlencoded<br>  3<br>  4 username=ff&amp;password=123</p>
</blockquote>
<h1 id="第-8-题"><a href="#第-8-题" class="headerlink" title="第 8 题"></a>第 8 题</h1><h2 id="请说出至少三种排序的思路，这三种排序的时间复杂度分别为"><a href="#请说出至少三种排序的思路，这三种排序的时间复杂度分别为" class="headerlink" title="请说出至少三种排序的思路，这三种排序的时间复杂度分别为"></a>请说出至少三种排序的思路，这三种排序的时间复杂度分别为</h2><ol>
<li>O(n*n)</li>
<li>O(n log2 n)</li>
<li>O(n + max)</li>
</ol>
<h2 id="答：-7"><a href="#答：-7" class="headerlink" title="答："></a>答：</h2><ol>
<li>冒泡排序<br>一个数组从左到右，1和2,2和3,3和4等等依次类推两两比较，较小的数在前，较大的数在后，第一轮过后则这个数组最大的数排在最后，下一轮则从头开始重新比较，直到排序完成</li>
<li>快速排序<br>将任意一个数作为‘基准’（参照），然后将其他所有数与其比较，比它小的数排在它前面，比它大的数排在它后面，第一轮结束后，第二轮重复，直到排序完成</li>
<li>计数排序<br>首先定义三个数组，数组a是最初待排序的数组，数组b是用来临时存放信息的数组，数组c是最终排序完成的数组。统计数组a中每个值为n的数出现的次数，并将其全部放入数组b的第n项中，再从b中按顺序将所有数排入数组c中，则排序完成</li>
</ol>
<h1 id="第-9-题"><a href="#第-9-题" class="headerlink" title="第 9 题"></a>第 9 题</h1><h2 id="一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？"><a href="#一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？" class="headerlink" title="一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？"></a>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</h2><h2 id="答：-8"><a href="#答：-8" class="headerlink" title="答："></a>答：</h2><ol>
<li>当发送一个url请求时，首先通过DNS解析获得网址的对应IP地址</li>
<li>在浏览器与远程web服务器之间通过TCP三次握手协商来建立一个TCP/IP连接：</li>
</ol>
<ul>
<li>第一次握手 主机向服务器发送一个建立连接的请求（你好我需要xxx）</li>
<li>第二次握手 服务器接到请求后发送同意连接的信号（好的，我同意）</li>
<li>第三次握手 主机接到同意连接的信号后，再次向服务器发送了确认信号（已确认收到），自此，主机与服务器两者建立了连接</li>
</ul>
<ol start="3">
<li>主机发送HTTP请求，请求报文包括：请求行，请求报头，请求正文</li>
<li>服务器处理请求并回复HTTP响应报文：状态码，响应报头，响应报文</li>
<li>浏览器解析渲染页面，首先解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，再进行布局渲染树，完成后，将其绘制在屏幕上。</li>
<li>断开连接，主机与服务器之间进行四次挥手</li>
</ol>
<ul>
<li>主机向服务器发送一个断开连接的请求（不早了，我该走了）</li>
<li>服务器接到请求后发送确认收到请求的信号（知道了）</li>
<li>服务器向主机发送断开通知（我也该走了）</li>
<li>主机接到断开通知后断开连接并反馈一个确认信号（嗯，好的），服务器收到确认信号后断开连接</li>
</ul>
<h1 id="第-10-题"><a href="#第-10-题" class="headerlink" title="第 10 题"></a>第 10 题</h1><h2 id="如何实现数组去重？"><a href="#如何实现数组去重？" class="headerlink" title="如何实现数组去重？"></a>如何实现数组去重？</h2><p>假设有数组 array = [1,5,2,3,4,2,3,1,3,4]<br>你要写一个函数 unique，使得<br>unique(array) 的值为 [1,5,2,3,4]<br>也就是把重复的值都去掉，只保留不重复的值。</p>
<p>要求：<br>不要做多重循环，只能遍历一次<br>请给出两种方案，一种能在 ES 5 环境中运行，一种能在 ES 6 环境中运行（提示 ES 6 环境多了一个 Set 对象）</p>
<h2 id="答：-9"><a href="#答：-9" class="headerlink" title="答："></a>答：</h2><p><strong>ES5</strong></p>
<pre><code class="js">array = [1,5,2,3,4,2,3,1,3,4]
function unique(array) {
    var temp = []
    var hash = {}
    for(var i = 0; i &lt; array.length; i++) {
        if(hash[array[i]] === undefined) {
            temp.push(array[i])
            hash[array[i]] = 1
        }
    }
    return temp
}
</code></pre>
<p><strong>ES6</strong></p>
<pre><code class="js">function unique(array) {
    return [...new Set(array)]
}
</code></pre>
]]></content>
      <categories>
        <category>面试汇总</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue</title>
    <url>/2019/06/28/Vue/</url>
    <content><![CDATA[<h1 id="VueJS是什么？"><a href="#VueJS是什么？" class="headerlink" title="VueJS是什么？"></a>VueJS是什么？</h1><p>简单小巧，渐进式，功能强大的技术栈<br><a id="more"></a></p>
<h1 id="VueJS的模式"><a href="#VueJS的模式" class="headerlink" title="VueJS的模式"></a>VueJS的模式</h1><p>MVVM模式，视图层和数据层的双向绑定<br>M：Model<br>V：View</p>
<h2 id="VM：ViewModel"><a href="#VM：ViewModel" class="headerlink" title="VM：ViewModel"></a>VM：ViewModel</h2><h1 id="数据绑定，指令，事件"><a href="#数据绑定，指令，事件" class="headerlink" title="数据绑定，指令，事件"></a>数据绑定，指令，事件</h1><h2 id="Vue实例和数据绑定"><a href="#Vue实例和数据绑定" class="headerlink" title="Vue实例和数据绑定"></a>Vue实例和数据绑定</h2><pre><code class="html">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;&gt;&lt;/script&gt;
</code></pre>
<ol>
<li><p>通过构造函数 Vue 就可以创建一个 Vue 的跟实例，并启动 Vue 应用入口</p>
<pre><code class="js">var app = new Vue({
 el:&#39;&#39;,
 data:{

 }
})
</code></pre>
</li>
<li>必不可少的一个选项就是 el，el 用于指定一个页面中己存在的 DOM 元素来挂载 Vue 实例，可以是标签。也可以是css语法</li>
<li>通过 Vue 实例的 data 选项，可以声明应用内需要双向绑定的数据。建议所有会用到的数据都预先在 data 内 声明，这样不至于将数据散落在业务逻辑中，难以维护。也可以指向一个已经有的变量</li>
<li>挂载成功后，我们可以通过<code>app.$el</code>来访问该元素。<br>访问 Vue 实例的属性：都是以<code>$</code>开头 如 app.$el<br>访问 data 元素的属性：直接<code>app.属性名</code> 如 app.msg</li>
</ol>
<hr>
<h2 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h2><pre><code class="js">jquery---$(document).ready()
</code></pre>
<ul>
<li>created 实例创建完成后调用，此阶段完成了数据的观测等，但尚未挂载， $el 还不可用。需要初始化处理一些数据时会比较有用 —-还未挂载</li>
<li>mounted el 挂载到实例上后调用，一般我们的第一个业务逻辑会在这里开始 。相当于 <code>$(document).ready()</code> —刚刚挂载</li>
<li>beforeDestroy 实例销毁之前调用。主要解绑一些使用 addEventListener 监听的事件等</li>
</ul>
<hr>
<h2 id="文本插值和表达式"><a href="#文本插值和表达式" class="headerlink" title="文本插值和表达式"></a>文本插值和表达式</h2><p>语法：使用双大括号（ Mustache 语法）”{ {} }”是最基本的文本插值方法，它会自动将我们双向绑定的数据实时显示出来<br>在”{ {} }”中，除了简单的绑定属性值外，还可 以使用 JavaScript 表达式进行简单的运算 、 三元运算等<br>—实例<br>Vue .js 只支持单个表达式，不支持语句和流控制。</p>
<pre><code class="js">{{ 6+6 *3}}---可以进行简单的运算 &lt;br&gt;
{{ 6<3 ? msg :a}}---可以用三元运算符 &lt;br&gt; {{if(6>3)}}-----注意：文本插值的形式，其中不能书写表达式,支持单个表达式
{{var a = 6}}--也是多行表达式----var a ;a = 6;
〈！一这是语旬，不是表达式 一〉
{ { var book = ’ Vue . js 实战 ’ ｝｝
〈！一不能使用流控制，要使用三元运算 一〉
{{ if (ok) return msg ))
```
---
## 过滤器
Vue. 支持在"{ {} }"插值的尾部添加一小管道符 “ | ” 对数据进行过滤，经常用于格式化文本，比如字母全部大写、货币千位使用逗号分隔等。过滤的规则是自定义的， 通过给 Vue 实例添加选项 filters 来设置过滤器：
`{ { data | filter1 |filter2} }`
`{ {date | formatDate(66,99)} }` 中的第一个和第二个参数，分别对应过滤器的第二个和第三个参数
---
## 指令和事件
指令（ Directives ）是 Vue 模板中最常用的一项功能，它带有前缀 v－，能帮我们快速完成DOM操作。循环渲染。显示和隐藏
v­-text:—————­解析文本 和"{ {} }"作用一样
v­-html:————— 解析html
v­-bind—————–v­bind 的基本用途是动态更新 HTML 元素上的属性，比如 id 、class 等
v­-on——————它用来绑定事件监听器

在普通元素上， v­on 可以监听原生的 DOM 事件，除了 click 外，还有dblclick、 keyup, mousemove 等。表达式可以是一个方法名，这些方法都写在 Vue 实例的 methods 属性内，并且是函数的形式，函数内的 this 指向的是当前 Vue 实例本身，因此可以直接使用 this.xxx 的形式来访问或修改数据

vue中用 到的所有方法都定义在methods中
## 语法糖
语法糖是指在不影响功能的情况下 ， 添加某种简洁方法实现同样的效果 ， 从而更加方便程序开发。
v-bind ——> : (冒号)
v-on ——> @
# 计算属性
所有的计算属性都以函数的形式写在 Vue 实例内的 computed 选项内，最终返回计算后的结果。

在一个计算属性里可以完成各种复杂的逻辑，包括运算、函数调用等，只要最终返回一个结果就可以。计算属性还可以依赖多个 Vue 实例的数据，只要其中任一数据变化，计算属性就会重新执行，视图也会更新

- getter
- setter

每一个计算属性都包含一个 getter 和一个 setter ，默认使用 getter ， 当手动修改计算属性的值就像修改一个普通数据那样时，就会出发 setter 函数， 执行一些自定义的操作

计算属性还有两个很实用的小技巧容易被忽略：一是计算属性可以依赖其他计算属性：二是计算属性不仅可以依赖当前 Vue 实例的数据，还可以依赖其他实例的数据

调用 methods 里的方法也可以与计算属性起到同样的作用
页面中的方法： 如果是调用方法，只要页面重新渲染。方法就会重新执行，不需要渲染，则不需要重新执行计算属性：不管渲染不渲染，只要计算属性依赖的数据未发生变化，就永远不变

结论: 没有使用计算属性，在 methods 里定义了一个方法实现了相同的效果，甚至该方法还可以接受参数，使用起来更灵活。既然使用 methods 就可以实现，那么为什么还需要计算属性呢？原因就是计算属性是基于它的依赖缓存的。一个计算属性所依赖的数据发生变化时，它才会重新取值，所以text 只要不改变，计算属性也就不更新

何时使用: -----------使用计算属性还是 methods 取决于你是否需要缓存，当遍历大数组和做大量计算时，应当使用计算属性，除非你不希望得到缓存。
# v-bind以及class与style的绑定
应用场景: DOM 元素经常会动态地绑定一些 class 类名或 style 样式
## 了解bind指令
链接的 href 属性和图片的 src 属性都被动态设置了，当数据变化时，就会重新渲染。
在数据绑定中，最常见的两个需求就是元素的样式名称 class 和内联样式 style 的动态绑定，它们也是HTML的属性，因此可以使用 v­-bind 指令。我们只需要用 v­-bind 计算出表达式最终的字符串就可以，不过有时候表达式的逻辑较复杂，使用字符串拼接方法较难阅读和维护，所以 Vue.js 增强了对 class 和 style 的绑定。
## 绑定 class 的几种方式
### 对象语法
给 v­-bind:class 设置一个对象，可以动态地切换 class， 值对应true ,false
当 class 的表达式过长或逻辑复杂时，还可以绑定一个计算属性，这是一种很友好和常见的用法，一般当条件多于两个时， 都可以使用 data 或 computed
### 数组语法
当需要应用多个 class 时， 可以使用数组语法 ，给 :class 绑定一个数组，应用一个 class 列表:数组成员直接对应className--类名 可以用三目运算实现,对象和数组混用
## 绑定内联样式
使用 v­-bind:style (即:style ) 可以给元素绑定内联样式，方法与 :class 类似，也有对象语法和数组语法，看起来很像直接在元素上写 CSS:
注意 : css 属性名称使用驼峰命名( fontSize )或短横分隔命名( font-size )，
- 应用多个样式对象时 ，可以使用数组语法 :在实际业务 中,style 的数组语法并不常用 ，因为往往可以写在一个对象里面 : 而较为常用 的应当是计算属性
- 使用 :style 时， Vue.js 会自动给特殊的 css 属性名称增加前缀， 比如 transform 。 
- 无需再加前缀属性!!!!
# VueJs 中的内置指令
## 基本指令
v­-cloak一般与display:none进行结合使用
作用:解决初始化慢导致页面闪动的最佳实践
v-once 定义它的元素和组件只渲染一次
## 条件渲染指令
v-if v-else v-else-if
Vue 在渲染元素时 ，出于效率考虑，会尽可能地复用已有的元素而非重新渲染，只会渲染变化的元素，也就是说，input元素被复用了
解决方法:加key，唯一，提供key值可以来决定是否复用该元素
v-show
只改变了css属性display
**v-if 和 v-show 的区别**
v­-if:
实时渲染:页面显示就渲染，不显示。我就给你移除
v­-show:
v­-show的元素永远存在也页面中，只是改变了css的display的属性
## 列表渲染指令v­-for
用法: 当需要将一个数组遍历或枚举一个对象属性的时候循环显示时，就会用到列表 渲染指令 v­-for
两种使用场景:
- 遍历多个对象
- 遍历一个对象的多个属性
## 数组更新，过滤与排序
改变数组的一系列方法:
- push() 在末尾添加元素
- pop() 将数组的最后一个元素移除
- shift() 删除数组的第一个元素
- unshift():在数组的第一个元素位置添加一个元素 
- splice() :可以添加或者删除函数—返回删除的元素 
**三个参数:**
1. 第一个参数 表示开始操作的位置
2. 第二个参数表示:要操作的长度
3. 第三个为可选参数:
- sort():排序
- reverse()
**两个数组变动vue检测不到:**
1. 改变数组的指定项 
2. 改变数组长度
**过滤:filter**
1. 改变指定项: Vue.set(app.arr,1,”car”);
2. app.arr.splice(1): 改变数组长度
**解决方法:**
1. set
2. splice
## 方法和事件
[object MouseEvent]
## 基本用法
v­-on绑定的事件类似于原生 的onclick等写法
```js
methods: {
    handle: function (count) {
        count = count || 1;
        this.count += count;
    }
}
```
如果方法中带有参数，但是尼没有加括号，默认传原生事件对象event
## 修饰符
在vue中传入event对象用 $event
向上冒泡
stop:阻止单击事件向上冒泡 
prevent::提交事件并且不重载页面 
self:只是作用在元素本身而非子元素的时候调用 
once: 只执行一次的方法

可以监听键盘事件:
<input @keyup.13="submitMe"> ——­指定的keyCode 
vueJS为我们提供了:
.enter
.tab
.delete
# 表单 v-model
## v-model
用于在表单类元素上双向绑定事件
**input和textarea**
可以用于input框，以及textarea等
注意: 所显示的值只依赖于所绑定的数据，不再关心初始化时的插入的value
**单选按钮:**
1. 单个单选按钮，直接用v­-bind绑定一个布尔值，用v­-model是不可以的
2. 如果是组合使用，就需要v­-model来配合value使用，绑定选中的单选框的value值，此处所绑定的初始值可以随意给

**复选框:**
1. 单个复选框，直接用定一个布尔值，可以用v­-model可以用v­-bind
2. 多个复选框, 如果是组合使用，就需要v­-model来配合value使用v­-model绑定一个数组—如果绑定的是字符串，则会转化为true。false，与所有绑定的复选框的 checked属性相对应

**下拉框:**
1. 如果是单选，所绑定的value值初始化可以为数组，也可以为字符串，有value直接优 先匹配一个value值，没有value就匹配一个text值
2. 如果是多选，就需要v­-model来配合value使用，v­-model绑定一个数组，与复选框类 似
3. v­-model一定是绑定在select标签上

**总结一下:**
如果是单选，初始化最好给定字符串，因为v­model此时绑定的是静态字符串或者布尔值
如果是多选，初始化最好给定一个数组
## 绑定值
- 单选按钮 
- 只需要用v­-bind给单个单选框绑定一个value值，此时，v­-model绑定的就是他的value值
- 复选框
- 下拉框
- 在select标签上绑定value值对option并没有影响
## 修饰符
- lazy —— v­-model默认是在input输入时实时同步输入框的数据，而lazy修饰符，可以使其在失去焦点或者敲回车键之后在更新
- number —— 将输入的字符串转化为number类型
- trim —— trim自动过滤输入过程中收尾输入的空格
# 组件
## 使用组件的原因
作用:提高代码的复用性
## 组件的使用方法
1. 全局注册
```js
Vue.component('my-component',{
    template:'<div>我是组件的内容</div>'
})  
优点:所有的nue实例都可以用 
缺点:权限太大，容错率降低
```
2. 局部注册
```js
var app = new Vue({
    el:'#app',
    components:{
        'my-component':{
            template:'<div>我是组件内容</div>'
        }
    }
})
```
3. vue组件的模板在某些情况下会受到html标签的限制，比如 \<table> 中只能还有 \<tr> , \<td> 这些元素，所以直接在table中使用组件是无效的，此时可以使用is属性来挂载组件
```html
<table>
    <tbody is="my-component"></tbody>
</table>
```
## 组件使用技巧
1. 推荐使用小写字母加­进行命名(必须) child, my­componnet命名组件
2. template中的内容必须被一个DOM元素包括 ，也可以嵌套
3. 在组件的定义中，除了template之外的其他选项—data,computed,methods 
4. data必须是一个方法
## 使用props传递数据 父亲向儿子传递数据
1. 在组件中使用props来从父亲组件接收参数，注意，在props中定义的属性，都可以在组件中直接使用
2. propps来自父级，而组件中data return的数据就是组件自己的数据，两种情况作用域就是组件本身，可以在template，computed，methods中直接使用
3. props的值有两种，一种是字符串数组，一种是对象
4. 可以使用v­-bind动态绑定父组件来的内容
## 单向数据流
- 解释 : 通过 props 传递数据是单向的， 也就是父组件数据变化时会传递给子组件，但是反过来不行。
- 目的 :是尽可能将父子组件解稿，避免子组件无意中修改了父组件的状态。 
- 应用场景: 业务中会经常遇到两种需要改变 prop 的情况

一种是父组件传递初始值进来，子组件将它作为初始值保存起来，在自己的作用域下可以随意使用和修改。这种情况可以在组件 data 内再声明一个数据，引用父组件的 prop
步骤一:注册组件
步骤二:将父组件的数据传递进来，并在子组件中用props接收 
步骤三:将传递进来的数据通过初始值保存起来
```html
<div id="app">
    <my-comp init-count="666"></my-comp>
</div>
<script>
    var app = new Vue({
        el: '#app',
        components: {
            'my-comp': {
                props: ['init-count'],
                template: '<div>{{init-count}}&lt;/div&gt;&#39;,
                data: function () {
                    return {
                        count: this.initCount
                    }
                }
            }
        }
    })
&lt;/script&gt;
</code></pre>
<p>另一种情况就是 prop 作为需要被转变的原始值传入。这种情况用计算属性就可以了<br>步骤一:注册组件<br>步骤二:将父组件的数据传递进来，并在子组件中用props接收<br>步骤三:将传递进来的数据通过计算属性进行重新计算</p>
<pre><code class="html">&lt;input type=&quot;text&quot; v-model=&quot;width&quot;&gt;
&lt;my-comp :width=&quot;width&quot;&gt;&lt;/my-comp&gt;
--------------------------------------------
&lt;script&gt;
    var app = new Vue({
        el: &#39;#app&#39;,
        data: {
            width: &#39;&#39;
        },
        components: {
            &#39;my-comp&#39;: {
                props: [&#39;init-count&#39;, &#39;width&#39;],
                template: &#39;&lt;div :style=&quot;style&quot;&gt;{{init-count}}&lt;/div&gt;&#39;,
                computed: {
                    style: function () {
                        return {
                            width: this.width + &#39;px&#39;,
                            background: &#39;red&#39;
                        }
                    }
                }
            }
        }
    })
&lt;/script&gt;
</code></pre>
<h2 id="数据验证"><a href="#数据验证" class="headerlink" title="数据验证"></a>数据验证</h2><ul>
<li>vue组件中camelCased (驼峰式) 命名与 kebab­case(短横线命名)</li>
<li>在html中, myMessage 和 mymessage 是一致的,因此在组件中的html中使用必须使用短横线命名方式。在html中不允许使用驼峰!!!!!!</li>
<li>在组件中, 父组件给子组件传递数据必须用短横线。在template中，必须使用驼峰命名方式，若为短横线的命名方式。则会直接保错。</li>
<li>在组件的data中,用this.XXX引用时,只能是驼峰命名方式。若为短横线的命名方式，则会报错。<br><strong>验证的 type 类型可以是:</strong></li>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Object</li>
<li>Array</li>
<li>Function<pre><code class="js">Vue.component(&#39;my-component&#39;, {
  props: {
      propA: Number,
      propB: [String, Number],
      propC: {
          type: Boolean,
          default: true
      },
      propD: {
          type: Number,
          required: true
      },
      propE: {
          type: Array,
          default: function () {
              return []
          }
      },
      propF: {
          validator: function (value) {
              return value &gt; 10
          }
      }
  }
})
</code></pre>
<h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2>组件关系可分为父子组件通信、兄弟组件通信、跨级组件通信<h2 id="自定义事件—子组件给父组件传递数据"><a href="#自定义事件—子组件给父组件传递数据" class="headerlink" title="自定义事件—子组件给父组件传递数据"></a>自定义事件—子组件给父组件传递数据</h2>使用v­-on 除了监昕 DOM 事件外，还可以用于组件之间的自定义事件。<br>JavaScript 的设计模式 一一观察者模式， dispatchEvent 和 addEventListener这两个方<br>法。 Vue 组件也有与之类似的一套模式，子组件用$emit()来触发事件 ，父组件用$on()来监昕子组件的事件<br>第一步:自定义事件<br>第二步: 在子组件中用$emit触发事件，第一个参数是事件名，后边的参数是要传递的数据<br>第三步:在自定义事件中用一个参数来接受<pre><code class="html">&lt;div id=&quot;app&quot;&gt;
  &lt;p&gt;您好,您现在的银行余额是{{total}}元&lt;/p&gt;
  &lt;btn-compnent @change=&quot;handleTotal&quot;&gt;&lt;/btn-compnent&gt;
&lt;/div&gt;
&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
var app = new Vue({
  el: &#39;#app&#39;,
  data: {
      total: 0
  },
  components: {
      &#39;btn-compnent&#39;: {
          template: &#39;&lt;div&gt;\
          &lt;button @click=&quot;handleincrease&quot;&gt;+1&lt;/button&gt; \
          &lt;button @click=&quot;handlereduce&quot;&gt;-1&lt;/button&gt;\
      &lt;/div&gt;&#39;,
          data: function () {
              return {
                  count: 0
              }
          },
          methods: {
              handleincrease: function () {
                  this.count++;
                  this.$emit(&#39;change&#39;, this.count);
              },
              handlereduce: function () {
                  this.count--;
                  this.$emit(&#39;change&#39;, this.count);
              }
          }
      }
  },
  methods: {
      handleTotal: function (total) {
          this.total = total;
      }
  }
})
&lt;/script&gt;
</code></pre>
<h2 id="组件中使用v-model"><a href="#组件中使用v-model" class="headerlink" title="组件中使用v-model"></a>组件中使用v-model</h2>$emit的代码,这行代码实际上会触发一个input事件, ‘input’后的参数就是传递给v­-model绑定的属性的值<br>v­-model 其实是一个语法糖，这背后其实做了两个操作</li>
<li>v­-bind 绑定一个 value 属性</li>
<li>v­-on 指令给当前元素绑定 input 事件<br>要使用v­model,要做到:</li>
<li>接收一个 value 属性</li>
<li>在有新的 value 时触发 input 事件<pre><code class="html">&lt;div id=&quot;app&quot;&gt;
  &lt;p&gt;您好,您现在的银行余额是{{total}}元&lt;/p&gt;
  &lt;btn-compnent v-model=&quot;total&quot;&gt;&lt;/btn-compnent&gt;
&lt;/div&gt;
&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  //关于
var app = new Vue({
  el: &#39;#app&#39;,
  data: {
      total: 0
  },
  components: {
      &#39;btn-compnent&#39;: {
          template: &#39;&lt;div&gt;\
          &lt;button @click=&quot;handleincrease&quot;&gt;+1&lt;/button&gt; \
          &lt;button @click=&quot;handlereduce&quot;&gt;-1&lt;/button&gt;\
      &lt;/div&gt;&#39;,
          data: function () {
              return {
                  count: 0
              }
          },
          methods: {
              handleincrease: function () {
                  this.count++;
              -- -- --注意观察.这一行, emit的是input事件 -- -- --
                      this.$emit(&#39;input&#39;, this.count);
              },
              handlereduce: function () {
                  this.count--;
                  this.$emit(&#39;input&#39;, this.count);
              }
          }
      }
  },
  methods: {
      /* handleTotal:function (total) {
          this.total = total;
      }*/
  }
})
&lt;/script&gt;
</code></pre>
<h2 id="非父组件之间的通信"><a href="#非父组件之间的通信" class="headerlink" title="非父组件之间的通信"></a>非父组件之间的通信</h2><pre><code class="html">&lt;div id=&quot;app&quot;&gt;
  &lt;my-acomponent&gt;&lt;/my-acomponent&gt;
  &lt;my-bcomponent&gt;&lt;/my-bcomponent&gt;
&lt;/div&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;&gt;
&lt;/script&gt;
&lt;script&gt;
Vue.component(&#39;my-acomponent&#39;, {
  template: &#39;&lt;div&gt;&lt;button @click=&quot;handle&quot;&gt;点击我向B组件传递数据&lt;/b
  utton &gt; &lt; /div&gt;&#39;,
  data: function () {
      return {
          aaa: &#39;我是来自A组件的内容&#39;
      }
  },
  methods: {
      handle: function () {
          this.$root.bus.$emit(&#39;lala&#39;, this.aaa);
      }
  }
})
Vue.component(&#39;my-bcomponent&#39;, {
  template: &#39;&lt;div&gt;&lt;/div&gt;&#39;,
  created: function () {
      //A组件在实例创建的时候就监听事件---lala事件 this.$root.bus.$on(&#39;lala&#39;,function (value) {
      alert(value)
  });
}
})
&lt;/script&gt;
</code></pre>
父链:this.$parent<pre><code class="js">Vue.component(&#39;child-component&#39;, {
  template: &#39;&lt;button @click=&quot;setFatherData&quot;&gt;通过点击我修改父亲的数据&lt;/button&gt;&#39;,methods:{
  setFatherData: function () {
      this.$parent.msg = &#39;数据已经修改了&#39;
  }
}
})
</code></pre>
子链:this.$refs<br>提供了为子组件提供索引的方法，用特殊的属性ref为其增加一个索引<pre><code class="js">var app = new Vue({
  el: &#39;#app&#39;,
  data: {
      //bus中介
      bus: new Vue(),
      msg: &#39;数据还未修改&#39;,
      formchild: &#39;还未拿到&#39;
  },
  methods: {
      getChildData: function () { //用来拿子组件中的内容 ----
          $refs
          this.formchild = this.$refs.c.msg;
      }
  }
})
</code></pre>
<h2 id="使用slot插槽"><a href="#使用slot插槽" class="headerlink" title="使用slot插槽"></a>使用slot插槽</h2>为了让组件可以组合，我们需要一种方式来混合父组件的内容与子组件自己的模板。这个过程被称为 内容分发.Vue.js 实现了一个内容分发API，使用特殊的 ‘slot’ 元素作为原始内容的插槽。<br>在深入内容分发 API 之前，我们先明确内容在哪个作用域里编译。假定模板为:<br>\<child-component>\</child-component><br>message 应该绑定到父组件的数据，还是绑定到子组件的数据?答案是父组件。组件作用域简单地说是:<br>父组件模板的内容在父组件作用域内编译;<br>子组件模板的内容在子组件作用域内编译。</li>
</ul>
<p>父组件的内容与子组件相混合，从而弥补了视图的不足<br>混合父组件的内容与子组件自己的模板<br>单个插槽:</p>
<pre><code class="js">&lt;div id=&quot;app&quot;&gt;
    &lt;my-component&gt;
        &lt;p&gt;我是父组件的内容&lt;/p&gt;
    &lt;/my-component&gt;
&lt;/div&gt;
Vue.component(&#39;my-component&#39;,{
    template:&#39;&lt;div&gt;\
        &lt;slot&gt;\
            如果父组件没有插入内容，我就作为默认出现\
        &lt;/slot&gt;\
    &lt;/div&gt;&#39;
})
</code></pre>
<p>具名插槽:</p>
<pre><code class="js">&lt;name-component&gt;
    &lt;h3 slot=&quot;header&quot;&gt;我是标题&lt;/h3&gt;
    &lt;p&gt;我是正文内容&lt;/p&gt;
    &lt;p&gt;正文内容有两段&lt;/p&gt;
    &lt;p slot=&quot;footer&quot;&gt;我是底部信息&lt;/p&gt;
&lt;/name-component&gt;
Vue.component(&#39;myname-component&#39;, {
    template: &#39;&lt;div&gt;\
    &lt;div class=&quot;header&quot;&gt;\
        &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;\
    &lt;/div&gt;\
    &lt;div class=&quot;content&quot;&gt;\
        &lt;slot&gt;&lt;/slot&gt;\
    &lt;/div&gt;\
    &lt;div class=&quot;footer&quot;&gt;\
        &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;\
    &lt;/div&gt;\
&lt;/div&gt;&#39;
})
</code></pre>
<p>作用域插槽是一种特殊的slot，使用一个可以复用的模板来替换已经渲染的元素<br>——从子组件获取数据<br>====template模板是不会被渲染的</p>
<pre><code class="js">Vue.component(&#39;my-component&#39;,{
    template:&#39;&lt;div&gt;\
        &lt;slot text=&quot;123&quot; tt=&quot;ssss&quot; name=&quot;abc&quot;&gt;\
        &lt;/slot&gt;\
    &lt;/div&gt;&#39;
})
</code></pre>
<p>访问slot<br>通过this.$slots.(NAME)</p>
<pre><code class="js"> mounted:function () { //访问插槽
    var header = this.$slots.header;
    var text = header[0].elm.innerText;
    var html = header[0].elm.innerHTML;
    console.log(header)
    console.log(text)
    console.log(html) }
</code></pre>
<p>组件高级用法–动态组件<br>VUE给我们提供了一个元素叫component<br>作用是: 用来动态的挂载不同的组件<br>实现:使用is特性来进行实现的</p>
</script></td></tr></table></3></code></pre>]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题汇总</title>
    <url>/2020/05/08/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p><strong> 面试题全汇总（不做分类）</strong><br><a id="more"></a></p>
<h1 id="MVC-MVVC-MVVM-模式的理解"><a href="#MVC-MVVC-MVVM-模式的理解" class="headerlink" title="MVC,MVVC,MVVM 模式的理解"></a>MVC,MVVC,MVVM 模式的理解</h1><h2 id="MVC-Model-View-Controller"><a href="#MVC-Model-View-Controller" class="headerlink" title="MVC(Model-View-Controller)"></a>MVC(Model-View-Controller)</h2><p>Model(模型): 数据层，负责存储数据。<br>View(视图): 展现层，用户所看到的页面<br>Controller(控制器): 协调层，负责协调 Model 和 View，根据用户在 View 上的动作在 Model 上作出对应的更改，同时将更改的信息返回到 View 上。<br>三者之间的关系<br>Controller 可以直接访问 Model，也可以直接控制 View, 但是 Model 和 View 不能相互通信，相当于 COntroller 就是介于这两者之间的协调者。</p>
<h2 id="MVVM-Model-View-ViewModel"><a href="#MVVM-Model-View-ViewModel" class="headerlink" title="MVVM(Model-View-ViewModel)"></a>MVVM(Model-View-ViewModel)</h2><p>Model(模型): 数据层，负责存储数据。<br>View(控制器): 就是 ViewController 层，他的任务就是从 ViewModel 层获取数据，然后显示。<br>ViewModel(视图模型): 就是 View 和 Model 层的粘合剂，封装业务逻辑处理，封装网络处理，封装数据缓存。就是把原来 ViewController 层的业务逻辑和页面逻辑等剥离出来放到 ViewModel 层。</p>
<h2 id="MVVC-Model-View-View-Controller"><a href="#MVVC-Model-View-View-Controller" class="headerlink" title="MVVC(Model-View-View-Controller)"></a>MVVC(Model-View-View-Controller)</h2><p>Model(模型): 数据层，负责存储数据。<br>View(视图): 展现层，创建需求创建 cell<br>View(视图): 定义数组，用来接收控制中的数据。处理回调（比如: 刷新回调、点击 cell 回调、加载更多回调、动态视图高度回调等等）<br>Controller(控制器): 加载网络数据，懒加载</p>
<h1 id="Vue-指令"><a href="#Vue-指令" class="headerlink" title="Vue 指令"></a>Vue 指令</h1><p>v-html、v-show、v-if、v-for 等等</p>
<h2 id="v-if-和-v-show-的区别"><a href="#v-if-和-v-show-的区别" class="headerlink" title="v-if 和 v-show 的区别"></a>v-if 和 v-show 的区别</h2><p>v-show 仅仅控制元素的显示方式，将 display 属性在 block 和 none 来回切换；而 v-if 会控制这个 DOM 节点的存在与否。当我们需要经常切换某个元素的显示 / 隐藏时，使用 v-show 会更加节省性能上的开销；当只需要一次显示或隐藏时，使用 v-if 更加合理。</p>
<h1 id="简述-Vue-的响应式原理"><a href="#简述-Vue-的响应式原理" class="headerlink" title="简述 Vue 的响应式原理"></a>简述 Vue 的响应式原理</h1><p>当一个 Vue 实例创建时，vue 会遍历 data 选项的属性，用 Object.defineProperty 将它们转为 getter/setter 并且在内部追踪相关依赖，在属性被访问和修改时通知变化。</p>
<p>每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。</p>
<h1 id="简述-Vue-的生命周期"><a href="#简述-Vue-的生命周期" class="headerlink" title="简述 Vue 的生命周期"></a>简述 Vue 的生命周期</h1><p>它可以总共分为 8 个阶段：</p>
<p>beforeCreate（创建前）,</p>
<p>created（创建后）,</p>
<p>beforeMount(载入前),</p>
<p>mounted（载入后）,</p>
<p>beforeUpdate（更新前）,</p>
<p>updated（更新后）,</p>
<p>beforeDestroy（销毁前）,</p>
<p>destroyed（销毁后）。</p>
<h1 id="vue-中-Computed-和-Watch-的使用和区别"><a href="#vue-中-Computed-和-Watch-的使用和区别" class="headerlink" title="vue 中 Computed 和 Watch 的使用和区别"></a>vue 中 Computed 和 Watch 的使用和区别</h1><h2 id="计算属性-computed-适用的情形"><a href="#计算属性-computed-适用的情形" class="headerlink" title="计算属性 computed 适用的情形"></a>计算属性 computed 适用的情形</h2><p>我们可能会有这样的需求，一个数据属性在它所依赖的属性发生变化时，也要发生变化，这种情况下，我们最好使用计算属性。</p>
<h2 id="监听器-watch-适当的情形"><a href="#监听器-watch-适当的情形" class="headerlink" title="监听器 watch 适当的情形"></a>监听器 watch 适当的情形</h2><p>watch 函数适用于，当数据发生变化时，执行异步操作或较大开销操作的情况。</p>
<h1 id="vue-与-react-优缺点对比"><a href="#vue-与-react-优缺点对比" class="headerlink" title="vue 与 react 优缺点对比"></a>vue 与 react 优缺点对比</h1><p><em>vue</em><br>API 设计上简单，语法简单，学习成本低<br>构建方面不包含路由和 ajax 功能，使用 vuex, vue-router<br>指令（dom）和组件（视图，数据，逻辑）处理清晰<br>性能好，容易优化<br>基于依赖追踪的观察系统，并且异步队列更新<br>独立触发<br>v-model 实时渲染<br>适用于：模板和渲染函数的弹性选择<br>简单的语法及项目搭建<br>更快的渲染速度和更小的体积</p>
<p><em>react</em><br>利用 jsx 创建虚拟 dom<br>是一种在内存中描述 dom 树状态的数据结构<br>函数式的方法描述视图<br>使用虚拟 dom 作为模板<br>程序片段<br>不好控制 dom<br>生命周期<br>服务端渲染：react 的虚拟 dom 的生成可以在任何支持 JavaScript 的环境生成的，所以可以在 node 环境生成，直接转为 string, 然后插入到 html 文件中输出浏览器便可<br>适用于：大型应用和更好的可测试性；同时适用于 web 端和原生 app; 更大的生态圈</p>
<ul>
<li><p>优点<br>React 伟大之处就在于，提出了 Virtual Dom 这种新颖的思路，并且这种思路衍生出了 React Native，有可能会统一 Web/Native 开发。在性能方面，由于运用了 Virtual Dom 技术，Reactjs 只在调用 setState 的时候会更新 dom，而且还是先更新 Virtual Dom，然后和实际 Dom 比较，最后再更新实际 Dom。这个过程比起 Angularjs 的 bind 方式来说，一是更新 dom 的次数少，二是更新 dom 的内容少，速度肯定快<br>ReactJS 更关注 UI 的组件化，和数据的单向更新，提出了 FLUX 架构的新概念，现在 React 可以直接用 JavaScript ES6 语法了，然后通过 webpack 编译成浏览器兼容的 ES5，开发效率上有些优势.<br>React Native 生成的 App 不是运行在 WebView 上，而是系统原生的 UI，React 通过 jsx 生成系统原生的 UI，iOS 和 Android 的 React UI 组件还是比较相似的，大量代码可以复用<br>维护 UI 的状态,Angular 里面使用的是 $scope，在 React 里面使用的是 this.setState。 而 React 的好处在于，它更简单直观。所有的状态改变都只有唯一一个入口 this.setState()，<br>同构的 JavaScript<br>单页面 JavaScript 应用程序的最大缺陷在于对搜索引擎的索引有很大限制。React 对此有了解决方案。<br>React 可以在服务器上预渲染应用再发送到客户端。它可以从预渲染的静态内容中恢复一样的记录到动态应用程序中。<br>因为搜索引擎的爬虫程序依赖的是服务端响应而不是 JavaScript 的执行，预渲染你的应用有助于搜索引擎优化。</p>
</li>
<li><p>缺点<br>React 是目标是 UI 组件，通常可以和其它框架组合使用，目前并不适合单独做一个完整的框架。React 即使配上 redux 的组合，也不能称之一个完整的框架，比如你想用 Promise 化的 AJAX？对不起没有，自己找现成的库去。而且第三方组件远远不如 Angular 多。目前在大的稳定的项目上采用 React 的，我也就只知道有 Yahoo 的 Email。React 本身只是一个 V 而已，所以如果是大型项目想要一套完整的框架的话，也许还需要引入 Redux 和 route 相关的东西。</p>
</li>
</ul>
<p><em>vue react 共性：</em><br>虚拟 dom 实现快速渲染<br>轻量级响应式组件<br>服务端渲染易于集成路由工具，打包工具及状态管理工具</p>
<h1 id="什么是-vuex？"><a href="#什么是-vuex？" class="headerlink" title="什么是 vuex？"></a>什么是 vuex？</h1><p>在 SPA 单页面组件的开发中 Vue 的 vuex 和 React 的 Redux 都统称为同一状态管理，个人的理解是全局状态管理更合适；简单的理解就是你在 state 中定义了一个数据之后，你可以在所在项目中的任何一个组件里进行获取、进行修改，并且你的修改可以得到全局的响应变更。</p>
<h2 id="核心概念-1-State"><a href="#核心概念-1-State" class="headerlink" title="核心概念 1: State"></a>核心概念 1: State</h2><p>state 就是 Vuex 中的公共的状态, 我是将 state 看作是所有组件的 data, 用于保存所有组件的公共数据.</p>
<h2 id="核心概念-2-Getters"><a href="#核心概念-2-Getters" class="headerlink" title="核心概念 2: Getters"></a>核心概念 2: Getters</h2><p>我将 getters 属性理解为所有组件的 computed 属性, 也就是计算属性. vuex 的官方文档也是说到可以将 getter 理解为 store 的计算属性, getters 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p>
<h2 id="核心概念-3-Mutations"><a href="#核心概念-3-Mutations" class="headerlink" title="核心概念 3: Mutations"></a>核心概念 3: Mutations</h2><p>我将 mutaions 理解为 store 中的 methods, mutations 对象中保存着更改数据的回调函数, 该函数名官方规定叫 type, 第一个参数是 state, 第二参数是 payload, 也就是自定义的参数.</p>
<h2 id="核心概念-4-Actions"><a href="#核心概念-4-Actions" class="headerlink" title="核心概念 4: Actions"></a>核心概念 4: Actions</h2><p>actions 类似于 mutations，不同在于：actions 提交的是 mutations 而不是直接变更状态 actions 中可以包含异步操作, mutations 中绝对不允许出现异步 actions 中的回调函数的第一个参数是 context, 是一个与 store 实例具有相同属性和方法的对象</p>
<h1 id="vue-组件之间相互传值：父传子-子传父"><a href="#vue-组件之间相互传值：父传子-子传父" class="headerlink" title="vue 组件之间相互传值：父传子 子传父"></a>vue 组件之间相互传值：父传子 子传父</h1><h2 id="父组件向子组件传值步骤"><a href="#父组件向子组件传值步骤" class="headerlink" title="父组件向子组件传值步骤"></a>父组件向子组件传值步骤</h2><ol>
<li>创建子组件，在 src/components/ 文件夹下新建一个 Child.vue<br>2.Child.vue 的中创建 props，然后创建一个名为 message 的属性</li>
<li>在 App.vue 中注册 Child 组件，并在 template 中加入 child 标签，标签中添加 message 属性并赋值</li>
</ol>
<pre><code class="html">//Child.vue
&lt;template&gt;
    &lt;div&gt;
        &lt;h2&gt;child 子组件&lt;/h2&gt;
        &lt;p&gt;{{message}}&lt;/p&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {props: [&quot;message&quot;]
    }
&lt;/script&gt;

//App.vue
&lt;template&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;child message=&quot;hello&quot;&gt;&lt;/child&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    import child from &#39;./components/Child&#39;
    export default {
        name: &#39;app&#39;,
        components: {child}
    }
&lt;/script&gt;
</code></pre>
<h2 id="子组件向父组件传值步骤"><a href="#子组件向父组件传值步骤" class="headerlink" title="子组件向父组件传值步骤"></a>子组件向父组件传值步骤</h2><ol>
<li>在子组件中创建一个按钮，给按钮绑定一个点击事件</li>
<li>在响应该点击事件的函数中使用 $emit 来触发一个自定义事件，并传递一个参数</li>
<li>在父组件中的子标签中监听该自定义事件并添加一个响应该事件的处理方法</li>
<li>保存修改的文件，在浏览器中点击按钮</li>
</ol>
<pre><code class="html">//Child.vue
&lt;template&gt;
    &lt;div&gt;
        &lt;h2&gt;child 子组件&lt;/h2&gt;
        &lt;p&gt;{{message}}&lt;/p&gt;
        &lt;button v-on:click=&quot;sendMsgToParent&quot;&gt;向父组件传值&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {props: [&quot;message&quot;]
        methods:{sendMsgToParent:function(){this.$emit(&quot;listenToChildEvent&quot;,&quot;this message is from child&quot;)
            }
        }
    }
&lt;/script&gt;

//App.vue
&lt;template&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;child v-bind:message=&quot;parentMsg&quot; v-on:listenToChildEvent=&quot;showMsgFromChild&quot;&gt;&lt;/child&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    import child from &#39;./components/Child&#39;
    export default {
        name: &#39;app&#39;,
        data(){return{parentMsg:&quot;hello child&quot;}
        },
        methods:{showMsgFromChild:function(data){consolo.log(data)
            }
        },
        components: {child}
    }
&lt;/script&gt;
</code></pre>
<h1 id="vue2-0-中的-router-和-route-的区别"><a href="#vue2-0-中的-router-和-route-的区别" class="headerlink" title="vue2.0 中的 \$router 和 \$route 的区别"></a>vue2.0 中的 \$router 和 \$route 的区别</h1><p>1.router 是 VueRouter 的一个对象，通过 Vue.use(VueRouter)和 VueRouter 构造函数得到一个 router 的实例对象，这个对象中是一个全局的对象，他包含了所有的路由包含了许多关键的对象和属性。</p>
<p>举例：history 对象</p>
<p>$router.push({path:’home’}); 本质是向 history 栈中添加一个路由，在我们看来是 切换路由，但本质是在添加一个 history 记录</p>
<p>方法：</p>
<p>$router.replace({path:’home’});// 替换路由，没有历史记录</p>
<p>2.route 是一个跳转的路由对象，每一个路由都会有一个 route 对象，是一个局部的对象，可以获取对应的 name,path,params,query 等</p>
<p>我们可以从 vue devtools 中看到每个路由对象的不同</p>
<h1 id="如何优化-SPA-应用的首屏加载速度慢的问题？"><a href="#如何优化-SPA-应用的首屏加载速度慢的问题？" class="headerlink" title="如何优化 SPA 应用的首屏加载速度慢的问题？"></a>如何优化 SPA 应用的首屏加载速度慢的问题？</h1><ol>
<li>将公用的 JavaScript 库通过 script 标签外部引入，减小 app.bundel 的大小，让浏览器并行下载资源文件，提高下载速度；</li>
<li>在配置路由时，页面和组件使用懒加载的方式引入，进一步缩小 app.bundel 的体积，在调用某个组件时再加载对应的 JavaScript 文件；</li>
<li>加一个首屏 loading 图，提升用户体验</li>
</ol>
<h1 id="网页从输入网址到渲染完成经历了哪些过程？"><a href="#网页从输入网址到渲染完成经历了哪些过程？" class="headerlink" title="网页从输入网址到渲染完成经历了哪些过程？"></a>网页从输入网址到渲染完成经历了哪些过程？</h1><ol>
<li>输入网址；</li>
<li>发送到 DNS 服务器，并获取域名对应的 web 服务器对应的 ip 地址；</li>
<li>与 web 服务器建立 TCP 连接；</li>
<li>浏览器向 web 服务器发送 http 请求；</li>
<li>web 服务器响应请求，并返回指定 url 的数据（或错误信息，或重定向的新的 url 地址）；</li>
<li>浏览器下载 web 服务器返回的数据及解析 html 源文件；</li>
<li>生成 DOM 树，解析 css 和 JavaScript，渲染页面，直至显示完成.</li>
</ol>
<h1 id="ajax-请求的过程"><a href="#ajax-请求的过程" class="headerlink" title="ajax 请求的过程"></a>ajax 请求的过程</h1><ol>
<li>创建 XMLHttpRequest 对象</li>
<li>创建一个新的 HTTP 请求, 并指定该 HTTP 请求的方法、URL 及验证信息.</li>
<li>设置响应 HTTP 请求状态变化的函数.</li>
<li>发送 HTTP 请求.</li>
<li>获取异步调用返回的数据.</li>
<li>使用 JavaScript 和 DOM 实现局部刷新.</li>
</ol>
<h1 id="js-数组去重"><a href="#js-数组去重" class="headerlink" title="js 数组去重"></a>js 数组去重</h1><h2 id="set-去重"><a href="#set-去重" class="headerlink" title="set 去重"></a>set 去重</h2><pre><code class="JavaScript">let array = [1,1,1,1,2,3,3,3,4,5,3]
let set = new Set(array)
console.log(set)
//Set{1,2,3,4,5}
</code></pre>
<h2 id="js-去重"><a href="#js-去重" class="headerlink" title="js 去重"></a>js 去重</h2><pre><code class="JavaScript">// 新建一个新数组，遍历传入数组，值不在新数组就 push 进去
function uniq(array){var temp = [] // 新数组
    for(var i = 0; i&lt;array.length; i++){if (temp.indexOf(array[i]) == -1){temp.push(array[i])
        }
    }
    return temp
}

var array1 = [1,1,1,1,2,3,4,5,5,5,6,7,3,2,4]
console.log(uniq(array1))
//[1,2,3,4,5,6,7]
</code></pre>
<h1 id="js-数组排序"><a href="#js-数组排序" class="headerlink" title="js 数组排序"></a>js 数组排序</h1><pre><code class="JavaScript">// 在数组最后插入一个最大数 100
// 然后进行递减排序(递增排序则为 a-b）
// 再移除最大数
var arr1 = [3,2,1,5,8,6,3]
arr1.push(100)
arr1.sort(function(a,b){return b-a}
)arr1.splice(0,1)
console.log(arr1)
</code></pre>
<h1 id="js-的原型和原型链"><a href="#js-的原型和原型链" class="headerlink" title="js 的原型和原型链"></a>js 的原型和原型链</h1><h2 id="JavaScript-原型"><a href="#JavaScript-原型" class="headerlink" title="JavaScript 原型"></a>JavaScript 原型</h2><p>JavaScript 中每个函数都存在有一个原型对象属性 prototype。并且所有函数的默认原型都是 Object 的实例。</p>
<h2 id="JavaScript-原型链"><a href="#JavaScript-原型链" class="headerlink" title="JavaScript 原型链"></a>JavaScript 原型链</h2><p>每个继承父函数的子函数的对象都包含一个内部属性 <em>proto</em>。该属性包含一个指针，指向父函数的 prototype。若父函数的原型对象的 <em>proto</em> 属性为再上一层函数。在此过程中就形成了原型链。<br>原型链实现了继承。</p>
<h1 id="JavaScript-实现继承的方法"><a href="#JavaScript-实现继承的方法" class="headerlink" title="JavaScript 实现继承的方法"></a>JavaScript 实现继承的方法</h1><h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>核心：将父类的实例作为子类的原型</p>
<pre><code class="JavaScript">function Cat(){}
Cat.prototype = new Animal()
Cat.prototype.name = &quot;cat&quot;

//Test Code
var cat = new Cat()console.log(cat.name)
console.log(cat.eat(&#39;fish&#39;))
console.log(cat.sleep())
console.log(cat instanceof Animal) //true
console.log(cat instanceof Cat) //true
</code></pre>
<h2 id="构造继承"><a href="#构造继承" class="headerlink" title="构造继承"></a>构造继承</h2><p>核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</p>
<pre><code class="JavaScript">function Cat(name){Animal.call(this)
    this.name = name || &#39;Tom&#39;
}

//Test Code
var cat = new Cat()console.log(cat.name)
console.log(cat.sleep())
console.log(cat instanceof Animal) //false
console.log(cat instanceof Cat) //true

</code></pre>
<h2 id="实例继承"><a href="#实例继承" class="headerlink" title="实例继承"></a>实例继承</h2><p>核心：为父类实例添加新特性，作为子类实例返回</p>
<pre><code class="JavaScript">function Cat(name){var instance = new AnimationPlaybackEvent()
    instance.name = name || &#39;Tom&#39;
    return instance
}

// Test Code
var cat = new Cat()console.log(cat.name)
console.log(cat.sleep())
console.log(cat instanceof Animal) //true
console.log(cat instanceof Cat) //false
</code></pre>
<h1 id="JavaScript-的基本数据类型"><a href="#JavaScript-的基本数据类型" class="headerlink" title="JavaScript 的基本数据类型"></a>JavaScript 的基本数据类型</h1><p>基本类型：String Number Boolean Symbol Undefined Null<br>引用类型：Object</p>
<h1 id="JavaScript-有哪些内置对象"><a href="#JavaScript-有哪些内置对象" class="headerlink" title="JavaScript 有哪些内置对象"></a>JavaScript 有哪些内置对象</h1><p>Math 对象：Math.abs(x);// 用来返回数的绝对值</p>
<p>Date 对象：var date = new Date();// 通过 new 的方式创建一个日期对象；</p>
<p>Array 对象：var arr=new Array();</p>
<p>字符串对象：var str=new String();</p>
<h1 id="JavaScript-操作数组的方法"><a href="#JavaScript-操作数组的方法" class="headerlink" title="JavaScript 操作数组的方法"></a>JavaScript 操作数组的方法</h1><p>join()：join(separator): 将数组的元素组起一个字符串，以 separator 为分隔符，省略的话则用默认用逗号为分隔符，该方法只接收一个参数：即分隔符。</p>
<p>push(): 可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。 </p>
<p>pop()：数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。</p>
<p>shift()：删除原数组第一项，并返回删除元素的值；如果数组为空则返回 undefined 。 </p>
<p>unshift(): 将参数添加到原数组开头，并返回数组的长度</p>
<p>sort()：按升序排列数组项——即最小的值位于最前面，最大的值排在最后面</p>
<p>reverse()：反转数组项的顺序。</p>
<p>concat()：将参数添加到原数组中。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给 concat()方法传递参数的情况下，它只是复制当前数组并返回副本。</p>
<p>slice()：返回从原数组中指定开始下标到结束下标之间的项组成的新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下， slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。</p>
<p>splice()：很强大的数组方法，它有很多种用法，可以实现删除、插入和替换。</p>
<p>删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如， splice(0,2)会删除数组中的前两项。</p>
<p>插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。例如，splice(2,0,4,6)会从当前数组的位置 2 开始插入 4 和 6。</p>
<p>替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice (2,1,4,6)会删除当前数组位置 2 的项，然后再从位置 2 开始插入 4 和 6。</p>
<p>splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项，如果没有删除任何项，则返回一个空数组。</p>
<p>indexOf()（ES5 新增）：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。</p>
<p>lastIndexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的末尾开始向前查找。</p>
<p>这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回 -1。在比较第一个参数与数组中的每一项时，会使用全等操作符。</p>
<p>forEach()（ES5 新增）：对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是 function 类型，默认有传参，参数分别为：遍历的数组内容；对应的数组索引，数组本身。</p>
<p>map()（ES5 新增）：指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</p>
<p>filter()（ES5 新增）：“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。</p>
<p>every()（ES5 新增）：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回 true。</p>
<p>some()（ES5 新增）：判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回 true。</p>
<p>reduce()和 reduceRight() （ES5 新增）这两个方法都会实现迭代数组的所有项，然后构建一个最终返回的值。reduce()方法从数组的第一项开始，逐个遍历到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。</p>
<p>这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。</p>
<p>传给 reduce()和 reduceRight()的函数接收 4 个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。</p>
<h1 id="什么是闭包，闭包的优缺点"><a href="#什么是闭包，闭包的优缺点" class="headerlink" title="什么是闭包，闭包的优缺点"></a>什么是闭包，闭包的优缺点</h1><p>闭包各种专业文献的闭包定义都非常抽象，我的理解是: 闭包就是能够读取其他函数内部变量的函数。</p>
<p>由于在 javascript 中，只有函数内部的子函数才能读取局部变量，所以说，闭包可以简单理解成“定义在一个函数内部的函数“。</p>
<p>所以，在本质上，闭包是将函数内部和函数外部连接起来的桥梁。</p>
<p>优点：</p>
<ol>
<li>逻辑连续，当闭包作为另一个函数调用的参数时，避免你脱离当前逻辑而单独编写额外逻辑。</li>
<li>方便调用上下文的局部变量。</li>
<li>加强封装性，第 2 点的延伸，可以达到对变量的保护作用。<br>缺点：<br>闭包有一个非常严重的问题，那就是内存浪费问题，这个内存浪费不仅仅因为它常驻内存，更重要的是，对闭包的使用不当会造成无效内存的产生</li>
</ol>
<h1 id="阻止时间冒泡和默认事件"><a href="#阻止时间冒泡和默认事件" class="headerlink" title="阻止时间冒泡和默认事件"></a>阻止时间冒泡和默认事件</h1><ol>
<li>e.stopPropagation()2. e.preventDefault()，</li>
<li>return false</li>
</ol>
<h1 id="JavaScript-中-apply、call、bind-的区别"><a href="#JavaScript-中-apply、call、bind-的区别" class="headerlink" title="JavaScript 中 apply、call、bind 的区别"></a>JavaScript 中 apply、call、bind 的区别</h1><p>在 JavaScript 中，这三者都是用来改变函数的 this 对象的指向的，他们有什么样的区别呢。</p>
<p>在说区别之前还是先总结一下三者的相似之处：</p>
<ol>
<li>都是用来改变函数的 this 对象的指向的。</li>
<li>第一个参数都是 this 要指向的对象。</li>
<li>都可以利用后续参数传参</li>
</ol>
<p>call 和 apply 都是对函数的直接调用，而 bind 方法返回的仍然是一个函数，因此后面还需要 () 来进行调用才可以。</p>
<p>call 后面的参数与 say 方法中是一一对应的，而 apply 的第二个参数是一个数组，数组中的元素是和 say 方法中一一对应的，这就是两者最大的区别。</p>
<pre><code class="JavaScript">var xw = {
    name : &quot;小王&quot;,
    gender : &quot;男&quot;,
    age : 24,
    say : function() {alert(this.name + &quot;,&quot; + this.gender + &quot;, 今年&quot; + this.age);                                
    }
}
var xh = {
    name : &quot;小红&quot;,
    gender : &quot;女&quot;,
    age : 18
}
xw.say();// 小王，男，今年 24

// 小红
xw.say.call(xh);
xw.say.apply(xh);
xw.say.bind(xh)();
</code></pre>
<pre><code class="JavaScript">var xw = {
    name : &quot;小王&quot;,
    gender : &quot;男&quot;,
    age : 24,
    say : function(school,grade) {alert(this.name + &quot;,&quot; + this.gender + &quot;, 今年&quot; + this.age + &quot;, 在&quot; + school + &quot;上&quot; + grade);                                
    }
}
var xh = {
    name : &quot;小红&quot;,
    gender : &quot;女&quot;,
    age : 18
}

// 小红
xw.say.call(xh,&quot;实验小学&quot;,&quot;六年级&quot;);       
xw.say.apply(xh,[&quot;实验小学&quot;,&quot;六年级&quot;]);
xw.say.bind(xh,&quot;实验小学&quot;,&quot;六年级&quot;)();
xw.say.bind(xh)(&quot;实验小学&quot;,&quot;六年级&quot;);
</code></pre>
<h1 id="如何解决跨域的问题"><a href="#如何解决跨域的问题" class="headerlink" title="如何解决跨域的问题"></a>如何解决跨域的问题</h1><p>JSONP：利用 script 标签可跨域的特点，在跨域脚本中可以直接回调当前脚本的函数。</p>
<h1 id="vue-this-set-给-data-对象新增属性，并触发视图更新"><a href="#vue-this-set-给-data-对象新增属性，并触发视图更新" class="headerlink" title="vue this.$set 给 data 对象新增属性，并触发视图更新"></a>vue this.$set 给 data 对象新增属性，并触发视图更新</h1><p>语法 <code>this.$set(this.data, &quot;key&quot;, value)</code></p>
<h1 id="写一个闭包"><a href="#写一个闭包" class="headerlink" title="写一个闭包"></a>写一个闭包</h1><p>实现 foo(1)(2) 输出 3</p>
<pre><code class="JavaScript">var result = foo(1)(2)

alert(result)

function foo(a){return function(b){return a+b}
}
</code></pre>
<h1 id="HTTP-中-Get、Post、Put-与-Delete-的区别"><a href="#HTTP-中-Get、Post、Put-与-Delete-的区别" class="headerlink" title="HTTP 中 Get、Post、Put 与 Delete 的区别"></a>HTTP 中 Get、Post、Put 与 Delete 的区别</h1><p>1、GET 请求会向数据库发索取数据的请求，从而来获取信息，该请求就像数据库的 select 操作一样，只是用来查询一下数据，不会修改、增加数据，不会影响资源的内容，即该请求不会产生副作用。无论进行多少次操作，结果都是一样的。</p>
<p>2、与 GET 不同的是，PUT 请求是向服务器端发送数据的，从而改变信息，该请求就像数据库的 update 操作一样，用来修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次 PUT 操作，其结果并没有不同。</p>
<p>3、POST 请求同 PUT 请求类似，都是向服务器端发送数据的，但是该请求会改变数据的种类等资源，就像数据库的 insert 操作一样，会创建新的内容。几乎目前所有的提交操作都是用 POST 请求的。</p>
<p>4、DELETE 请求顾名思义，就是用来删除某一个资源的，该请求就像数据库的 delete 操作。</p>
<p>就像前面所讲的一样，既然 PUT 和 POST 操作都是向服务器端发送数据的，那么两者有什么区别呢。。。POST 主要作用在一个集合资源之上的（url），而 PUT 主要作用在一个具体资源之上的（url/xxx），通俗一下讲就是，如 URL 可以在客户端确定，那么可使用 PUT，否则用 POST。</p>
<p>1、POST /url 创建<br>2、DELETE /url/xxx 删除<br>3、PUT /url/xxx 更新<br>4、GET /url/xxx 查看</p>
<h1 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h1><p>1, 箭头函数是匿名函数，不能作为构造函数，不能使用 new</p>
<p>2, 箭头函数不绑定 arguments，取而代之用 rest 参数… 解决</p>
<p>3, 箭头函数不绑定 this，会捕获其所在的上下文的 this 值，作为自己的 this 值</p>
<p>4, 箭头函数通过 call()或 apply() 方法调用一个函数时，只传入了一个参数，对 this 并没有影响。</p>
<p>5, 箭头函数没有原型属性</p>
<p>6, 箭头函数不能当做 Generator 函数, 不能使用 yield 关键字</p>
<h1 id="es6-新特性"><a href="#es6-新特性" class="headerlink" title="es6 新特性"></a>es6 新特性</h1><p>let+const 块级作用域, 有了块级作用域，还可以像强类型语言一样定义常量。由于之前没有块级作用域以及 var 关键字所带来的变量提升, 经常给我们的开发带来一些莫名其妙的问题.</p>
<p>Arrows 箭头函数</p>
<p>Class, extends, super 类的支持</p>
<p>模板字面量用倒引号(<code></code>)</p>
<h1 id="Promise-的理解和使用"><a href="#Promise-的理解和使用" class="headerlink" title="Promise 的理解和使用"></a>Promise 的理解和使用</h1><p>promise 对象有两个特点:(1)对象的状态不受外界外界影响.promise 对象代表一个异步操作, 有三种状态;pending(进行中),fulfilled(已成功)和 rejected(已失败). 只有异步操作的结果, 可以决定当前是哪一种状态;(2)一旦状态改变, 就不会再改变, 任何时候都可以得到这个结果.promise 的状态改变, 只有两种可能: 从 pending 变为 fulfilled 和从 pending 变成 rejected. 只要这两种状态情况发生, 状态就凝固了, 不会再变了, 会一直保持这个结果, 这时就称为 resolved(已定型).</p>
<p>基本用法</p>
<p>new Promise(/<em> executor </em>/ function(resolve, reject) {…} )</p>
<p>promise 接受一个函数作为参数, 该函数的两个参数分别是 resolve 和 reject. 它们是两个函数, 由 JavaScript 引擎提供, 不用自己部署.</p>
<p>then 方法</p>
<p>Promise 实例具有 then 方法, 也就是说,then 方法是定义在原型对象 Promise.prototype 上的, 它的作用是是为 Promise 实例添加状态改变时的回调函数.then 方法的第一个参数是 resolved 状态的回调函数, 第二个参数 (可选) 是 rejected 状态的回调函数. 并且 then 方法返回的是一个新的 Promise 实例</p>
<h1 id="常用的-http-方法有哪些"><a href="#常用的-http-方法有哪些" class="headerlink" title="常用的 http 方法有哪些?"></a>常用的 http 方法有哪些?</h1><p>GET: 用于请求访问已经被 url 识别的资源, 可以通过 url 传参给服务器.</p>
<p>POST: 用于传输信息给服务器, 主要功能 GET 类似, 但一般推荐使用 POST 方式.</p>
<p>PUT: 传输文件, 报文主体中包含文件内容, 保存到对应的 url 位置.</p>
<p>HEAD: 获得报文首部, 与 GET 方法类似, 只是不返回报文主体, 一般用于验证 url 是否有效.</p>
<p>DELETE: 删除文件, 与 PUT 方法相反, 删除对应 URL 位置的文件.</p>
<p>OPTIONS: 查询对应 url 支持的 http 方法</p>
<h1 id="GET-和-POST-的区别"><a href="#GET-和-POST-的区别" class="headerlink" title="GET 和 POST 的区别"></a>GET 和 POST 的区别</h1><p>区别一:</p>
<p>GET 重点从服务器上获取资源,POST 重点向服务器发送数据.</p>
<p>区别二:</p>
<p>get 传输数据是通过 URL 请求，置于 URL 后，并用”?”连接，多个请求数据间用”&amp;”连接.<br>post 传输数据通过 Http 的 post 机制，将字段与对应值封存在请求实体中发送给服务器，这个过程对用户是不可见的；</p>
<p>区别三:</p>
<p>Get 传输的数据量小，因为受 URL 长度限制，但效率较高；<br>Post 可以传输大量数据，所以上传文件时只能用 Post 方式；</p>
<p>区别四:</p>
<p>get 是不安全的，因为 URL 是可见的，可能会泄露私密信息，如密码等；<br>post 较 get 安全性较高；</p>
<p>区别五:</p>
<p>get 方式只能支持 ASCII 字符，向服务器传的中文字符可能会乱码。<br>post 支持标准字符集，可以正确传递中文字符。</p>
<h1 id="HTTP-请求报文与响应报文格式"><a href="#HTTP-请求报文与响应报文格式" class="headerlink" title="HTTP 请求报文与响应报文格式"></a>HTTP 请求报文与响应报文格式</h1><p>请求报文包含三部分：<br>a、请求行：包含请求方法、URL、HTTP 版本信息<br>b、请求首部字段<br>c、请求内容实体</p>
<p>响应报文包含三部分：<br>a、状态行：包含 HTTP 版本、状态码、状态码的原因短语<br>b、响应首部字段<br>c、响应内容实体</p>
<h1 id="怎样添加、移除、移动、复制、创建和查找节点？"><a href="#怎样添加、移除、移动、复制、创建和查找节点？" class="headerlink" title="怎样添加、移除、移动、复制、创建和查找节点？"></a>怎样添加、移除、移动、复制、创建和查找节点？</h1><p>1）创建新节点</p>
<p>createDocumentFragment() // 创建一个 DOM 片段</p>
<p>createElement() // 创建一个具体的元素</p>
<p>createTextNode() // 创建一个文本节点</p>
<p>2）添加、移除、替换、插入</p>
<p>appendChild() // 添加</p>
<p>removeChild() // 移除</p>
<p>replaceChild() // 替换</p>
<p>insertBefore() // 插入</p>
<p>3）查找</p>
<p>getElementsByTagName() // 通过标签名称</p>
<p>getElementsByName() // 通过元素的 Name 属性的值</p>
<p>getElementById() // 通过元素 Id，唯一性</p>
<h1 id="谈谈-Cookie-的弊端"><a href="#谈谈-Cookie-的弊端" class="headerlink" title="谈谈 Cookie 的弊端"></a>谈谈 Cookie 的弊端</h1><p>1.IE6 或更低版本最多 20 个 cookie<br>2.IE7 和之后的版本最后可以有 50 个 cookie。<br>3.Firefox 最多 50 个 cookie<br>4.chrome 和 Safari 没有做硬性限制</p>
<p>优点：极高的扩展性和可用性</p>
<ol>
<li>通过良好的编程，控制保存在 cookie 中的 session 对象的大小。</li>
<li>通过加密和安全传输技术（SSL），减少 cookie 被破解的可能性。</li>
<li>只在 cookie 中存放不敏感数据，即使被盗也不会有重大损失。</li>
<li>控制 cookie 的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的 cookie。</li>
</ol>
<p>缺点：<br>1.Cookie 数量和长度的限制。每个 domain 最多只能有 20 条 cookie，每个 cookie 长度不能超过 4KB，否则会被截掉。</p>
<ol start="2">
<li>安全性问题。如果 cookie 被人拦截了，那人就可以取得所有的 session 信息。即使加密也与事无补，因为拦截者并不需要知道 cookie 的意义，他只要原样转发 cookie 就可以达到目的了。</li>
<li>有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。</li>
</ol>
<h1 id="display-none-和-visibility-hidden-的区别？"><a href="#display-none-和-visibility-hidden-的区别？" class="headerlink" title="display:none 和 visibility:hidden 的区别？"></a>display:none 和 visibility:hidden 的区别？</h1><p>display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，<br>就当他从来不存在。</p>
<p>visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。</p>
<h1 id="CSS-中-link-和-import-的区别是？"><a href="#CSS-中-link-和-import-的区别是？" class="headerlink" title="CSS 中 link 和 @import 的区别是？"></a>CSS 中 link 和 @import 的区别是？</h1><p>(1) link 属于 HTML 标签，而 @import 是 CSS 提供的;<br>(2) 页面被加载的时，link 会同时被加载，而 @import 引用的 CSS 会等到页面被加载完再加载;<br>(3) import 只在 IE5 以上才能识别，而 link 是 HTML 标签，无兼容问题;<br>(4) link 方式的样式的权重 高于 @import 的权重.</p>
<h1 id="position的absolute与fixed共同点与不同点"><a href="#position的absolute与fixed共同点与不同点" class="headerlink" title="position的absolute与fixed共同点与不同点"></a>position的absolute与fixed共同点与不同点</h1><p>共同点：<br>1.改变行内元素的呈现方式，display被置为block；<br>2.让元素脱离普通流，不占据空间；<br>3.默认会覆盖到非定位元素上</p>
<p>不同点：<br>absolute的”根元素“是可以设置的，而fixed的”根元素“固定为浏览器窗口。当你滚动网页，fixed元素与浏览器窗口之间的距离是不变的。</p>
<h1 id="CSS的盒子模型"><a href="#CSS的盒子模型" class="headerlink" title="CSS的盒子模型"></a>CSS的盒子模型</h1><p>1）有两种， IE 盒子模型、标准 W3C 盒子模型；IE的content部分包含了 border 和 padding;</p>
<p>2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border).</p>
<h1 id="CSS-选择符有哪些？哪些属性可以继承？优先级算法如何计算？-CSS3新增伪类有那些？"><a href="#CSS-选择符有哪些？哪些属性可以继承？优先级算法如何计算？-CSS3新增伪类有那些？" class="headerlink" title="CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？"></a>CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？</h1><p>1.id选择器（ # myid）<br>2.类选择器（ . myclassname）<br>3.标签选择器（div, h1, p）<br>4.相邻选择器（h1 + p）<br>5.子选择器（ul &gt; li）<br>6.后代选择器（li a）<br>7.通配符选择器（ * ）<br>8.属性选择器（a[rel = “external”]）<br>9.伪类选择器（a: hover, li:nth-child）</p>
<ul>
<li>可继承的样式： font-size font-family color, text-indent;</li>
<li>不可继承的样式：border padding margin width height ;</li>
<li>优先级就近原则，同权重情况下样式定义最近者为准;</li>
<li>载入样式以最后载入的定位为准;</li>
</ul>
<p>优先级为:<br>!important &gt; id &gt; class &gt; tag<br>important 比 内联优先级高,但内联比 id 要高</p>
<p>CSS3新增伪类举例：<br>p:first-of-type 选择属于其父元素的首个 </p><p> 元素的每个 </p><p> 元素。<br>p:last-of-type 选择属于其父元素的最后 </p><p> 元素的每个 </p><p> 元素。<br>p:only-of-type 选择属于其父元素唯一的 </p><p> 元素的每个 </p><p> 元素。<br>p:only-child 选择属于其父元素的唯一子元素的每个 </p><p> 元素。<br>p:nth-child(2) 选择属于其父元素的第二个子元素的每个 </p><p> 元素。<br>:enabled :disabled 控制表单控件的禁用状态。<br>:checked 单选框或复选框被选中。</p>
<h1 id="列出display的值，说明他们的作用"><a href="#列出display的值，说明他们的作用" class="headerlink" title="列出display的值，说明他们的作用"></a>列出display的值，说明他们的作用</h1><p>none： 隐藏对象。与visibility属性的hidden值不同，其不为被隐藏的对象保留其物理空间<br>inline： 指定对象为内联元素。<br>block： 指定对象为块元素。<br>list-item： 指定对象为列表项目。<br>inline-block： 指定对象为内联块元素。</p>
<h1 id="relative和absolute分别是相对于谁进行定位的？"><a href="#relative和absolute分别是相对于谁进行定位的？" class="headerlink" title="relative和absolute分别是相对于谁进行定位的？"></a>relative和absolute分别是相对于谁进行定位的？</h1><ul>
<li>absolute 生成绝对定位的元素，相对于 static 定位以外的第一个祖先元素进行定位。</li>
<li>fixed （老IE不支持）生成绝对定位的元素，相对于浏览器窗口进行定位。</li>
<li>relative 生成相对定位的元素，相对于其在普通流中的位置进行定位。</li>
<li>static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。</li>
<li>inherit 规定从父元素继承 position 属性的值。</li>
</ul>
<h1 id="对BFC规范的理解"><a href="#对BFC规范的理解" class="headerlink" title="对BFC规范的理解"></a>对BFC规范的理解</h1><p>BFC，块级格式化上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。在同一个BFC中的两个毗邻的块级盒在垂直方向（和布局方向有关系）的margin会发生折叠。<br>（W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行布局，以及与其他元素的关系和相互作用。）</p>
<h1 id="Doctype作用-严格模式与混杂模式如何区分？它们有何意义"><a href="#Doctype作用-严格模式与混杂模式如何区分？它们有何意义" class="headerlink" title="Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?"></a>Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</h1><p>（1）&lt;!DOCTYPE&gt; 声明位于文档中的最前面，处于 <html> 标签之前。告知浏览器以何种模式来渲染文档。<br>（2）严格模式的排版和 JavaScript 运作模式是 以该浏览器支持的最高标准运行。<br>（3）在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。<br>（4）DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。</html></p>
<h1 id="HTML与XHTML-——-二者有什么区别"><a href="#HTML与XHTML-——-二者有什么区别" class="headerlink" title="HTML与XHTML —— 二者有什么区别"></a>HTML与XHTML —— 二者有什么区别</h1><p>1.所有的标记都必须要有一个相应的结束标记<br>2.所有标签的元素和属性的名字都必须使用小写<br>3.所有的XML标记都必须合理嵌套<br>4.所有的属性必须用引号””括起来<br>5.把所有&lt;和&amp;特殊符号用编码表示<br>6.给所有属性赋一个值<br>7.不要在注释内容中使“–”<br>8.图片必须有说明文字</p>
<h1 id="解释下浮动和它的工作原理？清除浮动的技巧"><a href="#解释下浮动和它的工作原理？清除浮动的技巧" class="headerlink" title="解释下浮动和它的工作原理？清除浮动的技巧"></a>解释下浮动和它的工作原理？清除浮动的技巧</h1><p>浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。</p>
<p>1.使用空标签清除浮动。<br>这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签。<br><code>&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;</code><br>2.使用overflow。<br>给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1; zoom:1用于兼容IE6。<br>3.使用after伪对象清除浮动。<br>该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；<br><code>#parent:after{
content:&quot;.&quot;;
height:0;
visibility:hidden;
display:block;
clear:both;
}</code></p>
<h1 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h1><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><p>Object.assign会合并对象生成一个新对象。如果对象的属性是普通类型改变之后新对象不会改变，如果是引用类型改变后新对象也会改变，所以Object.assign实际上还是浅拷贝。</p>
<pre><code class="JavaScript">var obj = {a:{a:&quot;kobe&quot;,b:39}}
var initObj = Object.assign({},obj)
initObj.a.a = &quot;wade&quot;
console.log(obj.a.a) //wade
</code></pre>
<p>但是当object只有一层的时候，是深拷贝</p>
<pre><code class="JavaScript">let obj = {username:&#39;kobe&#39;}
let initObj = Object.assign({},obj)
initObj.username = &#39;wade&#39;
console.log(obj.username) //kobe
</code></pre>
<h3 id="Array-prototype-concat"><a href="#Array-prototype-concat" class="headerlink" title="Array.prototype.concat()"></a>Array.prototype.concat()</h3><pre><code class="JavaScript">let arr = [1,3,{username:&#39;kobe&#39;}]
let arr2 = arr.concat()
arr2[2].username = &#39;wade&#39;
console.log(arr) //[1,3,{username:&#39;wade&#39;}]
</code></pre>
<h3 id="Array-prototype-slice"><a href="#Array-prototype-slice" class="headerlink" title="Array.prototype.slice()"></a>Array.prototype.slice()</h3><pre><code class="JavaScript">let arr = [1,3,{username:&#39;kobe&#39;}]
let arr2 = arr.slice()
arr2[2].username = &#39;wade&#39;
console.log(arr) //[1,3,{username:&#39;wade&#39;}]
</code></pre>
<p>关于Array的slice和concat方法的补充说明：Array的slice和concat方法不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。</p>
<p>原数组的元素会按照下述规则拷贝：</p>
<ul>
<li>如果该元素是个对象引用(不是实际的对象)，slice 会拷贝这个对象引用到新的数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变。</li>
<li>对于字符串、数字及布尔值来说（不是 String、Number 或者 Boolean 对象），slice 会拷贝这些值到新的数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组。</li>
</ul>
<pre><code class="JavaScript">let arr = [1,3,{username:&#39;kobe&#39;}]
let arr2 = arr.slice()
arr2[1] = 10
console.log(arr,arr2) //【1,3,{...}][1,10,{...}]
</code></pre>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><h3 id="JSON-parse-JSON-stringify"><a href="#JSON-parse-JSON-stringify" class="headerlink" title="JSON.parse(JSON.stringify())"></a>JSON.parse(JSON.stringify())</h3><pre><code class="JavaScript">let arr = [1, 3, {username: &#39; kobe&#39;}];
let arr4 = JSON.parse(JSON.stringify(arr));
arr4[2].username = &#39;duncan&#39;; 
console.log(arr, arr4)//[1,3,{&#39;kobe&#39;}][1,3,{&#39;duncan&#39;}]
</code></pre>
<p>原理： 用JSON.stringify将对象转成JSON字符串，再用JSON.parse()把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。<br>这种方法虽然可以实现数组或对象深拷贝，但不能处理函数。</p>
<pre><code class="JavaScript">let arr = [1, 3, { username: &#39; kobe&#39; },function(){}];
let arr4 = JSON.parse(JSON.stringify(arr));
arr4[2].username = &#39;duncan&#39;; 
console.log(arr, arr4)//[1,3,{&#39;kobe&#39;},f()][1,3,{&#39;duncan&#39;},null]
</code></pre>
<p>这是因为 JSON.stringify() 方法是将一个JavaScript值(对象或者数组)转换为一个 JSON字符串，不能接受函数。</p>
<h3 id="手写递归方法"><a href="#手写递归方法" class="headerlink" title="手写递归方法"></a>手写递归方法</h3><p>递归方法实现深度克隆原理：遍历对象、数组直到里边都是基本数据类型，然后再去复制，就是深度拷贝。</p>
<pre><code class="JavaScript">//定义检测数据类型的功能函数

function checkedType(target) {
    return Object.prototype.toString.call(target).slice(8, -1)
}

//实现深度克隆---对象/数组

function clone(target) {

    //判断拷贝的数据类型

    //初始化变量result 成为最终克隆的数据

    let result, targetType = checkedType(target)

    if (targetType === &#39;object&#39;) {
        result = {}
     } else if (targetType === &#39;Array&#39;) {
        result = []
      } else {
        return target
      }

    //遍历目标数据
    for (let i in target) {
        //获取遍历数据结构的每一项值。
        let value = target[i]
        //判断目标结构里的每一值是否存在对象/数组
        if (checkedType(value) === &#39;Object&#39; ||
          checkedType(value) === &#39;Array&#39;) { //对象/数组里嵌套了对象/数组
          //继续遍历获取到value值
          result[i] = clone(value)
        } else { //获取到value值是基本的数据类型或者是函数。
          result[i] = value;
        }
      }
      return result
}
</code></pre>
<h3 id="函数库lodash"><a href="#函数库lodash" class="headerlink" title="函数库lodash"></a>函数库lodash</h3><p>该函数库也有提供 _.cloneDeep 用来做深拷贝</p>
<pre><code class="JavaScript">var _ = require(&#39;lodash&#39;);
var obj1 = {a: 1, b: { f: { g: 1 } },c: [1, 2, 3]};
var obj2 = _.cloneDeep(obj1);
console.log(obj1.b.f === obj2.b.f);
// false
</code></pre>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><h2 id="变量声明提升"><a href="#变量声明提升" class="headerlink" title="变量声明提升"></a>变量声明提升</h2><p>在 JavaScript 中，函数声明（function aa(){}）与变量声明（var）经常被 JavaScript 引擎隐式地提升到当前作用域的顶部。<br>函数声明的优先级高于变量，如果变量名跟函数名相同且未赋值，则函数声明会覆盖变量声明<br>声明语句中的赋值部分并不会被提升，只有变量的名称被提升</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>因为函数的嵌套形成作用域的层级关系。当函数执行时，从当前作用域开始搜，没有找到的变量，会向上层作用域查找，直至全局函数，这就是作用域链。</p>
<ul>
<li>在 JavaScript 中，作用域为 function(){}内的区域，称为函数作用域。</li>
<li>全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节</li>
</ul>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包的原理就是作用域链，比函数F内部有一个函数G，函数 G可以访问到函数F中的变量，那么函数G就是闭包。</p>
<pre><code class="JavaScript">function F() {
  let a = 1
  window.G = function () {
      console.log(a)
  }
}
F()  // 1
</code></pre>
<h1 id="原型和继承"><a href="#原型和继承" class="headerlink" title="原型和继承"></a>原型和继承</h1><h2 id="JavaScript创建对象的几种方法"><a href="#JavaScript创建对象的几种方法" class="headerlink" title="JavaScript创建对象的几种方法"></a>JavaScript创建对象的几种方法</h2><p>对象字面量</p>
<pre><code class="JavaScript">var obj = {}
</code></pre>
<p>new一个构造函数</p>
<pre><code class="JavaScript">function Pel(){}
var p=new Pel();
p.name=&quot;hu&quot;;
p.age=&quot;25&quot;;
p.address=function(){}
</code></pre>
<p>new一个内置对</p>
<pre><code class="JavaScript">var obj = new Object()
</code></pre>
<p>Object.create()创建对象</p>
<pre><code class="JavaScript">var test = Object.create({x:1})
</code></pre>
<h2 id="JavaScript如何实现一个类"><a href="#JavaScript如何实现一个类" class="headerlink" title="JavaScript如何实现一个类"></a>JavaScript如何实现一个类</h2><p>构造函数法<br>缺点：是用到了this和prototype，编写复杂，可读性差</p>
<pre><code class="JavaScript">function P(name, age){
     this.name = name;
     this.age= age;
   }
   P.prototype.sell= function(){}
   var pel= new P(&quot;jj&quot;, 1);
   pel.sell()
</code></pre>
<p>ES6语法糖class</p>
<pre><code class="JavaScript">class Point {
       constructor(x, y) {
         this.x = x;
         this.y = y;
       }
       toString() {
         return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;
       }
     }
  var point = new Point(2, 3);
</code></pre>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>遍历一个实列的属性时，先遍历实列对象上的属性，再遍历它的原型对象，一直遍历到Object</p>
<p>任何一个类（函数）都有原型对象，原型对象至少有两个属性（constructor,proto）。constructor指向函数本身，proto指向父类原型对象。</p>
<p>函数上有一个prototype属性，指向原型对象，通过它可以访问原型对象</p>
<p>函数的实列可以直接访问原型对象(因为实列上有proto指向构造函数的原型对象)</p>
<pre><code class="JavaScript">function Dog(){}        //类         
var obj=new Dog();      //实列
obj.name=&#39;沪江&#39;;
Dog.prototype.name=&quot;旺财&quot;;
Dog.prototype.eat=function(){
    console.log(this.name);
};
console.log(Dog.prototype.name);  //旺财
console.log(obj.prototype);      //undefined,prototype是类上才有的，实列上没有
obj.eat();                       //沪江（先遍历实列对象上的属性，再遍历它的原型对象）
</code></pre>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>构造函数绑定：使用 call 或 apply 方法，将父对象的构造函数绑定在子对象上</p>
<pre><code class="JavaScript">function Cat(name,color){
 　Animal.apply(this, arguments);
 　this.name = name;
 　this.color = color;
}
</code></pre>
<p>实例继承：将子对象的 prototype 指向父对象的一个实例</p>
<pre><code class="JavaScript">Cat.prototype = new Animal();
Cat.prototype.constructor = Cat;
</code></pre>
<p>拷贝继承：如果把父对象的所有属性和方法，拷贝进子对象</p>
<pre><code class="JavaScript">function extend(Child, Parent) {
　　　var p = Parent.prototype;
　　　var c = Child.prototype;
　　　for (var i in p) {
　　　   c[i] = p[i];
　　　}
　　　c.uber = p;
}
</code></pre>
<p>原型继承：将子对象的 prototype 指向父对象的 prototype</p>
<pre><code class="JavaScript">function extend(Child, Parent) {
    var F = function(){};
    　F.prototype = Parent.prototype;
    　Child.prototype = new F();
    　Child.prototype.constructor = Child;
    　Child.uber = Parent.prototype;
}
</code></pre>
<p>ES6 语法糖 extends继承</p>
<pre><code class="JavaScript">class ColorPoint extends Point {
    constructor(x, y, color) {
        super(x, y); // 调用父类的constructor(x, y)
        this.color = color;
    }
    toString() {
        return this.color + &#39; &#39; + super.toString(); // 调用父类的toString()
    }
}
</code></pre>
<h1 id="new和this"><a href="#new和this" class="headerlink" title="new和this"></a>new和this</h1><h2 id="new-操作符具体干了什么？"><a href="#new-操作符具体干了什么？" class="headerlink" title="new 操作符具体干了什么？"></a>new 操作符具体干了什么？</h2><p>首先是创建实例对象{}<br>this 变量引用该对象，同时还继承了构造函数的原型<br>其次属性和方法被加入到 this 引用的对象中<br>并且新创建的对象由 this 所引用，最后隐式的返回 this</p>
<h2 id="this对象的理解"><a href="#this对象的理解" class="headerlink" title="this对象的理解"></a>this对象的理解</h2><p>普通函数</p>
<ul>
<li>this 总是指向函数的直接调用者</li>
<li>如果有 new 关键字，this 指向 new 出来的实例对象</li>
<li>在事件中，this 指向触发这个事件的对象</li>
<li>IE 下 attachEvent 中的 this 总是指向全局对象 Window</li>
<li>箭头函数中，函数体内的this对象，就是定义时所在作用域的对象，而不是使用时所在的作用域的对象。</li>
</ul>
<pre><code class="JavaScript">function foo() {
  console.log(this.a)
}
var a = 1
foo()           //1       
​
const obj = {
  a: 2,
  foo: foo
}
obj.foo()      //2
​
const c = new foo()   //undefined
</code></pre>
<ul>
<li>对于直接调用 foo 来说，不管 foo 函数被放在了什么地方，this 一定是window</li>
<li>对于 obj.foo() 来说，我们只需要记住，谁调用了函数，谁就是 this，所以在这个场景下 foo 函数中的 this 就是 obj 对象</li>
<li>对于 new 的方式来说，this 被永远绑定在了 new出来的对象上，不会被任何方式改变 this</li>
</ul>
<p>箭头函数中的 this</p>
<pre><code class="JavaScript">function a() {
  return () =&gt; {
    return () =&gt; {
      console.log(this)
    }
  }
}
a()()()        //Window
</code></pre>
<p>首先箭头函数其实是没有 this 的，箭头函数中的 this 只取决包裹箭头函数的第一个普通函数的 this。在这个例子中，因为包裹箭头函数的第一个普通函数是 a，所以此时的 this 是 window。另外对箭头函数使用 bind这类函数是无效的。</p>
<h1 id="apply、call、bind"><a href="#apply、call、bind" class="headerlink" title="apply、call、bind"></a>apply、call、bind</h1><p>call、apply和bind是Function对象自带的三个方法，都是为了改变函数体内部 this 的指向。<br>apply 、 call 、bind 三者第一个参数都是 this 要指向的对象，也就是想指定的上下文；<br>apply 、 call 、bind 三者都可以利用后续参数传参；<br>bind 是返回对应 函数，便于稍后调用；apply 、call 则是立即调用 。</p>
<pre><code class="JavaScript">function fruits() {}

fruits.prototype = {
    color: &#39;red&#39;,
    say: function() {
        console.log(this.color);
    }
};

var apple = new fruits();

apple.say();   // red, 此时方法里面的this 指的是fruits

banana = {color: &#39;yellow&#39;};
apple.say.call(banana); //yellow,此时的this的指向已经通过call（）方法改变了，指向的是banana，this.color就是banana.color=&#39;yellow&#39;;

apple.say.apply(banana);//yellow,同理，此时的this的指向已经通过apply（）方法改变了，指向的是banana，this.color就是banana.color =&#39;yellow&#39;;

apple.say.apply(null); //undefined, null是window下的，此时，this 就指向了window ，但是window下并没有clolr这个属性，因此this.clolr就是window.color=undefined;
</code></pre>
<p>bind() 方法会创建一个 新函数，当调用这个新函数时，新函数会以创建它时传入 bind() 方法的第一个参数 作为 this，传入 bind() 方法的 第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p>
<pre><code class="JavaScript">var bar = function(){
    console.log(this.x);
};
var foo = {
    x:3
};
bar();    // undefined
var func = bar.bind(foo); 

func(); // 3
</code></pre>
]]></content>
      <categories>
        <category>面试汇总</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 基础汇总</title>
    <url>/2020/04/03/JavaScript%E5%9F%BA%E7%A1%80%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="JS-基础"><a href="#JS-基础" class="headerlink" title="JS 基础"></a>JS 基础</h1><a id="more"></a>
<h2 id="JavaScript-简介"><a href="#JavaScript-简介" class="headerlink" title="JavaScript 简介"></a>JavaScript 简介</h2><p>JavaScript 是一种轻量级的编程脚本语言<br>ECMA-262 是 JavaScript 标准的官方名称<br>JavaScript 由 Brendan Eich 发明，它于 1995 年出现在 Netscape 中，并于 1997 年被 ECMA 采纳（一个标准协会）</p>
<hr>
<h2 id="JavaScript-用法"><a href="#JavaScript-用法" class="headerlink" title="JavaScript 用法"></a>JavaScript 用法</h2><h3 id="内部用法"><a href="#内部用法" class="headerlink" title="内部用法"></a>内部用法</h3><p>HTML 中的脚本必须位于 <code>&lt;script&gt; &lt;/script&gt;</code> 之间<br>脚本可被放置在 HTML 页面的 <code>&lt;body&gt; &lt;head&gt;</code> 部分中</p>
<h3 id="外部用法"><a href="#外部用法" class="headerlink" title="外部用法"></a>外部用法</h3><p>如需使用外部 JS 文件，请在 <code>&lt;script&gt;&lt;/script&gt;</code> 标签的 ‘src’ 属性中引入</p>
<hr>
<h2 id="JavaScript-输出"><a href="#JavaScript-输出" class="headerlink" title="JavaScript 输出"></a>JavaScript 输出</h2><p>JavaScript 没有任何打印或者输出的函数<br>JavaScript 可以通过不同的方式来输出数据：</p>
<ul>
<li>使用 <code>window.alert()</code> 弹出警告框</li>
<li>使用 <code>document.write()</code> 将内容写入 HTML 文档中</li>
<li>使用 <code>innerHTML</code> 写入到 HTML 元素</li>
<li>使用 <code>console.log()</code> 写入浏览器控制台</li>
<li>使用 <code>document.getElementById(id)</code> 来访问某个 HTML 元素，使用 ‘id’ 属性来标识 HTML 元素，并 <code>innerHTML</code> 来获取或者插入内容</li>
</ul>
<hr>
<h2 id="JavaScript-语法"><a href="#JavaScript-语法" class="headerlink" title="JavaScript 语法"></a>JavaScript 语法</h2><p>JavaScript 是一个程序语言，语法规则定义了语言结构</p>
<h3 id="JavaScript-字面量"><a href="#JavaScript-字面量" class="headerlink" title="JavaScript 字面量"></a>JavaScript 字面量</h3><p>在编程语言中，一般固定值成为字面量</p>
<ul>
<li>数字 <code>Number</code> 可以是整数或者小数或是科学计数<br>  <code>123 3.14</code></li>
<li>字符串 <code>String</code> 可以使用单引号或双引号<br>  <code>&quot;jack&quot; &#39;jack&#39;</code></li>
<li>数组 <code>Array</code> 定义一个数组<br>  <code>[20,3004,32,230]</code></li>
<li>对象 <code>Object</code> 定义一个对象<br>  <code>{firstName:&quot;jack&quot;,lastName:&quot;doe&quot;,age:40}</code></li>
<li>函数 <code>Function</code> 定义一个函数<br>  <code>function myFunction(a,b){return a+b}</code></li>
</ul>
<h3 id="JavaScript-变量"><a href="#JavaScript-变量" class="headerlink" title="JavaScript 变量"></a>JavaScript 变量</h3><p>编程语言中，变量用于存储数据值<br>JavaScript 使用关键字 <code>var</code> 来定义变量，使用 <code>=</code> 来为变量赋值</p>
<pre><code class="JavaScript">var x, length
x = 5
length = 6
</code></pre>
<p>变量可以通过变量名访问，通常可变，字面量是一个恒定的值<br>变量是一个名称，字面量是一个值</p>
<h3 id="JavaScript-操作符"><a href="#JavaScript-操作符" class="headerlink" title="JavaScript 操作符"></a>JavaScript 操作符</h3><p>JavaScript 使用算术运算符来计算值</p>
<pre><code class="JavaScript">(5+6)*10
</code></pre>
<p>JavaScript 使用赋值运算符给变量赋值</p>
<pre><code class="JavaScript">x = 5
y = 6
z = (x+y)*10
</code></pre>
<p>JavaScript 语言有多种类型运算符：</p>
<ul>
<li>赋值，算术和位运算符<br>  <code>= + - * /</code></li>
<li>条件，比较和逻辑运算符<br>  <code>== != &lt; &gt;</code></li>
</ul>
<h3 id="JavaScript-语句"><a href="#JavaScript-语句" class="headerlink" title="JavaScript 语句"></a>JavaScript 语句</h3><p>在 HTML 中，JavaScript 语句向浏览器发出的命令用分号分隔</p>
<pre><code class="JavaScript">x = 5 + 6
y = x * 5
</code></pre>
<h3 id="JavaScript-关键字"><a href="#JavaScript-关键字" class="headerlink" title="JavaScript 关键字"></a>JavaScript 关键字</h3><table>
<thead>
<tr>
<th style="text-align:center">abstract</th>
<th style="text-align:center">else</th>
<th style="text-align:center">instanceof</th>
<th style="text-align:center">super</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">enum</td>
<td style="text-align:center">int</td>
<td style="text-align:center">switch</td>
</tr>
<tr>
<td style="text-align:center">break</td>
<td style="text-align:center">export</td>
<td style="text-align:center">interface</td>
<td style="text-align:center">synchronized</td>
</tr>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">extends</td>
<td style="text-align:center">let</td>
<td style="text-align:center">this</td>
</tr>
<tr>
<td style="text-align:center">case</td>
<td style="text-align:center">false</td>
<td style="text-align:center">long</td>
<td style="text-align:center">throw</td>
</tr>
<tr>
<td style="text-align:center">catch</td>
<td style="text-align:center">final</td>
<td style="text-align:center">native</td>
<td style="text-align:center">throws</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">finally</td>
<td style="text-align:center">new</td>
<td style="text-align:center">transient</td>
</tr>
<tr>
<td style="text-align:center">class</td>
<td style="text-align:center">float</td>
<td style="text-align:center">null</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center">const</td>
<td style="text-align:center">for</td>
<td style="text-align:center">package</td>
<td style="text-align:center">try</td>
</tr>
<tr>
<td style="text-align:center">continue</td>
<td style="text-align:center">function</td>
<td style="text-align:center">private</td>
<td style="text-align:center">typeof</td>
</tr>
<tr>
<td style="text-align:center">debugger</td>
<td style="text-align:center">goto</td>
<td style="text-align:center">protected</td>
<td style="text-align:center">var</td>
</tr>
<tr>
<td style="text-align:center">default</td>
<td style="text-align:center">if</td>
<td style="text-align:center">public</td>
<td style="text-align:center">void</td>
</tr>
<tr>
<td style="text-align:center">delete</td>
<td style="text-align:center">implements</td>
<td style="text-align:center">return</td>
<td style="text-align:center">volatile</td>
</tr>
<tr>
<td style="text-align:center">do</td>
<td style="text-align:center">import</td>
<td style="text-align:center">short</td>
<td style="text-align:center">while</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">in</td>
<td style="text-align:center">static</td>
<td style="text-align:center">with</td>
</tr>
</tbody>
</table>
<h3 id="JavaScript-注释"><a href="#JavaScript-注释" class="headerlink" title="JavaScript 注释"></a>JavaScript 注释</h3><p>双斜杠 <code>//</code> 后的内容会被浏览器忽略</p>
<h3 id="JavaScript-数据类型"><a href="#JavaScript-数据类型" class="headerlink" title="JavaScript 数据类型"></a>JavaScript 数据类型</h3><pre><code class="JavaScript">var length = 16;                                  // Number 通过数字字面量赋值
var points = x * 10;                              // Number 通过表达式字面量赋值
var lastName = &quot;Johnson&quot;;                         // String 通过字符串字面量赋值
var cars = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;];              // Array  通过数组字面量赋值
var person = {firstName:&quot;John&quot;, lastName:&quot;Doe&quot;};  // Object 通过对象字面量赋值
</code></pre>
<h3 id="JavaScript-字符集"><a href="#JavaScript-字符集" class="headerlink" title="JavaScript 字符集"></a>JavaScript 字符集</h3><p>JavaScript 使用 Unicode 字符集</p>
<hr>
<h2 id="JavaScript-语句-1"><a href="#JavaScript-语句-1" class="headerlink" title="JavaScript 语句"></a>JavaScript 语句</h2><p>JavaScript 语句向浏览器发出命令告诉浏览器该做什么<br>下面的 JavaScript 语句向 id=”demo” 的 HTML 元素输出文本 “你好 Dolly” ：</p>
<pre><code class="JavaScript">document.getElementById(&quot;demo&quot;).innerHTML = &quot;你好 Dolly&quot;
</code></pre>
<h3 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h3><p>分号用于分隔 JavaScript 语句</p>
<pre><code class="JavaScript">a = 5;
b = 6;
c = a + b;
// 或
a = 5; b = 6; c = a + b;
</code></pre>
<h3 id="JavaScript-代码"><a href="#JavaScript-代码" class="headerlink" title="JavaScript 代码"></a>JavaScript 代码</h3><p>JavaScript 代码是 JavaScript 语句的序列<br>浏览器按照便携顺序依次执行每条语句</p>
<pre><code class="JavaScript">document.getElementById(&quot;demo&quot;).innerHTML = &quot;hello Dolly&quot;
document.getElementById(&quot;myDiv&quot;).innerHTML = &quot;how are you&quot;
</code></pre>
<h3 id="JavaScript-代码块"><a href="#JavaScript-代码块" class="headerlink" title="JavaScript 代码块"></a>JavaScript 代码块</h3><p>JavaScript 可以分批地组合起来<br>代码块以左花括号开始，以右花括号结束<br>代码块的作用是一并地执行语句序列</p>
<pre><code class="JavaScript">function myFunciton(){document.getElementById(&quot;demo&quot;).innerHTML = &quot;hello Dolly&quot;
    document.getElementById(&quot;myDiv&quot;).innerHTML = &quot;how are you&quot;
}
</code></pre>
<h3 id="JavaScript-语句标识符"><a href="#JavaScript-语句标识符" class="headerlink" title="JavaScript 语句标识符"></a>JavaScript 语句标识符</h3><p>JavaScript 语句通常以一个 语句标识符 为开始，并执行该语句<br>语句标识符是保留关键字不能作为变量名使用</p>
<table>
<thead>
<tr>
<th style="text-align:center">语句</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">break</td>
<td style="text-align:center">用于跳出循环</td>
</tr>
<tr>
<td style="text-align:center">catch</td>
<td style="text-align:center">语句块，在 try 语句块执行出错时执行 catch 语句块</td>
</tr>
<tr>
<td style="text-align:center">continue</td>
<td style="text-align:center">跳出循环中的一个迭代</td>
</tr>
<tr>
<td style="text-align:center">do…while</td>
<td style="text-align:center">执行一个语句块，在条件语句为 true 时继续执行该语句块</td>
</tr>
<tr>
<td style="text-align:center">for</td>
<td style="text-align:center">在条件语句为 true 时，可以将代码块执行指定的次数</td>
</tr>
<tr>
<td style="text-align:center">for…in</td>
<td style="text-align:center">用于遍历数组或者对象的属性（对数组或者对象的属性进行循环操作）</td>
</tr>
<tr>
<td style="text-align:center">function</td>
<td style="text-align:center">定义一个函数</td>
</tr>
<tr>
<td style="text-align:center">if…else</td>
<td style="text-align:center">用于基于不同的条件来执行不同的动作</td>
</tr>
<tr>
<td style="text-align:center">return</td>
<td style="text-align:center">退出函数</td>
</tr>
<tr>
<td style="text-align:center">switch</td>
<td style="text-align:center">用于基于不同的条件来执行不同的动作</td>
</tr>
<tr>
<td style="text-align:center">throw</td>
<td style="text-align:center">抛出（生成）错误</td>
</tr>
<tr>
<td style="text-align:center">try</td>
<td style="text-align:center">实现错误处理，与 catch 一同使用</td>
</tr>
<tr>
<td style="text-align:center">var</td>
<td style="text-align:center">声明一个变量</td>
</tr>
<tr>
<td style="text-align:center">while</td>
<td style="text-align:center">当条件语句为 true 时，执行语句块</td>
</tr>
</tbody>
</table>
<h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><p>JavaScript 会忽略多余的空格，可以向脚本添加空格，来提高其可读性</p>
<pre><code class="JavaScript">var person=&quot;Jack&quot;
var person = &quot;Jack&quot;
</code></pre>
<h3 id="对代码进行折行"><a href="#对代码进行折行" class="headerlink" title="对代码进行折行"></a>对代码进行折行</h3><p>可以在文本字符串中使用反斜杠对代码进行换行</p>
<pre><code class="JavaScript">document.write(&quot;你好 \n 世界!&quot;)
</code></pre>
<hr>
<h2 id="JavaScript-注释-1"><a href="#JavaScript-注释-1" class="headerlink" title="JavaScript 注释"></a>JavaScript 注释</h2><p>JavaScript 注释可用于提高代码可读性<br>JavaScript 不会执行注释</p>
<h3 id="JavaScript-单行注释"><a href="#JavaScript-单行注释" class="headerlink" title="JavaScript 单行注释"></a>JavaScript 单行注释</h3><p>单行注释以 <code>//</code> 开头</p>
<pre><code class="JavaScript">// 输出标题
document.getElementById(&quot;myH1&quot;).innerHTML = &quot;欢迎来到我的主页&quot;
// 输出段落
document.getElementById(&quot;myP&quot;).innerHTML = &quot;这是我的第一个段落&quot;
</code></pre>
<h3 id="JavaScript-多行注释"><a href="#JavaScript-多行注释" class="headerlink" title="JavaScript 多行注释"></a>JavaScript 多行注释</h3><p>多行注释以 <code>/*</code> 开始，以 <code>*/</code> 结尾</p>
<pre><code class="JavaScript">/*
下面的代码会输出
一个标题和
一个段落
*/
document.getElementById(&quot;myH1&quot;).innerHTML = &quot;欢迎来到我的主页&quot;
document.getElementById(&quot;myP&quot;).innerHTML = &quot;这是我的第一个段落&quot;
</code></pre>
<hr>
<p>##JavaScript 变量<br>变量是用于存储信息的“容器”</p>
<pre><code class="JavaScript">var x = 5
var y = 6
var z = x+y
</code></pre>
<p>变量可以使用短名称（x，y），也可以使用描述性更好的名称（age，sum）</p>
<ul>
<li>变量必须以字母开头</li>
<li>变量也能以 $ 和 _ 符号开头</li>
<li>变量名称对大小写敏感<br>JavaScript 语句和 JavaScript 变量都对大小写敏感</li>
</ul>
<h3 id="JavaScript-数据类型-1"><a href="#JavaScript-数据类型-1" class="headerlink" title="JavaScript 数据类型"></a>JavaScript 数据类型</h3><p>JavaScript 变量还能保存其他数据类型，比如文本值（name=”bill”)<br>在 JavaScript 中，类似“bill”这样一条文本被称为字符串<br>向变量分配文本值时，应该用双引号或单引号包围这个值<br>赋值为数值时，不要使用引号，不然会被当文本来处理</p>
<pre><code class="JavaScript">var pi = 3.14
var person = &quot;john doe&quot;
var answer = &quot;yes I am&quot;
</code></pre>
<h3 id="声明（创建）JavaScript-变量"><a href="#声明（创建）JavaScript-变量" class="headerlink" title="声明（创建）JavaScript 变量"></a>声明（创建）JavaScript 变量</h3><p>在 JavaScript 中创建变量通常称为“声明”变量<br>使用 <code>var</code> 关键词来声明变量</p>
<pre><code class="JavaScript">var carname
</code></pre>
<p>变量声明之后，该变量是空的（没有值）<br>如需向变量赋值，则需要使用等号</p>
<pre><code class="JavaScript">carname = &quot;volvo&quot;
</code></pre>
<p>不过，也可以在声明变量时就赋值</p>
<pre><code class="JavaScript">var carname = &quot;volvo&quot;
</code></pre>
<h3 id="一条语句，多个变量"><a href="#一条语句，多个变量" class="headerlink" title="一条语句，多个变量"></a>一条语句，多个变量</h3><p>可以在一条语句中声明多个变量，以 <code>var</code> 开头，并用逗号分隔</p>
<pre><code class="JavaScript">var name = &quot;Doe&quot;, age = &quot;30&quot;, job = &quot;teacher&quot;
// 也可以横跨多行
var name = &quot;Doe&quot;,
age = &quot;30&quot;,
job = &quot;teacher&quot;
</code></pre>
<p>一条语句声明的多个不可以赋同一个值</p>
<pre><code class="JavaScript">var x,y,z=1
//x,y 为 undefined，z 为 1
</code></pre>
<h3 id="Value-undefined"><a href="#Value-undefined" class="headerlink" title="Value=undefined"></a>Value=undefined</h3><p>未使用值来声明的变量，其值为 undefined</p>
<h3 id="重新声明-JavaScript-变量"><a href="#重新声明-JavaScript-变量" class="headerlink" title="重新声明 JavaScript 变量"></a>重新声明 JavaScript 变量</h3><p>如果重新声明 JavaScript 变量，该变量的值不会丢失</p>
<pre><code class="JavaScript">var x = &quot;xxx&quot;
var x
//x 的值依然为“xxx”
</code></pre>
<hr>
<h2 id="JavaScript-数据类型-2"><a href="#JavaScript-数据类型-2" class="headerlink" title="JavaScript 数据类型"></a>JavaScript 数据类型</h2><p>值类型（基本类型）：</p>
<ul>
<li>字符串 String</li>
<li>数字 Number</li>
<li>布尔 Boolean</li>
<li>空 Null</li>
<li>未定义 undefined</li>
<li>唯一值 Symbol</li>
</ul>
<p>引入数据类型：</p>
<ul>
<li>对象 Object</li>
<li>数组 Array</li>
<li>函数 Function</li>
</ul>
<h3 id="JavaScript-拥有动态类型"><a href="#JavaScript-拥有动态类型" class="headerlink" title="JavaScript 拥有动态类型"></a>JavaScript 拥有动态类型</h3><p>意味着相同的变量可用作不同的类型</p>
<pre><code class="JavaScript">var x   //x 为 undefined
var x = 5   //x 为数字
var x = &#39;Jk&quot;    //x 为字符串
</code></pre>
<h3 id="JavaScript-字符串-String"><a href="#JavaScript-字符串-String" class="headerlink" title="JavaScript 字符串 String"></a>JavaScript 字符串 String</h3><p>字符串是存储字符（如“Jack”）的变量<br>字符串可以是引号内的任意文本，单引号或双引号</p>
<pre><code class="JavaScript">var name = &quot;Jack 80D&quot;
var add = &quot;shanxi&#39;linfen&#39;&quot;
</code></pre>
<h3 id="JavaScript-数字-Number"><a href="#JavaScript-数字-Number" class="headerlink" title="JavaScript 数字 Number"></a>JavaScript 数字 Number</h3><p>JavaScript 只有一种数字类型，可以带小数点或是科学计数法</p>
<pre><code class="JavaScript">var x = 123
var y = 3.14
var z = 123e5
</code></pre>
<h3 id="JavaScript-布尔-Boolean"><a href="#JavaScript-布尔-Boolean" class="headerlink" title="JavaScript 布尔 Boolean"></a>JavaScript 布尔 Boolean</h3><p>布尔（逻辑）只有两个值，<code>true/false</code></p>
<h3 id="JavaScript-数组-Array"><a href="#JavaScript-数组-Array" class="headerlink" title="JavaScript 数组 Array"></a>JavaScript 数组 Array</h3><p>数组的下标是基于零的，所以第一个项目是 [0]，第二个是 [1]，以此类推</p>
<pre><code class="JavaScript">var x = new Array()x[0] = &quot;y&quot;
x[1] = &quot;h&quot;
x[2] = &quot;h&quot;
//or
var x = new Array(&quot;y&quot;,&quot;h&quot;,&quot;h&quot;)
//or
var x = [&quot;y&quot;,&quot;h&quot;,&quot;h&quot;]
</code></pre>
<h3 id="JavaScript-对象-Object"><a href="#JavaScript-对象-Object" class="headerlink" title="JavaScript 对象 Object"></a>JavaScript 对象 Object</h3><p>对象由花括号分隔，在括号内部，对象的属性以名称和值的形式 <code>name：value</code> 来定义，属性由逗号分隔</p>
<pre><code class="JavaScript">var person = {
    name: &quot;Yhh&quot;,
    age: &quot;18&quot;,
    id: 7281
}
// 两种寻址方式
name = person.name
name = person[&quot;name&quot;]
</code></pre>
<h3 id="undefined-和-Null"><a href="#undefined-和-Null" class="headerlink" title="undefined 和 Null"></a>undefined 和 Null</h3><p>undefined 表示变量不含有值<br>可以通过将变量的值设为 null 来清空变量</p>
<h3 id="声明变量类型"><a href="#声明变量类型" class="headerlink" title="声明变量类型"></a>声明变量类型</h3><p>可以使用关键词 <code>new</code> 来声明类型</p>
<pre><code class="JavaScript">var name = new String
var x = new Number
var y = new Boolean
var z = new Array
var i = new Object
</code></pre>
<p>JavaScript 变量均为对象，当声明一个变量时，就创建了一个新的对象</p>
<hr>
<h2 id="JavaScript-对象"><a href="#JavaScript-对象" class="headerlink" title="JavaScript 对象"></a>JavaScript 对象</h2><p>JavaScript 对象是拥有属性和方法的数据</p>
<h3 id="真是生活中的对象，属性，方法"><a href="#真是生活中的对象，属性，方法" class="headerlink" title="真是生活中的对象，属性，方法"></a>真是生活中的对象，属性，方法</h3><p>真实生活中，一辆汽车是一个对象<br>对象有它的属性，如重量颜色，方法有启动停止</p>
<table>
<thead>
<tr>
<th style="text-align:center">对象</th>
<th style="text-align:center">属性</th>
<th style="text-align:center">方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">car</td>
<td style="text-align:center">car.name = fiat<br>car.model = 500<br>car.weight = 800kg<br></td>
<td style="text-align:center">car.start()<br>car.brake()<br>car.stop()</td>
</tr>
</tbody>
</table>
<h3 id="JavaScript-对象-1"><a href="#JavaScript-对象-1" class="headerlink" title="JavaScript 对象"></a>JavaScript 对象</h3><p>JavaScript 对象是变量的容器</p>
<pre><code class="JavaScript">var car = &quot;fiat&quot;
//or
var car = {
    type: &quot;fiat&quot;,
    model: 500,
    color: &quot;white&quot;
}
</code></pre>
<h3 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h3><p>JavaScript 对象是变量的容器 ===JavaScript 对象是键值对的容器<br>键值对通常写法为 <code>name：value</code>（键 冒号 值）<br>键值对在 JavaScript 对象称为 对象属性<br>对象键值对的写法类似于：</p>
<ul>
<li>PHP 中的关联数组</li>
<li>Python 中的字典</li>
<li>C 语言中的哈希表</li>
<li>Java 中的哈希映射</li>
<li>Ruby 和 Perl 中的哈希表</li>
</ul>
<h3 id="访问对象属性"><a href="#访问对象属性" class="headerlink" title="访问对象属性"></a>访问对象属性</h3><p>两种方式</p>
<pre><code class="JavaScript">car.type
//or
car[&quot;type&quot;]
</code></pre>
<h3 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h3><p>对象的方法定义了一个函数，并作为对象的属性存储<br>对象方法通过添加（）调用</p>
<pre><code class="JavaScript">var person = {
    firstName: &quot;John&quot;,
    lastName: &quot;Doe&quot;,
    id: 5566,
    fullName: function (){return this.firstName + &quot; &quot; + this.lastName;}
};
person.fullName //function (){return this.firstName + &quot; &quot; + this.lastName;}
person.fullName() //John Doe
不加括号输出函数表达式
加括号输出函数执行结果
</code></pre>
<hr>
<h2 id="JavaScript-函数"><a href="#JavaScript-函数" class="headerlink" title="JavaScript 函数"></a>JavaScript 函数</h2><p>函数是由事件驱动的或者当它被调用时执行的可重复使用的代码块</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt; 测试实例 &lt;/title&gt;
    &lt;script&gt;
        function myFunction(){alert(&quot;Hello World!&quot;);
        }
    &lt;/script&gt;
&lt;/head&gt;
    &lt;button onclick=&quot;myFunction()&quot;&gt; 点我 &lt;/button&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="JavaScript-函数语法"><a href="#JavaScript-函数语法" class="headerlink" title="JavaScript 函数语法"></a>JavaScript 函数语法</h3><p>函数就是包裹在花括号内的代码块，前面使用了关键词 function</p>
<pre><code class="JavaScript">function functionName(){// 执行代码}
</code></pre>
<h3 id="调用带参数的函数"><a href="#调用带参数的函数" class="headerlink" title="调用带参数的函数"></a>调用带参数的函数</h3><p>在调用函数时，可以向其传递值，这些值被称为参数<br>可以发送任意多的参数，由逗号分隔<br>当声明函数时，把参数作为变量来声明<br>变量和参数必须以一致的顺序出现，第一个变量就是第一个被传递的参数的给定的值</p>
<pre><code class="html">&lt;p&gt; 点击这个按钮，来调用带参数的函数。&lt;/p&gt;
&lt;button onclick=&quot;myFunction(&#39;Harry Potter&#39;,&#39;Wizard&#39;)&quot;&gt; 点击这里 &lt;/button&gt;
&lt;script&gt;
    function myFunction(name,job) {alert(&quot;Welcome&quot; + name + &quot;, the&quot; + job);
    }
&lt;/script&gt;
</code></pre>
<h3 id="带有返回值的函数"><a href="#带有返回值的函数" class="headerlink" title="带有返回值的函数"></a>带有返回值的函数</h3><p>在使用 return 语句时，函数会停止执行，并返回指定的值</p>
<pre><code class="JavaScript">function myFunction() {
    var x=5;
    return x;
}
</code></pre>
<p>返回值可选</p>
<pre><code class="JavaScript">function myFunction(a,b) {if (a&gt;b) {return;}
    return a+b
}
当 a&gt;b 时，则直接退出函数，返回 undefined
当 a&lt;=b 时，则返回 a+b 的值
</code></pre>
<h3 id="局部-JavaScript-变量"><a href="#局部-JavaScript-变量" class="headerlink" title="局部 JavaScript 变量"></a>局部 JavaScript 变量</h3><p>在 JavaScript 函数内部声明的变量是局部变量，所以只能在函数内部访问，为局部作用域<br>可以在不同的函数中使用名称相同的局部变量<br>只要函数运行完毕，本地变量就会被删除</p>
<h3 id="全局-JavaScript-变量"><a href="#全局-JavaScript-变量" class="headerlink" title="全局 JavaScript 变量"></a>全局 JavaScript 变量</h3><p>在函数外声明的变量时全局变量，网页上所有的脚本和函数都可以访问</p>
<h3 id="JavaScript-变量的生存期"><a href="#JavaScript-变量的生存期" class="headerlink" title="JavaScript 变量的生存期"></a>JavaScript 变量的生存期</h3><p>JavaScript 变量的生命期从被声明开始<br>局部变量会在函数运行后删除<br>全局变量会在页面关闭后删除</p>
<h3 id="向未声明的-JavaScript-变量分配值"><a href="#向未声明的-JavaScript-变量分配值" class="headerlink" title="向未声明的 JavaScript 变量分配值"></a>向未声明的 JavaScript 变量分配值</h3><p>如果把值赋给尚未声明的变量，则该变量将被自动作为 window 的一个属性<br>非严格模式下给未声明的变量赋值创建的全局变量，是全局对象的可配置属性，可以删除</p>
<pre><code class="JavaScript">var x = 1; // 不可配置全局属性
y = 2; // 没有使用 var 声明，可配置全局属性

console.log(this.x); // 1
console.log(window.x); // 1

delete x; // false 无法删除
console.log(x); //1

delete y; //true 删除
console.log(y); // 已经删除 报错变量未定义
</code></pre>
<hr>
<h2 id="JavaScript-作用域"><a href="#JavaScript-作用域" class="headerlink" title="JavaScript 作用域"></a>JavaScript 作用域</h2><p>作用域是可访问变量的集合</p>
<h3 id="JavaScript-作用域-1"><a href="#JavaScript-作用域-1" class="headerlink" title="JavaScript 作用域"></a>JavaScript 作用域</h3><p>在 JavaScript 中，对象和函数都是变量<br>在 JavaScript 中，作用域为可访问变量，对象，函数的集合<br>JavaScript 函数作用域：作用域在函数内修改</p>
<h3 id="JavaScript-局部变量"><a href="#JavaScript-局部变量" class="headerlink" title="JavaScript 局部变量"></a>JavaScript 局部变量</h3><p>变量在函数内声明，为局部变量<br>局部变量：只能在函数内部访问</p>
<pre><code class="JavaScript">// 此处不能调用 carName 变量
function myFunction() {
    var carName = &quot;Volvo&quot;;
    // 函数内可调用 carName 变量
}
</code></pre>
<p>因为局部变量只作用于函数内，所以不同的函数可以使用相同名称的变量<br>局部变量在函数开始执行时创建，函数执行完后局部变量会自动销毁</p>
<h3 id="JavaScript-全局变量"><a href="#JavaScript-全局变量" class="headerlink" title="JavaScript 全局变量"></a>JavaScript 全局变量</h3><p>变量在函数外定义，为全局变量<br>全局作用域：网页中的所有脚本和函数均可使用</p>
<pre><code class="JavaScript">var carName = &quot;Volvo&quot;;
// 此处可调用 carName 变量
function myFunction(){// 函数内可调用 carName 变量}
</code></pre>
<p>如果变量在函数内没有声明（没有使用 var 关键字），该变量为全局变量</p>
<pre><code class="JavaScript">// 此处可调用 carName 变量
function myFunction() {
    carName = &quot;Volvo&quot;;
    // 此处可调用 carName 变量
}
</code></pre>
<h3 id="JavaScript-变量生命周期"><a href="#JavaScript-变量生命周期" class="headerlink" title="JavaScript 变量生命周期"></a>JavaScript 变量生命周期</h3><p>JavaScript 变量生命周期在它声明时初始化<br>局部变量在函数执行完毕后销毁<br>全局变量在页面关闭后销毁</p>
<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>函数参数只在函数内起作用为局部变量</p>
<h3 id="HTML-中的全局变量"><a href="#HTML-中的全局变量" class="headerlink" title="HTML 中的全局变量"></a>HTML 中的全局变量</h3><p>在 HTML 中，全局变量是 window 对象：所有数据变量都属于 window 对象</p>
<pre><code class="JavaScript">// 此处可使用 window.carName
function myFunction(){carName = &quot;Volvo&quot;;}
</code></pre>
<p><strong> 全局变量，或者函数，可以覆盖 window 对象的变量或者函数<br>局部变量，包括 window 对象可以覆盖全局变量和函数 </strong></p>
<hr>
<h2 id="JavaScript-事件"><a href="#JavaScript-事件" class="headerlink" title="JavaScript 事件"></a>JavaScript 事件</h2><p>HTML 事件是发生在 HTML 元素上的事情<br>当在 HTML 页面中使用 JavaScript 时，JavaScript 可以触发这些事件</p>
<h3 id="HTML-事件"><a href="#HTML-事件" class="headerlink" title="HTML 事件"></a>HTML 事件</h3><p>HTML 事件可以是浏览器行为，也可以是用户行为</p>
<ul>
<li>HTML 页面加载完成</li>
<li>HTML input 字段改变</li>
<li>HTML 按钮被点击</li>
</ul>
<h3 id="常见的-HTML-事件"><a href="#常见的-HTML-事件" class="headerlink" title="常见的 HTML 事件"></a>常见的 HTML 事件</h3><table>
<thead>
<tr>
<th style="text-align:center">事件</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">onchange</td>
<td style="text-align:center">HTML 元素改变</td>
</tr>
<tr>
<td style="text-align:center">onclick</td>
<td style="text-align:center">用户点击 HTML 元素</td>
</tr>
<tr>
<td style="text-align:center">onmouseover</td>
<td style="text-align:center">移动鼠标</td>
</tr>
<tr>
<td style="text-align:center">onmouseout</td>
<td style="text-align:center">移开鼠标</td>
</tr>
<tr>
<td style="text-align:center">onkeydown</td>
<td style="text-align:center">按下键盘按键</td>
</tr>
<tr>
<td style="text-align:center">onload</td>
<td style="text-align:center">浏览器已加载完成</td>
</tr>
</tbody>
</table>
<h3 id="JavaScript-可以做什么"><a href="#JavaScript-可以做什么" class="headerlink" title="JavaScript 可以做什么"></a>JavaScript 可以做什么</h3><p>事件可以用于处理表单验证，用户输入，用户行为及浏览器动作:</p>
<ul>
<li>页面加载时触发事件</li>
<li>页面关闭时触发事件</li>
<li>用户点击按钮执行动作</li>
<li>验证用户输入内容的合法性</li>
</ul>
<p>可以使用多种方法来执行 JavaScript 事件代码：</p>
<ul>
<li>HTML 事件属性可以直接执行 JavaScript 代码</li>
<li>HTML 事件属性可以调用 JavaScript 函数</li>
<li>可以为 HTML 元素指定自己的事件处理程序</li>
<li>可以阻止事件的发生</li>
</ul>
<hr>
<h2 id="JavaScript-字符串"><a href="#JavaScript-字符串" class="headerlink" title="JavaScript 字符串"></a>JavaScript 字符串</h2><p>JavaScript 字符串用于存储和处理文本</p>
<h3 id="JavaScript-字符串-1"><a href="#JavaScript-字符串-1" class="headerlink" title="JavaScript 字符串"></a>JavaScript 字符串</h3><p>可以存储一系列字符，如“yhh”<br>可以是插入到引号中的任何字符，单引号或双引号<br>可以使用索引位置来访问字符串中的每个字符<br>字符串的索引从 0 开始，第一个字符索引值为 [0]，第二个是 [1]，以此类推<br>可以在字符串中添加转义字符来使用引号</p>
<pre><code class="JavaScript">var name = &quot;yyh7281&quot;
var name = &#39;yyh7281&#39;
name[3] //7
name[0] //y
var x = &quot;he is called \&quot;Jack\&quot;&quot;
</code></pre>
<h3 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h3><p>可以使用内置属性 <code>length</code> 来计算字符串的长度</p>
<pre><code class="JavaScript">var text = &quot;dhxahjsocnbdhehowcwncnhi&quot;
text.length //15
</code></pre>
<h3 id="特殊字符（转义字符）"><a href="#特殊字符（转义字符）" class="headerlink" title="特殊字符（转义字符）"></a>特殊字符（转义字符）</h3><table>
<thead>
<tr>
<th style="text-align:center">代码</th>
<th style="text-align:center">输出</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">‘</td>
<td style="text-align:center">单引号</td>
</tr>
<tr>
<td style="text-align:center">“</td>
<td style="text-align:center">双引号</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td style="text-align:center">反斜杠</td>
</tr>
<tr>
<td style="text-align:center">\n</td>
<td style="text-align:center">换行</td>
</tr>
<tr>
<td style="text-align:center">\r</td>
<td style="text-align:center">回车</td>
</tr>
<tr>
<td style="text-align:center">\t</td>
<td style="text-align:center">tab（制表符）</td>
</tr>
<tr>
<td style="text-align:center">\b</td>
<td style="text-align:center">退格符</td>
</tr>
<tr>
<td style="text-align:center">\f</td>
<td style="text-align:center">换页符</td>
</tr>
</tbody>
</table>
<h3 id="字符串可以是对象"><a href="#字符串可以是对象" class="headerlink" title="字符串可以是对象"></a>字符串可以是对象</h3><p>通常，JavaScript 字符串是原始值，可以使用字符创建<br>但也可以使用 new 关键字将字符串定义为一个对象</p>
<pre><code class="JavaScript">var x = &quot;yyh&quot;
var y = new String(&quot;hhhy&quot;)
typeof x //String
typeof y //Object
x === y //false 因为 x 为字符串，y 为对象
</code></pre>
<h3 id="字符串属性和方法"><a href="#字符串属性和方法" class="headerlink" title="字符串属性和方法"></a>字符串属性和方法</h3><p>原始值字符串，如 “John”, 没有属性和方法 (因为他们不是对象)<br>原始值可以使用 JavaScript 的属性和方法，因为 JavaScript 在执行方法和属性时可以把原始值当作对象</p>
<h3 id="字符串属性"><a href="#字符串属性" class="headerlink" title="字符串属性"></a>字符串属性</h3><table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">constructor</td>
<td style="text-align:center">返回创建字符串属性的函数</td>
</tr>
<tr>
<td style="text-align:center">length</td>
<td style="text-align:center">返回字符串的长度</td>
</tr>
<tr>
<td style="text-align:center">prototype</td>
<td style="text-align:center">允许向对象添加属性和方法</td>
</tr>
</tbody>
</table>
<h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">charAt()</td>
<td style="text-align:center">返回指定索引位置的字符</td>
</tr>
<tr>
<td style="text-align:center">charCodeAt()</td>
<td style="text-align:center">返回指定索引位置字符的 Unicode 值</td>
</tr>
<tr>
<td style="text-align:center">concat()</td>
<td style="text-align:center">连接两个或多个字符串，返回连接后的字符串</td>
</tr>
<tr>
<td style="text-align:center">fromCharCode()</td>
<td style="text-align:center">将 Unicode 转换为字符串</td>
</tr>
<tr>
<td style="text-align:center">indexOf()</td>
<td style="text-align:center">返回字符串中检索指定字符第一次出现的位置</td>
</tr>
<tr>
<td style="text-align:center">lastIndexOf()</td>
<td style="text-align:center">返回字符串中检索指定字符最后一次出现的位置</td>
</tr>
<tr>
<td style="text-align:center">localeCompare()</td>
<td style="text-align:center">用本地特定的顺序来比较两个字符串</td>
</tr>
<tr>
<td style="text-align:center">match()</td>
<td style="text-align:center">找到一个或多个正则表达式的匹配</td>
</tr>
<tr>
<td style="text-align:center">replace()</td>
<td style="text-align:center">替换与正则表达式匹配的子串</td>
</tr>
<tr>
<td style="text-align:center">search()</td>
<td style="text-align:center">检索与正则表达式相匹配的值</td>
</tr>
<tr>
<td style="text-align:center">slice()</td>
<td style="text-align:center">提取字符串的片段，并在新的字符串中返回被提取的部分</td>
</tr>
<tr>
<td style="text-align:center">split()</td>
<td style="text-align:center">把字符串分割为子字符串数组</td>
</tr>
<tr>
<td style="text-align:center">substr()</td>
<td style="text-align:center">从起始索引号提取字符串中指定数目的字符</td>
</tr>
<tr>
<td style="text-align:center">substring()</td>
<td style="text-align:center">提取字符串中两个指定的索引号之间的字符</td>
</tr>
<tr>
<td style="text-align:center">toLowerCase()</td>
<td style="text-align:center">把字符串转换为小写</td>
</tr>
<tr>
<td style="text-align:center">toString()</td>
<td style="text-align:center">返回字符串对象值</td>
</tr>
<tr>
<td style="text-align:center">toUpperCase()</td>
<td style="text-align:center">把字符串转换为大写</td>
</tr>
<tr>
<td style="text-align:center">trim()</td>
<td style="text-align:center">移除字符串首尾空白</td>
</tr>
<tr>
<td style="text-align:center">valueOf()</td>
<td style="text-align:center">返回某个字符串对象的原始值</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="JavaScript-运算符"><a href="#JavaScript-运算符" class="headerlink" title="JavaScript 运算符"></a>JavaScript 运算符</h2><p>运算符 = 用于给 JavaScript 变量赋值<br>算术运算符 + 用于把值加起来</p>
<pre><code class="JavaScript">x = 3
y = 5
z = x+y
z //8
</code></pre>
<h3 id="JavaScript-算术运算符"><a href="#JavaScript-算术运算符" class="headerlink" title="JavaScript 算术运算符"></a>JavaScript 算术运算符</h3><table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">例子（y=5）</th>
<th style="text-align:center">x 运算结果</th>
<th style="text-align:center">y 运算结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">加法</td>
<td style="text-align:center">x=y+2</td>
<td style="text-align:center">7</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">减法</td>
<td style="text-align:center">x=y-2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">乘法</td>
<td style="text-align:center">x=y*2</td>
<td style="text-align:center">10</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">/</td>
<td style="text-align:center">除法</td>
<td style="text-align:center">x=y/5</td>
<td style="text-align:center">1</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:center">取模（余数）</td>
<td style="text-align:center">x=y%2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">++</td>
<td style="text-align:center">自增</td>
<td style="text-align:center">x=++y<br>x=y++</td>
<td style="text-align:center">6<br>5</td>
<td style="text-align:center">6<br>6</td>
</tr>
<tr>
<td style="text-align:center">–</td>
<td style="text-align:center">自减</td>
<td style="text-align:center">x=–y<br>x=y–</td>
<td style="text-align:center">4<br>5</td>
<td style="text-align:center">4<br>4</td>
</tr>
</tbody>
</table>
<h3 id="JavaScript-赋值运算符"><a href="#JavaScript-赋值运算符" class="headerlink" title="JavaScript 赋值运算符"></a>JavaScript 赋值运算符</h3><p><code>var x = 10 y = 5</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">例子</th>
<th style="text-align:center">等同于</th>
<th style="text-align:center">运算结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">=</td>
<td style="text-align:center">x=y</td>
<td style="text-align:center"></td>
<td style="text-align:center">x=5</td>
</tr>
<tr>
<td style="text-align:center">+=</td>
<td style="text-align:center">x+=y</td>
<td style="text-align:center">x=x+y</td>
<td style="text-align:center">x=15</td>
</tr>
<tr>
<td style="text-align:center">-=</td>
<td style="text-align:center">x-=y</td>
<td style="text-align:center">x=x-y</td>
<td style="text-align:center">x=5</td>
</tr>
<tr>
<td style="text-align:center">*=</td>
<td style="text-align:center">x*=y</td>
<td style="text-align:center">x=x*y</td>
<td style="text-align:center">x=50</td>
</tr>
<tr>
<td style="text-align:center">/=</td>
<td style="text-align:center">x/=y</td>
<td style="text-align:center">x=x/y</td>
<td style="text-align:center">x=2</td>
</tr>
<tr>
<td style="text-align:center">%=</td>
<td style="text-align:center">x%=y</td>
<td style="text-align:center">x=x%y</td>
<td style="text-align:center">x=0</td>
</tr>
</tbody>
</table>
<h3 id="用于字符串的-运算符"><a href="#用于字符串的-运算符" class="headerlink" title="用于字符串的 + 运算符"></a>用于字符串的 + 运算符</h3><ul>
<li>运算符永雨把文本值或字符串变量加起来（连接起来）</li>
</ul>
<pre><code class="JavaScript">text1 = &quot;hello&quot;
text2 = &quot;world&quot;
text3 = text1+text2 //&quot;helloworld&quot;
text4 = text1+&quot;&quot;+text2 //&quot;hello world&quot;
</code></pre>
<h3 id="对字符串和数字进行加法运算"><a href="#对字符串和数字进行加法运算" class="headerlink" title="对字符串和数字进行加法运算"></a>对字符串和数字进行加法运算</h3><p>两个数字相加，返回相加的和，数字与字符串相加，则返回字符串</p>
<pre><code class="JavaScript">x = 5+5 //10
y = &quot;3&quot;+5 //&quot;35&quot;
z = &quot;hello&quot;+5 //&quot;hello5&quot;
</code></pre>
<hr>
<h2 id="JavaScript-比较和逻辑运算符"><a href="#JavaScript-比较和逻辑运算符" class="headerlink" title="JavaScript 比较和逻辑运算符"></a>JavaScript 比较和逻辑运算符</h2><p>比较和逻辑运算符用于测试 true 或者 false</p>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>比较运算符在逻辑语句中使用，以测定变量或值是否相等<br><code>var x = 5</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">比较</th>
<th style="text-align:center">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">==</td>
<td style="text-align:center">等于</td>
<td style="text-align:center">x\==8<br>x==5</td>
<td style="text-align:center">false<br>true</td>
</tr>
<tr>
<td style="text-align:center">===</td>
<td style="text-align:center">绝对等于（值和类型均相等）</td>
<td style="text-align:center">x=\==“5”<br>x\===5</td>
<td style="text-align:center">false<br>true</td>
</tr>
<tr>
<td style="text-align:center">!=</td>
<td style="text-align:center">不等于</td>
<td style="text-align:center">x!=8</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center">!==</td>
<td style="text-align:center">不绝对等于（值和类型有一个或两个不相等）</td>
<td style="text-align:center">x!\==“5”<br>x!==5</td>
<td style="text-align:center">true<br>false</td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">大于</td>
<td style="text-align:center">x&gt;8</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">小于</td>
<td style="text-align:center">x&lt;8</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center">&gt;=</td>
<td style="text-align:center">大于等于</td>
<td style="text-align:center">x&gt;=8</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">&lt;=</td>
<td style="text-align:center">小于等于</td>
<td style="text-align:center">x&lt;=8</td>
<td style="text-align:center">true</td>
</tr>
</tbody>
</table>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符用于测定变量或值之间的逻辑<br><code>var x=6 y=3</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&amp;&amp;</td>
<td style="text-align:center">and</td>
<td style="text-align:center">(x&lt;10&amp;&amp;y&gt;1)//true</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td style="text-align:center">\</td>
<td style="text-align:center"></td>
<td>or</td>
<td>(x\==6 \</td>
<td>\</td>
<td>y==5)//true</td>
</tr>
<tr>
<td style="text-align:center">!</td>
<td style="text-align:center">not</td>
<td style="text-align:center">!(x==y)//true</td>
</tr>
</tbody>
</table>
<h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><p>JavaScript 还包含了基于某些条件对变量进行赋值的条件运算</p>
<pre><code class="JavaScript">name = (condition) ? value1 : value2 // 语法
yhh=(age&lt;18)?&quot;年龄不够&quot;:&quot;年龄已达到&quot; // 如果 age&lt;18 则赋值“年龄太小”，反之“年龄已达到”
</code></pre>
<hr>
<h2 id="JavaScript-if…else-语句"><a href="#JavaScript-if…else-语句" class="headerlink" title="JavaScript if…else 语句"></a>JavaScript if…else 语句</h2><p>条件语句用于基于不同的条件来执行不同的动作</p>
<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>在 JavaScript 中，可以使用一下条件语句：</p>
<ul>
<li>if 语句 只有当指定条件为 true 时，使用该语句来执行代码</li>
<li>if…else 语句 当条件为 true 时执行代码，当条件为 false 时执行其他代码</li>
<li>if…else if…else 使用该语句来选择多个代码块之一来执行</li>
<li>switch 语句 使用该语句来选择多个代码块之一来执行</li>
</ul>
<h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p>只有当指定条件为 true 时，该语句才会执行代码</p>
<pre><code class="JavaScript">if(condition){当条件为 true 时执行}

var x = 10
function z(){if(x&lt;20){return x}
}
z() //10 否则为 undefined
</code></pre>
<h3 id="if…else-语句"><a href="#if…else-语句" class="headerlink" title="if…else 语句"></a>if…else 语句</h3><p>使用 if…else 语句在条件为 true 时执行代码，在条件为 false 时执行其他代码</p>
<pre><code class="JavaScript">if (condition) {当条件为 true 时执行的代码}
else {当条件不为 true 时执行的代码}

var x = 10
function z(){if(x&lt;5){return x}else{return x+1}
}
z() //11
</code></pre>
<h3 id="if…else-if…else-语句"><a href="#if…else-if…else-语句" class="headerlink" title="if…else if…else 语句"></a>if…else if…else 语句</h3><p>使用 if….else if…else 语句来选择多个代码块之一来执行</p>
<pre><code class="JavaScript">if (condition1) {当条件 1 为 true 时执行的代码}
else if (condition2) {当条件 2 为 true 时执行的代码}
else {当条件 1 和 条件 2 都不为 true 时执行的代码}

var x = 10
function z(){if(x&lt;5){return x}else if(x&lt;15){return x+5}else{return x+1}
}
z() //15
</code></pre>
<hr>
<h2 id="JavaScript-switch-语句"><a href="#JavaScript-switch-语句" class="headerlink" title="JavaScript switch 语句"></a>JavaScript switch 语句</h2><p>switch 语句用于基于不同条件来执行不同的动作</p>
<h3 id="JavaScript-switch-语句-1"><a href="#JavaScript-switch-语句-1" class="headerlink" title="JavaScript switch 语句"></a>JavaScript switch 语句</h3><p>使用 switch 语句来选择要执行的多个代码块之一</p>
<pre><code class="JavaScript">switch(n){
    case 1:
        执行代码块 1
        break;
    case 2:
        执行代码块 2
        break;
    default:
        与 case1 和 case2 不同时执行
}
工作原理：首先设置表达式 n（通常是一个变量）。随后表达式的值会与结构中的每个 case 的值做比较
如果存在匹配，则与该 case 关联的代码块会被执行。请使用 break 来阻止代码自动地向下一个 case 运行

var d=new Date().getDay();
switch (d) {
  case 0:x=&quot;今天是星期日&quot;;
  break;
  case 1:x=&quot;今天是星期一&quot;;
  break;
  case 2:x=&quot;今天是星期二&quot;;
  break;
  case 3:x=&quot;今天是星期三&quot;;
  break;
  case 4:x=&quot;今天是星期四&quot;;
  break;
  case 5:x=&quot;今天是星期五&quot;;
  break;
  case 6:x=&quot;今天是星期六&quot;;
  break;
}
// 今天是星期六
</code></pre>
<h3 id="default-关键词"><a href="#default-关键词" class="headerlink" title="default 关键词"></a>default 关键词</h3><p>使用 default 关键词来规定匹配不存在时做的事情</p>
<pre><code class="JavaScript">var d=new Date().getDay();
switch (d) {
    case 666:x=&quot;今天是星期六&quot;;
    break;
    case 000:x=&quot;今天是星期日&quot;;
    break;
    default:
    x=&quot;期待周末&quot;;
}
// 期待周末
</code></pre>
<hr>
<h2 id="JavaScript-for-循环"><a href="#JavaScript-for-循环" class="headerlink" title="JavaScript for 循环"></a>JavaScript for 循环</h2><p>循环可以将代码块执行指定的次数</p>
<h3 id="JavaScript-循环"><a href="#JavaScript-循环" class="headerlink" title="JavaScript 循环"></a>JavaScript 循环</h3><p>如果需要一遍又一遍运行相同的代码，且每次的值都不同，那么可以使用循环</p>
<pre><code class="JavaScript">// 常规写法
document.write(x[0])
document.write(x[1])
document.write(x[2])
document.write(x[3])
document.write(x[4])
document.write(x[5])
//for 循环
for(let i=0;i&lt;x.length;i++){document.write(x[i]) 
}
</code></pre>
<h3 id="不同类型的循环"><a href="#不同类型的循环" class="headerlink" title="不同类型的循环"></a>不同类型的循环</h3><p>JavaScript 支持不同类型的循环：</p>
<ul>
<li>for 循环代码块一定的次数</li>
<li>for/in 循环遍历对象的属性</li>
<li>while 当指定的条件为 true 时循环指定的代码块</li>
<li>do/while 同样当指定的条件为 true 时循环指定的代码块</li>
</ul>
<h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><pre><code class="JavaScript">for(语句 1; 语句 2; 语句 3){被执行的代码块}
语句 1 （代码块）开始前执行
语句 2 定义运行循环（代码块）的条件
语句 3 在循环（代码块）已被执行之后执行

for (var i=0; i&lt;5; i++) {x+=i;}
</code></pre>
<h3 id="for-in-循环"><a href="#for-in-循环" class="headerlink" title="for/in 循环"></a>for/in 循环</h3><p>JavaScript for/in 语句循环遍历对象的属性</p>
<pre><code class="JavaScript">var person={fname:&quot;John&quot;,lname:&quot;Doe&quot;,age:25};
for (x in person) { // x 为属性名
    txt=txt + person[x];
}
//JohnDoe25
</code></pre>
<hr>
<h2 id="JavaScript-while-循环"><a href="#JavaScript-while-循环" class="headerlink" title="JavaScript while 循环"></a>JavaScript while 循环</h2><p>只要指定条件为 true，循环就可以一直执行代码块</p>
<h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><pre><code class="JavaScript">while(条件){代码块}

while(i&lt;5){
    x+=i
    i++
}
</code></pre>
<h3 id="do-while-循环"><a href="#do-while-循环" class="headerlink" title="do/while 循环"></a>do/while 循环</h3><p>do/while 循环是 while 循环的变体，该循环会在检查条件是否为真之前执行一次代码块，然后如果条件为真，则会重复循环，意味着代码至少会被执行一次</p>
<pre><code class="JavaScript">do{代码}
while(条件)

do{
    x+=i
    i++
}
while(i&gt;3)
</code></pre>
<h3 id="比较-for-跟-while-循环"><a href="#比较-for-跟-while-循环" class="headerlink" title="比较 for 跟 while 循环"></a>比较 for 跟 while 循环</h3><p>基本类似</p>
<hr>
<h2 id="JavaScript-break-和-continue-语句"><a href="#JavaScript-break-和-continue-语句" class="headerlink" title="JavaScript break 和 continue 语句"></a>JavaScript break 和 continue 语句</h2><p>break 语句用于跳出循环<br>continue 语句用于跳出循环中的一个迭代</p>
<h3 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h3><p>break 语句跳出循环后，会继续执行该循环之后的代码（如果有）</p>
<pre><code class="JavaScript">for (i=0;i&lt;10;i++) {if (i==3) {break;}
    x=x + &quot;The number is&quot; + i + &quot;&lt;br&gt;&quot;;
}
//0 1 2
</code></pre>
<h3 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a>continue 语句</h3><p>continue 语句中断循环中的的迭代，如果出现了指定的条件，然后继续循环中的下一个迭代</p>
<pre><code class="JavaScript">for (i=0;i&lt;10;i++) {if (i==3) {continue;}
    x=x + &quot;The number is&quot; + i + &quot;&lt;br&gt;&quot;;
}
//0 1 2 4 5 6 7 8 9 
</code></pre>
<h3 id="JavaScript-标签"><a href="#JavaScript-标签" class="headerlink" title="JavaScript 标签"></a>JavaScript 标签</h3><p>continue 语句（带有或不带标签引用）只能用在循环中<br>break 语句（不带标签引用）只能在循环或 switch 中<br>通过标签引用，break 语句可用于跳出任何 JavaScript 代码块</p>
<pre><code class="JavaScript">cars=[&quot;BMW&quot;,&quot;Volvo&quot;,&quot;Saab&quot;,&quot;Ford&quot;];
list: {document.write(cars[0] + &quot;&lt;br&gt;&quot;);
    document.write(cars[1] + &quot;&lt;br&gt;&quot;);
    document.write(cars[2] + &quot;&lt;br&gt;&quot;);
    break list;
    document.write(cars[3] + &quot;&lt;br&gt;&quot;);
    document.write(cars[4] + &quot;&lt;br&gt;&quot;);
    document.write(cars[5] + &quot;&lt;br&gt;&quot;);}
//&quot;BMW&quot;&quot;Volvo&quot;&quot;Saab&quot;
</code></pre>
<hr>
<h2 id="JavaScript-typeof、null、undefined"><a href="#JavaScript-typeof、null、undefined" class="headerlink" title="JavaScript typeof、null、undefined"></a>JavaScript typeof、null、undefined</h2><h3 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h3><p>检测变量的数据类型</p>
<pre><code class="JavaScript">typeof &quot;John&quot;               //  返回 string
typeof 3.14                 //  返回 number
typeof false                //  返回 boolean
typeof [1,2,3]              //  返回 object
typeof {name:&#39;John&#39;,age:34} //  返回 object
</code></pre>
<h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><p>在 JavaScript 中 null 表示“什么都没有”<br>null 是一个只有一个值的特殊类型，表示一个空对象引用<br>用 typeof 检测 null 返回 object<br>可以设置 null 来清空对象</p>
<pre><code class="JavaScript">var person = null // 值为 null（空） 类型为对象
var person = undefined // 值为 undefined 类型为 undefined
</code></pre>
<h3 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h3><p>在 JavaScript 中，undefined 是一个没有设置值的变量<br>typeof 一个没有值的变量会返回 undefined</p>
<h3 id="undefined-和-null-的区别"><a href="#undefined-和-null-的区别" class="headerlink" title="undefined 和 null 的区别"></a>undefined 和 null 的区别</h3><p>null 和 undefined 的值相等，但类型不同</p>
<pre><code class="JavaScript">typeof undefined //undefined
typeof null //object
null === undefined //false
null == undefined //true
</code></pre>
<hr>
<h2 id="JavaScript-类型转换"><a href="#JavaScript-类型转换" class="headerlink" title="JavaScript 类型转换"></a>JavaScript 类型转换</h2><p>Number()转换为数字，String() 转换为字符串，Boolean() 转换为布尔值</p>
<h3 id="JavaScript-数据类型-3"><a href="#JavaScript-数据类型-3" class="headerlink" title="JavaScript 数据类型"></a>JavaScript 数据类型</h3><p>在 JavaScript 中有 5 种不同的数据类型</p>
<ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>object</li>
<li>function</li>
</ul>
<p>3 种对象类型</p>
<ul>
<li>Object</li>
<li>Date</li>
<li>Array</li>
</ul>
<p>2 种不包含任何值的数据类型</p>
<ul>
<li>null</li>
<li>undefined</li>
</ul>
<h3 id="typeof-操作符-1"><a href="#typeof-操作符-1" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h3><pre><code class="JavaScript">typeof &quot;john&quot;           //string
typeof 3.14             //number
typeof NaN              //number
typeof false            //boolean
typeof [1,2,3]          //object
typeof {name:&#39;y&#39;,age:30}//object
typeof new Date()       //object
typeof function(){}     //function
typeof x                //undefined
typeof null             //object
typeof undefined        //undefined
</code></pre>
<p>注意：</p>
<ul>
<li>NaN 的数据类型是 number</li>
<li>数组 Array 的数据类型是 object</li>
<li>日期 Date 的数据类型是 object</li>
<li>null 的数据类型是 object</li>
<li>未定义变量的数据类型是 undefined</li>
</ul>
<h3 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a>constructor 属性</h3><p>constructor 属性返回所有 JavaScript 变量的构造函数</p>
<pre><code class="JavaScript">&quot;John&quot;.constructor                 // 返回函数 String(){[native code] }
(3.14).constructor                 // 返回函数 Number(){[native code] }
false.constructor                  // 返回函数 Boolean(){[native code] }
[1,2,3,4].constructor              // 返回函数 Array(){[native code] }
{name:&#39;John&#39;, age:34}.constructor  // 返回函数 Object(){[native code] }
new Date().constructor             // 返回函数 Date()    {[native code] }
function (){}.constructor         // 返回函数 Function(){[native code] }
</code></pre>
<h3 id="JavaScript-类型转换-1"><a href="#JavaScript-类型转换-1" class="headerlink" title="JavaScript 类型转换"></a>JavaScript 类型转换</h3><p>JavaScript 变量可以转换为新变量或其他数据类型</p>
<ul>
<li>通过使用 JavaScript 函数</li>
<li>通过 JavaScript 自身自动转换</li>
</ul>
<h3 id="将数字转换为字符串"><a href="#将数字转换为字符串" class="headerlink" title="将数字转换为字符串"></a>将数字转换为字符串</h3><pre><code class="JavaScript">String(x)       // 将变量 x 转换为字符串并返回 &quot;x&quot;
String(123)     // 将数字 123 转换为字符串并返回 &quot;123&quot;
String(100+23)  // 将数字表达式转换为字符串并返回 &quot;123&quot;

Number 方法 toString() 也有同样的效果
x.toString()        //&quot;x&quot;
(123).toString()    //&quot;123&quot;
(100+23).toString() //&quot;123&quot;
</code></pre>
<h3 id="将布尔值转换为字符串"><a href="#将布尔值转换为字符串" class="headerlink" title="将布尔值转换为字符串"></a>将布尔值转换为字符串</h3><p>全局方法 String() 可以将布尔值转换为字符串</p>
<pre><code class="JavaScript">String(false)   //&quot;false&quot;
String(true)    //&quot;true&quot;
false.toString()//&quot;false&quot;
true.toString() //&quot;true&quot;
</code></pre>
<h3 id="将日期转换为字符串"><a href="#将日期转换为字符串" class="headerlink" title="将日期转换为字符串"></a>将日期转换为字符串</h3><p>Date() 返回字符串</p>
<pre><code class="JavaScript">Date()// 返回 &quot;Sat Apr 04 2020 17:25:36 GMT+0800 ( 中国标准时间)&quot;
String(new Date())  // 返回 &quot;Sat Apr 04 2020 17:25:36 GMT+0800 (中国标准时间)&quot;
obj = new Date()obj.toString()  // 返回 &quot;Sat Apr 04 2020 17:25:36 GMT+0800 (中国标准时间)&quot;
</code></pre>
<p>Date 方法</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">getDate()</td>
<td style="text-align:center">从 Date 对象返回一个月中的某一天（1-31）</td>
</tr>
<tr>
<td style="text-align:center">getDay()</td>
<td style="text-align:center">从 Date 对象返回一周中的某一天（0-6）</td>
</tr>
<tr>
<td style="text-align:center">getFullYear()</td>
<td style="text-align:center">从 Date 对象以四位数字返回年份</td>
</tr>
<tr>
<td style="text-align:center">getMonth()</td>
<td style="text-align:center">从 Date 对象返回月份（0-11）</td>
</tr>
<tr>
<td style="text-align:center">getHours()</td>
<td style="text-align:center">返回 Date 对象的小时（0-23）</td>
</tr>
<tr>
<td style="text-align:center">getMinutes()</td>
<td style="text-align:center">返回 Date 对象的分钟（0-59）</td>
</tr>
<tr>
<td style="text-align:center">getSeconds()</td>
<td style="text-align:center">返回 Date 对象的秒数（0-59）</td>
</tr>
<tr>
<td style="text-align:center">getMilliseconds()</td>
<td style="text-align:center">返回 Date 对象的毫秒数（0-999）</td>
</tr>
<tr>
<td style="text-align:center">getTime()</td>
<td style="text-align:center">返回 1970 年 1 月 1 日至今的毫秒数</td>
</tr>
</tbody>
</table>
<h3 id="将字符串转换为数字"><a href="#将字符串转换为数字" class="headerlink" title="将字符串转换为数字"></a>将字符串转换为数字</h3><p>全局方法 Number() 可以将字符串转换为数字<br>空字符串转换为 0<br>其他的字符串会转换为 NaN（不是数字）</p>
<pre><code class="JavaScript">Number(&quot;3.14&quot;)  //3.14
Number(&quot; &quot;)     //0
Number(&quot;&quot;)      //0
Number(&quot;99 88&quot;) //NaN
</code></pre>
<h3 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符 +"></a>一元运算符 +</h3><p>Operator + 可用于将变量转换为数字<br>如果变量不能转换，它仍是一个数字，但值为 NaN</p>
<pre><code class="JavaScript">var x = &quot;5&quot;
var y = +x      //5

var x = &quot;sdad&quot;
var y = +x      //NaN
</code></pre>
<h3 id="将布尔值转换为数字"><a href="#将布尔值转换为数字" class="headerlink" title="将布尔值转换为数字"></a>将布尔值转换为数字</h3><p>全局方法 Number() 将布尔值转换为数字</p>
<pre><code class="JavaScript">Number(false)   //0
Number(true)    //1
</code></pre>
<h3 id="将日期转换为数字"><a href="#将日期转换为数字" class="headerlink" title="将日期转换为数字"></a>将日期转换为数字</h3><p>全局方法 Number() 将日期转换为数字</p>
<pre><code class="JavaScript">obj = new Date()Number(obj)     //1585993392324
obj.getTime()   //1585993392324
</code></pre>
<h3 id="自动转换类型"><a href="#自动转换类型" class="headerlink" title="自动转换类型"></a>自动转换类型</h3><p>当 JavaScript 尝试操作一个“错误”的数据类型时，会自动转换为“正确“的数据类型</p>
<pre><code class="JavaScript">5 + null    //5         null 转换为 0
&quot;5&quot; + null  //&quot;5null&quot;   null 转换为 &quot;null&quot;
&quot;5&quot; + 1     //51        1 转换为 &quot;1&quot;
&quot;5&quot; - 1     //4         &quot;5&quot; 转换为 5
</code></pre>
<hr>
<h2 id="JavaScript-正则表达式"><a href="#JavaScript-正则表达式" class="headerlink" title="JavaScript 正则表达式"></a>JavaScript 正则表达式</h2><p>正则表达式（Regular Expression，在代码中常简写为 regex，regexp 或 RE）使用单个字符串来描述、匹配一系列符合某个句法规则的的字符串搜索模式<br>搜索模式可用于文本搜索和文本替换</p>
<h3 id="什么事正则表达式"><a href="#什么事正则表达式" class="headerlink" title="什么事正则表达式"></a>什么事正则表达式</h3><p>正则表达式是由一个字符序列形成的搜索模式<br>当你在文本中搜索数据时，你可以用搜索模式来描述你要查询的内容<br>正则表达式可以是一个简单的字符，或一个更复杂的模式<br>正则表达式可用于所有文本搜索和文本替换的操作</p>
<pre><code class="JavaScript">/ 正则表达式主体 / 修饰符（可选）
var patt = /nowcoder/i

/nowcoder/i 是一个正则表达式
nowcoder 是一个正则表达式主体（用于检索）
i 是一个修饰符（搜索不区分大小写）
</code></pre>
<h3 id="使用字符串方法"><a href="#使用字符串方法" class="headerlink" title="使用字符串方法"></a>使用字符串方法</h3><p>在 JavaScript 中，正则表达式通常用于两个字符串方法：search()和 replace()<br>search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置<br>replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串</p>
<h3 id="search-方法使用正则表达式"><a href="#search-方法使用正则表达式" class="headerlink" title="search() 方法使用正则表达式"></a>search() 方法使用正则表达式</h3><pre><code class="JavaScript">搜索字符串 &quot;Nowcoder&quot;, 并显示匹配的起始位置：
var str = &quot;Visit Nowcoder!&quot;
var n = str.search(/Nowcoder/i)
//6
search 方法可使用字符串作为参数。字符串参数会转换为正则表达式，搜索字符串 &quot;Nowcoder&quot;, 并显示匹配的起始位置：
var str = &quot;Visit Nowcoder!&quot;
var n = str.search(&quot;Nowcoder&quot;)
</code></pre>
<h3 id="replace-方法使用正则表达式"><a href="#replace-方法使用正则表达式" class="headerlink" title="replace() 方法使用正则表达式"></a>replace() 方法使用正则表达式</h3><pre><code class="JavaScript">使用正则表达式且不区分大小写将字符串中的 Microsoft 替换为 Nowcoder：
var str = document.getElementById(&quot;demo&quot;).innerHTML
var txt  = str.replace(/microsoft/i,&quot;Nowcoder&quot;)
//or
var txt = str.replace(&quot;Microsoft&quot;,&quot;Nowcoder&quot;)
</code></pre>
<h3 id="正则表达式修饰符"><a href="#正则表达式修饰符" class="headerlink" title="正则表达式修饰符"></a>正则表达式修饰符</h3><table>
<thead>
<tr>
<th style="text-align:center">修饰符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">i</td>
<td style="text-align:center">执行对大小写不敏感的匹配</td>
</tr>
<tr>
<td style="text-align:center">g</td>
<td style="text-align:center">执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）</td>
</tr>
<tr>
<td style="text-align:center">m</td>
<td style="text-align:center">执行多行匹配</td>
</tr>
</tbody>
</table>
<h3 id="使用-test-test-方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回-true，否则返回-false"><a href="#使用-test-test-方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回-true，否则返回-false" class="headerlink" title="使用 test()test() 方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false"></a>使用 test()test() 方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false</h3><pre><code class="JavaScript">/e/.test(&quot;The best things in life are free!&quot;) //true
字符串中含有“e”
</code></pre>
<h3 id="使用-exec-exec-方法用于检索字符串中的正则表达式的匹配，该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为-null"><a href="#使用-exec-exec-方法用于检索字符串中的正则表达式的匹配，该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为-null" class="headerlink" title="使用 exec()exec() 方法用于检索字符串中的正则表达式的匹配，该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null"></a>使用 exec()exec() 方法用于检索字符串中的正则表达式的匹配，该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null</h3><pre><code class="JavaScript">/e/.exec(&quot;The best things in life are free!&quot;) //e
字符串中含有“e”
</code></pre>
<hr>
<h2 id="JavaScript-错误-throw、try、catch"><a href="#JavaScript-错误-throw、try、catch" class="headerlink" title="JavaScript 错误 - throw、try、catch"></a>JavaScript 错误 - throw、try、catch</h2><p>try 语句测试代码块的错误<br>catch 语句处理错误<br>throw 语句创建自定义错误<br>finally 语句在 try 和 catch 语句之后，无论是否有触发异常，该语句都会执行</p>
<h3 id="JavaScript-错误"><a href="#JavaScript-错误" class="headerlink" title="JavaScript 错误"></a>JavaScript 错误</h3><p>当 JavaScript 引擎执行 JavaScript 代码时，会发生各种错误<br>可能是语法错误，通常是程序员造成的编码错误或错别字<br>可能是拼写错误或语言中缺少的功能（可能由于浏览器差异）<br>可能是由于来自服务器或用户的错误输出而导致的错误<br>当然，也可能是由于许多其他不可预知的因素</p>
<h3 id="JavaScript-抛出（throw）错误"><a href="#JavaScript-抛出（throw）错误" class="headerlink" title="JavaScript 抛出（throw）错误"></a>JavaScript 抛出（throw）错误</h3><p>当错误发生时，当事情出问题时，JavaScript 引擎通常会停止，并生成一个错误消息<br>描述这种情况的技术术语是：JavaScript 将抛出一个错误</p>
<h3 id="JavaScript-try-和-catch"><a href="#JavaScript-try-和-catch" class="headerlink" title="JavaScript try 和 catch"></a>JavaScript try 和 catch</h3><p>try 语句允许我们定义在执行时进行错误测试的代码块<br>catch 语句允许我们定义当 try 代码块发生错误时，所执行的代码块<br>JavaScript 语句 try 和 catch 是成对出现的</p>
<pre><code class="JavaScript">try {...    // 异常的抛出} catch(e) {...    // 异常的捕获与处理} finally {...    // 结束处理}

var txt=&quot;&quot;;
function message(){try {adddlert(&quot;Welcome guest!&quot;);
    } catch(err) {
        txt=&quot;本页有一个错误&quot;;
        txt+=&quot;错误描述：&quot; + err.message + &quot; &quot;;
        txt+=&quot;点击确定继续&quot;;
        alert(txt);
    }
}
</code></pre>
<h3 id="JavaScript-throw-和-finally"><a href="#JavaScript-throw-和-finally" class="headerlink" title="JavaScript throw 和 finally"></a>JavaScript throw 和 finally</h3><p>throw 语句允许我们创建自定义错误<br>正确的技术术语是：创建或抛出异常（exception）<br>如果把 throw 与 try 和 catch 一起使用，那么您能够控制程序流，并生成自定义的错误消息<br>finally 语句不论之前的 try 和 catch 中是否产生异常都会执行该代码块</p>
<pre><code class="JavaScript">function myFunction() {
  var message, x;
  message = document.getElementById(&quot;p01&quot;);
  message.innerHTML = &quot;&quot;;
  x = document.getElementById(&quot;demo&quot;).value;
  try {if(x == &quot;&quot;) throw&quot; 值是空的 &quot;;
    if(isNaN(x)) throw &quot;值不是一个数字&quot;;
    x = Number(x);
    if(x &gt; 10) throw &quot;太大&quot;;
    if(x &lt; 5) throw &quot;太小&quot;;
  }
  catch(err) {message.innerHTML = &quot;错误:&quot; + err + &quot;.&quot;;}
  finally {document.getElementById(&quot;demo&quot;).value = &quot;&quot;;
  }
}
</code></pre>
<hr>
<h2 id="JavaScript-调试"><a href="#JavaScript-调试" class="headerlink" title="JavaScript 调试"></a>JavaScript 调试</h2><h3 id="console-log-方法"><a href="#console-log-方法" class="headerlink" title="console.log() 方法"></a>console.log() 方法</h3><p>console.log() 打印 JavaScript 值</p>
<h3 id="设置断点-debugger"><a href="#设置断点-debugger" class="headerlink" title="设置断点 debugger"></a>设置断点 debugger</h3><p>debugger 关键字用于停止执行 JavaScript，并调用调试函数</p>
<pre><code class="JavaScript">开启 dubugger，则代码在第三行前停止执行
var x = 15 * 5;
debugger;
document.getElementbyId(&quot;demo&quot;).innerHTML = x;
</code></pre>
<hr>
<h2 id="JavaScript-变量提升"><a href="#JavaScript-变量提升" class="headerlink" title="JavaScript 变量提升"></a>JavaScript 变量提升</h2><p>JavaScript 中，函数及变量的声明都将被提升到函数的最顶端<br>JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明</p>
<pre><code class="JavaScript">x = 5; // 变量 x 设置为 5

elem = document.getElementById(&quot;demo&quot;); // 查找元素
elem.innerHTML = x;                     // 在元素中显示 x

var x; // 声明 x
// 等同于
var x; // 声明 x
x = 5; // 变量 x 设置为 5

elem = document.getElementById(&quot;demo&quot;); // 查找元素
elem.innerHTML = x;                     // 在元素中显示 x
</code></pre>
<h3 id="JavaScript-初始化不会提升"><a href="#JavaScript-初始化不会提升" class="headerlink" title="JavaScript 初始化不会提升"></a>JavaScript 初始化不会提升</h3><p>JavaScript 只有声明的变量会提升，初始化的不会</p>
<pre><code class="JavaScript">var x = 5; // 初始化 x
var y = 7; // 初始化 y

elem = document.getElementById(&quot;demo&quot;); // 查找元素
elem.innerHTML = x + &quot; &quot; + y;           // 显示 x 和 y
//5 7
var x = 5; // 初始化 x

elem = document.getElementById(&quot;demo&quot;); // 查找元素
elem.innerHTML = x + &quot; &quot; + y;           // 显示 x 和 y

var y = 7; // 初始化 y
//5 undefined
// 等同于
var x = 5; // 初始化 x
var y;     // 声明 y

elem = document.getElementById(&quot;demo&quot;); // 查找元素
elem.innerHTML = x + &quot; &quot; + y;           // 显示 x 和 y

y = 7;    // 设置 y 为 7
</code></pre>
<h3 id="在顶端声明变量"><a href="#在顶端声明变量" class="headerlink" title="在顶端声明变量"></a>在顶端声明变量</h3><p>为了避免这些问题，通常我们在每个作用域开始前声明这些变量，这也是正常的 JavaScript 解析步骤，易于我们理解<br>JavaScript 严格模式 (strict mode) 不允许使用未声明的变量</p>
<hr>
<h2 id="JavaScript-严格模式（use-strict）"><a href="#JavaScript-严格模式（use-strict）" class="headerlink" title="JavaScript 严格模式（use strict）"></a>JavaScript 严格模式（use strict）</h2><p>即在严格的条件下进行</p>
<h3 id="使用“use-strict”-指令"><a href="#使用“use-strict”-指令" class="headerlink" title="使用“use strict” 指令"></a>使用“use strict” 指令</h3><p>严格模式通过在脚本或函数的头部添加 <code>“use strict”</code> 表达式来声明<br>在函数内部声明是局部作用域<br>为什么要用严格模式：</p>
<ul>
<li>消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为</li>
<li>消除代码运行的一些不安全之处，保证代码运行的安全</li>
<li>提高编译器效率，增加运行速度</li>
<li>为未来新版本的 Javascript 做好铺垫</li>
</ul>
<hr>
<h2 id="JavaScript-使用误区"><a href="#JavaScript-使用误区" class="headerlink" title="JavaScript 使用误区"></a>JavaScript 使用误区</h2><h3 id="赋值运算符应用错误"><a href="#赋值运算符应用错误" class="headerlink" title="赋值运算符应用错误"></a>赋值运算符应用错误</h3><p>在 JavaScript 程序中如果在 if 条件语句中使用赋值运算符的等号 (=) 将会产生一个错误结果, 正确的方法是使用比较运算符的两个等号 (==)</p>
<pre><code class="JavaScript">var x = 0;
if (x == 10)    //false

var x = 0;
if (x = 10)     //true 

var x = 0;
if (x = 0)      //false
</code></pre>
<h3 id="比较运算符常见错误"><a href="#比较运算符常见错误" class="headerlink" title="比较运算符常见错误"></a>比较运算符常见错误</h3><p>在常规比较重，数据类型是被忽略的</p>
<pre><code class="JavaScript">var x = 10;
var y = &quot;10&quot;;
if (x == y)     //true

var x = 10;
var y = &quot;10&quot;;
if (x === y)    //false
</code></pre>
<p>switch 语句会使用恒等计算符（===）进行比较</p>
<pre><code class="JavaScript">var x = 10;
switch(x) {case 10: alert(&quot;Hello&quot;);
}   // 执行

var x = 10;
switch(x) {case &quot;10&quot;: alert(&quot;Hello&quot;);
}   // 不执行
</code></pre>
<h3 id="加法与连接注意事项"><a href="#加法与连接注意事项" class="headerlink" title="加法与连接注意事项"></a>加法与连接注意事项</h3><p>加法是两个数字相加<br>连接是两个字符串连接<br>JavaScript 的加法和连接都用 + 运算符</p>
<pre><code class="JavaScript">var x = 10 + 5;          // x 的结果为 15
var x = 10 + &quot;5&quot;;        // x 的结果为 &quot;105&quot;

var x = 10;
var y = 5;
var z = x + y;           // z 的结果为 15

var x = 10;
var y = &quot;5&quot;;
var z = x + y;           // z 的结果为 &quot;105&quot;
</code></pre>
<h3 id="浮点型数据使用注意事项"><a href="#浮点型数据使用注意事项" class="headerlink" title="浮点型数据使用注意事项"></a>浮点型数据使用注意事项</h3><p>JavaScript 中的所有数据都是以 64 位浮点型数据（float）来存储</p>
<pre><code class="JavaScript">var x = 0.1;
var y = 0.2;
var z = x + y            // z 的结果为 0.3
if (z == 0.3)            // 返回 false

可以用整数的乘除法来解决：
var z = (x * 10 + y * 10) / 10;       // z 的结果为 0.3
</code></pre>
<h3 id="JavaScript-字符串分行"><a href="#JavaScript-字符串分行" class="headerlink" title="JavaScript 字符串分行"></a>JavaScript 字符串分行</h3><pre><code class="JavaScript">var x =
&quot;Hello World!&quot;;

var x = &quot;Hello
World!&quot;;            // 报错

var x = &quot;Hello \nWorld!&quot;;
</code></pre>
<hr>
<h2 id="JavaScript-表单"><a href="#JavaScript-表单" class="headerlink" title="JavaScript 表单"></a>JavaScript 表单</h2><p>HTML 表单验证可以通过 JavaScript 完成</p>
<pre><code class="html">&lt;form name=&quot;myForm&quot; action=&quot;//www.nowcoder.com&quot;
      onsubmit=&quot;return validateForm()&quot; method=&quot;post&quot;&gt;
    名字: &lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
&lt;/form&gt;
</code></pre>
<pre><code class="js">function validateForm(){var x = document.forms[&quot;myForm&quot;][&quot;fname&quot;].value;
    if (x == null || x == &quot;&quot;) {alert(&quot; 需要输入名字。&quot;);
        return false;
    }
}
用于判断表单字段 (fname) 值是否存在， 如果不存在，就弹出信息，阻止表单提交
</code></pre>
<h3 id="JavaScript-验证输入的数字"><a href="#JavaScript-验证输入的数字" class="headerlink" title="JavaScript 验证输入的数字"></a>JavaScript 验证输入的数字</h3><pre><code class="js">function myFunction() {
    var x, text;

    // 获取 id=&quot;numb&quot; 的值
    x = document.getElementById(&quot;numb&quot;).value;

    // 如果输入的值 x 不是数字或者小于 1 或者大于 10，
    // 则提示错误 Not a Number or less than one or greater than 10
    if (isNaN(x) || x &lt; 1 || x &gt; 10){text = &quot;输入错误&quot;;} else {text = &quot;输入正确&quot;;}
    document.getElementById(&quot;demo&quot;).innerHTML = text;
}
</code></pre>
<h3 id="HTML-表单自动验证"><a href="#HTML-表单自动验证" class="headerlink" title="HTML 表单自动验证"></a>HTML 表单自动验证</h3><pre><code class="html">如果表单字段 (fname) 的值为空, required 属性会阻止表单提交：
&lt;form action=&quot;//www.nowcoder.com&quot; method=&quot;post&quot;&gt;
  &lt;input type=&quot;text&quot; name=&quot;fname&quot; required=&quot;required&quot;&gt;
  &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
&lt;/form&gt;
</code></pre>
<h3 id="数据验证"><a href="#数据验证" class="headerlink" title="数据验证"></a>数据验证</h3><p>数据验证用于确保用户输入的数据是有效的<br>典型的数据验证有：</p>
<ul>
<li>必需字段是否有输入?</li>
<li>用户是否输入了合法的数据?</li>
<li>在数字字段是否输入了文本?</li>
</ul>
<p>大多数情况下，数据验证用于确保用户正确输入数据<br>数据验证可以使用不同方法来定义，并通过多种方式来调用<br>服务端数据验证是在数据提交到服务器上后再验证<br>客户端数据验证是在数据发送到服务器前，在浏览器上完成验证</p>
<h3 id="HTML-约束验证"><a href="#HTML-约束验证" class="headerlink" title="HTML 约束验证"></a>HTML 约束验证</h3><p>HTML5 新增了 HTML 表单验证方式：约束验证<br>约束验证是表单被提交时浏览器用来实现验证的一种算法<br>HTML 约束验证基于：</p>
<ul>
<li>HTML 输入属性</li>
<li>CSS 伪类选择器</li>
<li>DOM 属性和方法</li>
</ul>
<p>约束验证 HTML 输入属性</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">disabled</td>
<td style="text-align:center">规定输入的元素不可用</td>
</tr>
<tr>
<td style="text-align:center">max</td>
<td style="text-align:center">规定输入元素的最大值</td>
</tr>
<tr>
<td style="text-align:center">min</td>
<td style="text-align:center">规定输入元素的最小值</td>
</tr>
<tr>
<td style="text-align:center">pattern</td>
<td style="text-align:center">规定输入元素值的模式</td>
</tr>
<tr>
<td style="text-align:center">required</td>
<td style="text-align:center">规定输入元素字段是必需的</td>
</tr>
<tr>
<td style="text-align:center">type</td>
<td style="text-align:center">规定输入元素的类型</td>
</tr>
</tbody>
</table>
<p>约束验证 CSS 伪类选择器</p>
<table>
<thead>
<tr>
<th style="text-align:center">选择器</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">:disabled</td>
<td style="text-align:center">选取属性为”disabled”属性的 input 元素</td>
</tr>
<tr>
<td style="text-align:center">:invalid</td>
<td style="text-align:center">选取无效的 input 元素</td>
</tr>
<tr>
<td style="text-align:center">:optional</td>
<td style="text-align:center">选择没有”required”属性的 input 元素</td>
</tr>
<tr>
<td style="text-align:center">:required</td>
<td style="text-align:center">选择有”required”属性的 input 元素</td>
</tr>
<tr>
<td style="text-align:center">:valid</td>
<td style="text-align:center">选取有效值的 input 元素</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="JavaScript-表单验证"><a href="#JavaScript-表单验证" class="headerlink" title="JavaScript 表单验证"></a>JavaScript 表单验证</h2><p>JavaScript 可用来在数据被送往服务器前对 HTML 表单中的这些输入数据进行验证<br>表单数据经常需要使用 JavaScript 来验证其正确性：</p>
<ul>
<li>验证表单数据是否为空？</li>
<li>验证输入是否是一个正确的 email 地址？</li>
<li>验证日期是否输入正确？</li>
<li>验证表单输入内容是否为数字型？</li>
</ul>
<h3 id="必填或必选项目"><a href="#必填或必选项目" class="headerlink" title="必填或必选项目"></a>必填或必选项目</h3><p>form 表单提交时调用函数检查用户是否已填写表单中的必填项目，假如为空，则发出警告</p>
<pre><code class="html">&lt;form name=&quot;myForm&quot; action=&quot;//www.nowcoder.com&quot;
    onsubmit=&quot;return validateForm()&quot; method=&quot;post&quot;&gt;
    姓: &lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
&lt;/form&gt;
</code></pre>
<pre><code class="js">function validateForm(){var x=document.forms[&quot;myForm&quot;][&quot;fname&quot;].value;
  if (x==null || x==&quot;&quot;) {alert(&quot; 姓必须填写 &quot;);
    return false;
  }
}
</code></pre>
<h3 id="E-mail-验证"><a href="#E-mail-验证" class="headerlink" title="E-mail 验证"></a>E-mail 验证</h3><p>函数检查用户输入的数据是否符合电子邮件地址的基本语法</p>
<pre><code class="html">&lt;form name=&quot;myForm&quot; action=&quot;//www.nowcoder.com&quot;
      onsubmit=&quot;return validateForm();&quot; method=&quot;post&quot;&gt;
    Email: &lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
&lt;/form&gt;
</code></pre>
<pre><code class="js">function validateForm(){var x=document.forms[&quot;myForm&quot;][&quot;email&quot;].value;
  var atpos=x.indexOf(&quot;@&quot;);
  var dotpos=x.lastIndexOf(&quot;.&quot;);
  if (atpos&lt;1 || dotpos&lt;atpos+2 || dotpos+2&gt;=x.length){alert(&quot;不是一个有效的 e-mail 地址&quot;);
    return false;
  }
}
// 输入的数据必须包含 @ 符号和点号 (.)。同时，@ 不可以是邮件地址的首字符，并且 @ 之后需有至少一个点号
</code></pre>
<hr>
<h2 id="JavaScript-this-关键字"><a href="#JavaScript-this-关键字" class="headerlink" title="JavaScript this 关键字"></a>JavaScript this 关键字</h2><p>面向对象语言中 this 表示当前对象的一个引用<br>但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变</p>
<ul>
<li>在方法中，this 表示该方法所属的对象</li>
<li>如果单独使用，this 表示全局对象</li>
<li>在函数中，this 表示全局对象</li>
<li>在函数中，在严格模式下，this 是未定义的 (undefined)</li>
<li>在事件中，this 表示接收事件的元素</li>
<li>类似 call()和 apply() 方法可以将 this 引用到任何对象</li>
</ul>
<h3 id="方法中的-this"><a href="#方法中的-this" class="headerlink" title="方法中的 this"></a>方法中的 this</h3><p>在对象方法中，this 指向调用它所在方法的对象</p>
<pre><code class="js">var person = {
  firstName: &quot;John&quot;,
  lastName : &quot;Doe&quot;,
  id       : 5566,
  fullName : function(){return this.firstName + &quot; &quot; + this.lastName;}
};
</code></pre>
<h3 id="单独使用-this"><a href="#单独使用-this" class="headerlink" title="单独使用 this"></a>单独使用 this</h3><p>单独使用 this，则指向全局对象（Global）<br>在浏览器中，window 就是该全局对象 [object Window]</p>
<pre><code class="js">var x = this //object Window
</code></pre>
<h3 id="函数中使用-this（默认）"><a href="#函数中使用-this（默认）" class="headerlink" title="函数中使用 this（默认）"></a>函数中使用 this（默认）</h3><p>在函数中，函数的所属者默认绑定到 this 上<br>//object Window</p>
<h3 id="函数中使用-this（严格模式）"><a href="#函数中使用-this（严格模式）" class="headerlink" title="函数中使用 this（严格模式）"></a>函数中使用 this（严格模式）</h3><p>严格模式下函数是没有绑定到 this 上的，this 为 undefined</p>
<h3 id="事件中的-this"><a href="#事件中的-this" class="headerlink" title="事件中的 this"></a>事件中的 this</h3><p>在 HTML 事件中，this 指向了接受事件的 HTML 元素</p>
<pre><code class="html">&lt;button onclick=&quot;this.style.display=&#39;none&#39;&quot;&gt;
点我后我就消失了
&lt;/button&gt;
</code></pre>
<h3 id="对象方法中绑定"><a href="#对象方法中绑定" class="headerlink" title="对象方法中绑定"></a>对象方法中绑定</h3><pre><code class="js">var person = {
  firstName  : &quot;John&quot;,
  lastName   : &quot;Doe&quot;,
  id         : 5566,
  myFunction : function(){return this;}
};//[object Object]

var person = {
  firstName: &quot;John&quot;,
  lastName : &quot;Doe&quot;,
  id       : 5566,
  fullName : function(){return this.firstName + &quot; &quot; + this.lastName;}
};//John Doe
this.firstName 表示 this（person）对象的 firstName 属性
</code></pre>
<h3 id="显式函数绑定"><a href="#显式函数绑定" class="headerlink" title="显式函数绑定"></a>显式函数绑定</h3><p>在 JavaScript 中函数也是对象，对象则有方法，apply 和 call 就是函数对象的方法，这两个方法异常强大，他们允许切换函数执行的上下文环境（context），即 this 绑定的对象<br>下面实例中，使用 person2 作为参数来调用 person1.fullName 方法时，this 将指向 person2，即便它是 person1 的方法</p>
<pre><code class="js">var person1 = {fullName: function() {return this.firstName + &quot; &quot; + this.lastName;}
}
var person2 = {
  firstName:&quot;John&quot;,
  lastName: &quot;Doe&quot;,
}
person1.fullName.call(person2);  // 返回 &quot;John Doe&quot;
</code></pre>
<hr>
<h2 id="JavaScript-let-和-const"><a href="#JavaScript-let-和-const" class="headerlink" title="JavaScript let 和 const"></a>JavaScript let 和 const</h2><p>ES6 新增加了两个重要的 Javascript 关键字：let 和 const<br>let 声明的变量只在 let 命令所在的代码块内有效<br>const 声明一个只读的常量，一旦声明，常量的值就不能改变<br>在 ES6 之前，Javascript 只有两种作用域：全局变量与函数内的局部变量</p>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>在函数外声明的变量作用域是全局的<br>全局变量在 Javascript 程序的任何地方都可以访问</p>
<pre><code class="js">var carName = &quot;Volvo&quot;;
// 这里可以使用 carName 变量
function myFunction(){// 这里也可以使用 carName 变量}
</code></pre>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>在函数内声明的变量作用域是局部的<br>函数内使用 var 声明的变量只能在函数内容访问，如果不使用 var 则是全局变量</p>
<pre><code class="js">// 这里不能使用 carName 变量
function myFunction() {
    var carName = &quot;Volvo&quot;;
    // 这里可以使用 carName 变量
}
// 这里不能使用 carName 变量
</code></pre>
<h3 id="JavaScript-块级作用域（Block-Scope）"><a href="#JavaScript-块级作用域（Block-Scope）" class="headerlink" title="JavaScript 块级作用域（Block Scope）"></a>JavaScript 块级作用域（Block Scope）</h3><p>使用 var 关键字声明的变量不具备块级作用域的特性，它在 {} 外依然能被访问到</p>
<pre><code class="js">{var x = 2;}
// 这里可以使用 x 变量
</code></pre>
<p>在 ES6 之前，是没有块级作用域的概念的<br>ES6 可以使用 let 关键字来实现块级作用域<br>let 声明的变量只在 let 命令所在的代码块 {} 内有效，在 {} 之外不能访问</p>
<pre><code class="js">{let x = 2;}
// 这里不能使用 x 变量
</code></pre>
<h3 id="重新定义变量"><a href="#重新定义变量" class="headerlink" title="重新定义变量"></a>重新定义变量</h3><p>使用 var 关键字重新声明变量可能会带来问题<br>在块中重新声明变量也会重新声明块外的变量</p>
<pre><code class="js">var x = 10;
// 这里输出 x 为 10
{
    var x = 2;
    // 这里输出 x 为 2
}
// 这里输出 x 为 2
</code></pre>
<h3 id="循环作用域"><a href="#循环作用域" class="headerlink" title="循环作用域"></a>循环作用域</h3><p>使用 var 关键字</p>
<pre><code class="js">var i = 5;
for (var i = 0; i &lt; 10; i++) {// 一些代码...}
// 这里输出 i 为 10
</code></pre>
<p>let 关键字</p>
<pre><code class="js">let i = 5;
for (let i = 0; i &lt; 10; i++) {// 一些代码...}
// 这里输出 i 为 5
</code></pre>
<p>在第一个实例中，使用了 var 关键字，它声明的变量是全局的，包括循环体内与循环体外<br>在第二个实例中，使用 let 关键字， 它声明的变量作用域只在循环体内，循环体外的变量不受影响</p>
<h3 id="局部变量-1"><a href="#局部变量-1" class="headerlink" title="局部变量"></a>局部变量</h3><p>在函数体内使用 var 和 let 关键字声明的变量有点类似</p>
<pre><code class="js">// 使用 var
function myFunction(){var carName = &quot;Volvo&quot;;   // 局部作用域}

// 使用 let
function myFunction(){let carName = &quot;Volvo&quot;;   //  局部作用域}
</code></pre>
<h3 id="全局变量-1"><a href="#全局变量-1" class="headerlink" title="全局变量"></a>全局变量</h3><p>在函数体内或代码块外使用 var 和 let 关键字声明的变量也有点类似<br>它们的作用域都是全局的</p>
<pre><code class="js">// 使用 var
var x = 2;       // 全局作用域

// 使用 let
let x = 2;       // 全局作用域
</code></pre>
<h3 id="HTML-代码中使用全局变量"><a href="#HTML-代码中使用全局变量" class="headerlink" title="HTML 代码中使用全局变量"></a>HTML 代码中使用全局变量</h3><p>在 JavaScript 中, 全局作用域是针对 JavaScript 环境<br>在 HTML 中, 全局作用域是针对 window 对象<br>使用 var 关键字声明的全局作用域变量属于 window 对象：</p>
<pre><code class="js">var carName = &quot;Volvo&quot;;
// 可以使用 window.carName 访问变量
</code></pre>
<p>使用 let 关键字声明的全局作用域变量不属于 window 对象</p>
<pre><code class="js">let carName = &quot;Volvo&quot;
// 不能使用 window.carName 访问变量
</code></pre>
<h3 id="重制变量"><a href="#重制变量" class="headerlink" title="重制变量"></a>重制变量</h3><p>使用 var 关键字声明的变量在任何地方都可以修改</p>
<pre><code class="js">var x = 2;
// x 为 2

var x = 3;
// 现在 x 为 3
</code></pre>
<p>在相同的作用域或块级作用域中，不能使用 let 关键字来重置 var 关键字声明的变量：</p>
<pre><code class="js">var x = 2;       // 合法
let x = 3;       // 不合法

{
    var x = 4;   // 合法
    let x = 5   // 不合法
}
</code></pre>
<p>在相同的作用域或块级作用域中，不能使用 let 关键字来重置 let 关键字声明的变量：</p>
<pre><code class="js">let x = 2;       // 合法
let x = 3;       // 不合法

{
    let x = 4;   // 合法
    let x = 5;   // 不合法
}
</code></pre>
<p>在相同的作用域或块级作用域中，不能使用 var 关键字来重置 let 关键字声明的变量：</p>
<pre><code class="js">let x = 2;       // 合法
var x = 3;       // 不合法

{
    let x = 4;   // 合法
    var x = 5;   // 不合法
}
</code></pre>
<p>let 关键字在不同作用域，或不同块级作用域中是可以重新声明赋值的：</p>
<pre><code class="js">let x = 2;       // 合法

{let x = 3;   // 合法}

{let x = 4;   // 合法}
</code></pre>
<h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>JavaScript 中，var 关键字定义的变量可以在使用后声明，也就是变量可以先使用再声明</p>
<pre><code class="js">// 在这里可以使用 carName 变量

var carName;
</code></pre>
<p>let 关键字定义的变量则不可以在使用后声明，也就是变量需要先声明再使用。</p>
<pre><code class="js">// 在这里不可以使用 carName 变量

let carName;
</code></pre>
<p>const 关键字定义的变量则不可以在使用后声明，也就是变量需要先声明再使用</p>
<pre><code class="js">carName = &quot;Volvo&quot;;    // 在这里不可以使用 carName 变量
const carName = &quot;Volvo&quot;;
</code></pre>
<h3 id="const-关键字"><a href="#const-关键字" class="headerlink" title="const 关键字"></a>const 关键字</h3><p>const 用于声明一个或多个常量，声明时必须进行初始化，且初始化后值不可再修改</p>
<pre><code class="js">const PI = 3.141592653589793;
PI = 3.14;      // 报错
PI = PI + 10;   // 报错
</code></pre>
<p>const 定义常量与使用 let 定义的变量相似：</p>
<ul>
<li>二者都是块级作用域</li>
<li>都不能和它所在作用域内的其他变量或函数拥有相同的名称</li>
</ul>
<p>两者还有以下两点区别：</p>
<ul>
<li>const 声明的常量必须初始化，而 let 声明的变量不用</li>
<li>const 定义常量的值不能通过再赋值修改，也不能再次声明。而 let 定义的变量值可以修改</li>
</ul>
<pre><code class="js">var x = 10;
// 这里输出 x 为 10
{
    const x = 2;
    // 这里输出 x 为 2
}
// 这里输出 x 为 10
</code></pre>
<p>const 声明的常量必须初始化：</p>
<pre><code class="js">// 错误写法
const PI;
PI = 3.14159265359;

// 正确写法
const PI = 3.14159265359;
</code></pre>
<h3 id="并非真正的常量"><a href="#并非真正的常量" class="headerlink" title="并非真正的常量"></a>并非真正的常量</h3><p>const 的本质: const 定义的变量并非常量，并非不可变，它定义了一个常量引用一个值。使用 const 定义的对象或者数组，其实是可变的。下面的代码并不会报错：</p>
<pre><code class="js">// 创建常量对象
const car = {type:&quot;Fiat&quot;, model:&quot;500&quot;, color:&quot;white&quot;};

// 修改属性:
car.color = &quot;red&quot;;

// 添加属性
car.owner = &quot;Johnson&quot;;
</code></pre>
<p>但是我们不能对常量对象重新赋值：</p>
<pre><code class="js">const car = {type:&quot;Fiat&quot;, model:&quot;500&quot;, color:&quot;white&quot;};
car = {type:&quot;Volvo&quot;, model:&quot;EX60&quot;, color:&quot;red&quot;};    // 错误
</code></pre>
<p>以下实例修改常量数组：</p>
<pre><code class="js">// 创建常量数组
const cars = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;];

// 修改元素
cars[0] = &quot;Toyota&quot;;

// 添加元素
cars.push(&quot;Audi&quot;);
</code></pre>
<p>但是我们不能对常量数组重新赋值：</p>
<pre><code class="js">const cars = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;];
cars = [&quot;Toyota&quot;, &quot;Volvo&quot;, &quot;Audi&quot;];    // 错误
</code></pre>
<h3 id="重置变量"><a href="#重置变量" class="headerlink" title="重置变量"></a>重置变量</h3><p>使用 var 关键字声明的变量在任何地方都可以修改</p>
<pre><code class="js">var x = 2;    //  合法
var x = 3;    //  合法
x = 4;        //  合法
</code></pre>
<p>在相同的作用域或块级作用域中，不能使用 const 关键字来重置 var 和 let 关键字声明的变量：</p>
<pre><code class="js">var x = 2;         // 合法
const x = 2;       // 不合法
{
    let x = 2;     // 合法
    const x = 2;   // 不合法
}
</code></pre>
<p>在相同的作用域或块级作用域中，不能使用 const 关键字来重置 const 关键字声明的变量：</p>
<pre><code class="js">const x = 2;       // 合法
const x = 3;       // 不合法
x = 3;             // 不合法
var x = 3;         // 不合法
let x = 3;         // 不合法

{
    const x = 2;   // 合法
    const x = 3;   // 不合法
    x = 3;         // 不合法
    var x = 3;     // 不合法
    let x = 3;     // 不合法
}
</code></pre>
<p>const 关键字在不同作用域，或不同块级作用域中是可以重新声明赋值的：</p>
<pre><code class="js">const x = 2;       // 合法

{const x = 3;   // 合法}

{const x = 4;   // 合法}
</code></pre>
<hr>
<h2 id="Javascript-JSON"><a href="#Javascript-JSON" class="headerlink" title="Javascript JSON"></a>Javascript JSON</h2><p>JSON 是用于存储和传输数据的格式<br>JSON 通常用于服务端向网页传递数据 </p>
<h3 id="什么是-JSON？"><a href="#什么是-JSON？" class="headerlink" title="什么是 JSON？"></a>什么是 JSON？</h3><p>JSON 英文全称 JavaScript Object Notation<br>JSON 是一种轻量级的数据交换格式<br>JSON 是独立的语言<br>JSON 易于理解<br>JSON 使用 JavaScript 语法，但是 JSON 格式仅仅是一个文本<br>文本可以被任何编程语言读取及作为数据格式传递</p>
<h3 id="JSON-实例"><a href="#JSON-实例" class="headerlink" title="JSON 实例"></a>JSON 实例</h3><p>JSON 语法定义了 sites 对象：3 条网站信息（对象）的数组：</p>
<pre><code class="js">{&quot;sites&quot;:[{&quot;name&quot;:&quot;Runoob&quot;, &quot;url&quot;:&quot;www.nowcoder.com&quot;},
    {&quot;name&quot;:&quot;Google&quot;, &quot;url&quot;:&quot;www.google.com&quot;},
    {&quot;name&quot;:&quot;Taobao&quot;, &quot;url&quot;:&quot;www.taobao.com&quot;}
]}
</code></pre>
<h3 id="JSON-格式化后为-JavaScript-对象"><a href="#JSON-格式化后为-JavaScript-对象" class="headerlink" title="JSON 格式化后为 JavaScript 对象"></a>JSON 格式化后为 JavaScript 对象</h3><p>JSON 格式在语法上与创建 JavaScript 对象代码是相同的<br>由于它们很相似，所以 JavaScript 程序可以很容易的将 JSON 数据转换为 JavaScript 对象</p>
<h3 id="JSON-语法规则"><a href="#JSON-语法规则" class="headerlink" title="JSON 语法规则"></a>JSON 语法规则</h3><p>数据为 键 / 值 对<br>数据由逗号分隔<br>大括号保存对象<br>方括号保存数组</p>
<h3 id="JSON-数据-一个名称对应一个值"><a href="#JSON-数据-一个名称对应一个值" class="headerlink" title="JSON 数据 - 一个名称对应一个值"></a>JSON 数据 - 一个名称对应一个值</h3><p>JSON 数据格式为 键 / 值 对，就像 JavaScript 对象属性<br>键 / 值对包括字段名称（在双引号中），后面一个冒号，然后是值：<br><code>&quot;name&quot;:&quot;Nowcoder&quot;</code></p>
<h3 id="JSON-对象"><a href="#JSON-对象" class="headerlink" title="JSON 对象"></a>JSON 对象</h3><p>JSON 对象保存在大括号内<br>就像在 JavaScript 中, 对象可以保存多个 键 / 值 对：<br><code>{&quot;name&quot;:&quot;Nowcoder&quot;, &quot;url&quot;:&quot;www.nowcoder.com&quot;}</code></p>
<h3 id="JSON-数组"><a href="#JSON-数组" class="headerlink" title="JSON 数组"></a>JSON 数组</h3><p>JSON 数组保存在中括号内<br>就像在 JavaScript 中, 数组可以包含对象：</p>
<pre><code class="js">&quot;sites&quot;:[{&quot;name&quot;:&quot;Nowcoder&quot;, &quot;url&quot;:&quot;www.nowcoder.com&quot;},
    {&quot;name&quot;:&quot;Google&quot;, &quot;url&quot;:&quot;www.google.com&quot;},
    {&quot;name&quot;:&quot;Taobao&quot;, &quot;url&quot;:&quot;www.taobao.com&quot;}
]
在以上实例中，对象 &quot;sites&quot; 是一个数组，包含了三个对象
每个对象为站点的信息（网站名和网站地址）
</code></pre>
<h3 id="JSON-字符串转换为-Javascript-对象"><a href="#JSON-字符串转换为-Javascript-对象" class="headerlink" title="JSON 字符串转换为 Javascript 对象"></a>JSON 字符串转换为 Javascript 对象</h3><p>通常我们从服务器中读取 JSON 数据，并在网页中显示数据<br>简单起见，我们网页中直接设置 JSON 字符串：<br>首先，创建 JavaScript 字符串，字符串为 JSON 格式的数据：</p>
<pre><code class="js">var text = &#39;{&quot;sites&quot;: [&#39; +
    &#39;{&quot;name&quot;:&quot;Nowcoder&quot;,&quot;url&quot;:&quot;www.nowcoder.com&quot;},&#39; +
    &#39;{&quot;name&quot;:&quot;Google&quot;,&quot;url&quot;:&quot;www.google.com&quot;},&#39; +
    &#39;{&quot;name&quot;:&quot;Taobao&quot;,&quot;url&quot;:&quot;www.taobao.com&quot;} ]}&#39;;

obj = JSON.parse(text); // 内置函数 JSON.parse() 将字符串转换为 JavaScript 对象
document.getElementById(&quot;demo&quot;).innerHTML = obj.sites[1].name + &quot; &quot; + obj.sites[1].url;
</code></pre>
<hr>
<h2 id="JavaScript-void-0-含义"><a href="#JavaScript-void-0-含义" class="headerlink" title="JavaScript:void(0) 含义"></a>JavaScript:void(0) 含义</h2><p>javascript:void(0) 中最关键的是 void 关键字， void 是 JavaScript 中非常重要的关键字，该操作符指定要计算一个表达式但是不返回值</p>
<pre><code class="html">语法格式：
&lt;head&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
&lt;!--
void func()javascript:void func()

或者

void(func())
javascript:void(func())
//--&gt;
&lt;/script&gt;
&lt;/head&gt;

&lt;a href=&quot;javascript:void(0)&quot;&gt; 单击此处什么也不会发生 &lt;/a&gt;
// 当用户链接时，void(0) 计算为 0，但 Javascript 上没有任何效果

&lt;head&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
&lt;!--
//--&gt;
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;a href=&quot;javascript:void(alert(&#39;Warning!!!&#39;))&quot;&gt; 点我!&lt;/a&gt;
&lt;/body&gt;
// 在用户点击链接后显示警告信息

&lt;head&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
&lt;!--
function getValue(){
  var a,b,c;
  a = void (b = 5, c = 7);
  document.write(&#39;a =&#39; + a + &#39;b =&#39; + b +&#39;c =&#39; + c);
}
//--&gt;
&lt;/script&gt;
&lt;/head&gt;
// 参数 a 返回 undefined
</code></pre>
<h3 id="href-”-”-与-href-”javascript-void-0-”-的区别"><a href="#href-”-”-与-href-”javascript-void-0-”-的区别" class="headerlink" title="href=”#” 与 href=”javascript:void(0)” 的区别"></a>href=”#” 与 href=”javascript:void(0)” 的区别</h3><p># 包含了一个位置信息，默认的锚是 #top 也就是网页的上端<br>而 javascript:void(0), 仅仅表示一个死链接<br>在页面很长的时候会使用 # 来定位页面的具体位置，格式为：# + id<br>如果你要定义一个死链接请使用 javascript:void(0) </p>
<pre><code class="html">&lt;a href=&quot;javascript:void(0);&quot;&gt; 点我没有反应的!&lt;/a&gt;
&lt;a href=&quot;#pos&quot;&gt; 点我定位到指定位置!&lt;/a&gt;
&lt;br&gt;
...
&lt;br&gt;
&lt;p id=&quot;pos&quot;&gt; 尾部定位点 &lt;/p&gt;
</code></pre>
<hr>
<h2 id="JavaScript-代码规范"><a href="#JavaScript-代码规范" class="headerlink" title="JavaScript 代码规范"></a>JavaScript 代码规范</h2><p>所有的 JavaScript 项目都适用同一种规范</p>
<h3 id="JavaScript-代码规范-1"><a href="#JavaScript-代码规范-1" class="headerlink" title="JavaScript 代码规范"></a>JavaScript 代码规范</h3><p>代码规范通常包括以下几个方面：</p>
<ul>
<li>变量和函数的命名规则</li>
<li>空格，缩进，注释的使用规则</li>
<li>其他常用规范</li>
</ul>
<p>规范的代码更易于阅读与维护</p>
<h3 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h3><p>一般使用驼峰法来命名</p>
<pre><code class="js">firstName = &quot;John&quot;;
lastName = &quot;Doe&quot;;

price = 19.90;
tax = 0.20;

fullPrice = price + (price * tax);
</code></pre>
<h3 id="空格与运算符"><a href="#空格与运算符" class="headerlink" title="空格与运算符"></a>空格与运算符</h3><p>通常运算符（= + - * /）前后需要添加空格</p>
<h3 id="代码缩进"><a href="#代码缩进" class="headerlink" title="代码缩进"></a>代码缩进</h3><p>通常使用 4 个空格来缩进代码块</p>
<h3 id="语句规则"><a href="#语句规则" class="headerlink" title="语句规则"></a>语句规则</h3><p>简单语句</p>
<ul>
<li>一条语句通常以分号来作为结束符</li>
</ul>
<p>复杂语句</p>
<ul>
<li>将左花括号放在第一行的结尾</li>
<li>左花括号前添加一空格</li>
<li>将右花括号独立放在一行</li>
<li>不要以分号结束一个复杂的声明</li>
</ul>
<pre><code class="js">var values = [&quot;Volvo&quot;, &quot;Saab&quot;, &quot;Fiat&quot;];

var person = {
    firstName: &quot;John&quot;,
    lastName: &quot;Doe&quot;,
    age: 50,
    eyeColor: &quot;blue&quot;
};

function toCelsius(fahrenheit) {return (5 / 9) * (fahrenheit - 32);
}

for (i = 0; i &lt; 5; i++) {x += i;}

if (time &lt; 20) {greeting = &quot;Good day&quot;;} else {greeting = &quot;Good evening&quot;;}
</code></pre>
<h3 id="对象规则"><a href="#对象规则" class="headerlink" title="对象规则"></a>对象规则</h3><p>对象定义的规则：</p>
<ul>
<li>将左花括号与类名放在同一行</li>
<li>冒号与属性值间有个空格</li>
<li>字符串使用双引号，数字不需要</li>
<li>最后一个属性 - 值对后面不要添加逗号</li>
<li>将右花括号独立放在一行，并以分号作为结束符号</li>
</ul>
<pre><code class="js">var person = {
    firstName: &quot;John&quot;,
    lastName: &quot;Doe&quot;,
    age: 50,
    eyeColor: &quot;blue&quot;
};
//or
var person = {firstName:&quot;John&quot;, lastName:&quot;Doe&quot;, age:50, eyeColor:&quot;blue&quot;};
</code></pre>
<h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><p>一般很多代码语言的命名规则都是类似的，例如:</p>
<ul>
<li>变量和函数为小驼峰法标识, 即除第一个单词之外，其他单词首字母大写（ lowerCamelCase）</li>
<li>全局变量为大写 (UPPERCASE)</li>
<li>常量 (如 PI) 为大写 (UPPERCASE)</li>
</ul>
<p>HTML 和 CSS 的横杠 (-) 字符:<br>HTML5 属性可以以 data- (如：data-quantity, data-price) 作为前缀<br>CSS 使用 - 来连接属性名 (font-size)</p>
<ul>
<li>通常在 JavaScript 中被认为是减法，所以不允许使用</li>
</ul>
<p>下划线:<br>很多程序员比较喜欢使用下划线 (如：date_of_birth), 特别是在 SQL 数据库中<br>PHP 语言通常都使用下划线</p>
<p>帕斯卡拼写法 (PascalCase):<br>帕斯卡拼写法 (PascalCase) 在 C 语言中语言较多</p>
<p>驼峰法：<br>JavaScript 中通常推荐使用驼峰法，jQuery 及其他 JavaScript 库都使用驼峰法<br>变量名不要以 $ 作为开始标记，会与很多 JavaScript 库冲突</p>
<hr>
<h1 id="JS-函数"><a href="#JS-函数" class="headerlink" title="JS 函数"></a>JS 函数</h1><h2 id="JavaScript-函数定义"><a href="#JavaScript-函数定义" class="headerlink" title="JavaScript 函数定义"></a>JavaScript 函数定义</h2><p>JavaScript 使用关键字 function 定义函数<br>函数可以通过声明定义，也可以是一个表达式</p>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>函数声明后不会立即执行，会在我们需要的时候调用到</p>
<pre><code class="js">function functionName(parameters) {执行的代码}

function myFunction(a, b) {return a * b;}
</code></pre>
<h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><p>JavaScript 函数可以通过一个表达式定义<br>函数表达式可以存储在变量中</p>
<pre><code class="JavaScript">var x = function (a, b) {return a * b};

在函数表达式存储在变量后，变量也可作为一个函数使用：
var x = function (a, b) {return a * b};
var z = x(4, 3);

实际上，以上函数实际上是一个 匿名函数 (函数没有名称)
函数存储在变量中，不需要函数名称，通常通过变量名来调用
上述函数以分号结尾，因为它是一个执行语句
</code></pre>
<h3 id="Function-构造函数"><a href="#Function-构造函数" class="headerlink" title="Function() 构造函数"></a>Function() 构造函数</h3><p>函数通过关键字 function 定义<br>函数同样可以通过内置的 JavaScript 函数构造器（Function()）定义</p>
<pre><code class="JavaScript">var myFunction = new Function(&quot;a&quot;, &quot;b&quot;, &quot;return a * b&quot;);
var x = myFunction(4, 3);

// 等同于
var myFunction = function (a, b) {return a * b};
var x = myFunction(4, 3);
</code></pre>
<h3 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h3><p>提升（Hoisting）是 JavaScript 默认将当前作用域提升到前面去的的行为<br>提升（Hoisting）应用在变量的声明与函数的声明<br>因此，函数可以在声明之前调用：</p>
<pre><code class="JavaScript">myFunction(5);
function myFunction(y) {return y * y;}
使用表达式定义函数时无法提升
</code></pre>
<h3 id="自调用函数"><a href="#自调用函数" class="headerlink" title="自调用函数"></a>自调用函数</h3><p>函数表达式可以 “自调用”<br>自调用表达式会自动调用<br>如果表达式后面紧跟 () ，则会自动调用<br>不能自调用声明的函数<br>通过添加括号，来说明它是一个函数表达式：</p>
<pre><code class="JavaScript">(function () {var x = &quot;Hello!!&quot;;      // 我将调用自己})();
</code></pre>
<h3 id="函数可以作为一个值使用"><a href="#函数可以作为一个值使用" class="headerlink" title="函数可以作为一个值使用"></a>函数可以作为一个值使用</h3><p>JavaScript 函数作为一个值使用：</p>
<pre><code class="JavaScript">function myFunction(a, b) {return a * b;}

var x = myFunction(4, 3);
</code></pre>
<p>JavaScript 函数可作为表达式使用：</p>
<pre><code class="JavaScript">function myFunction(a, b) {return a * b;}

var x = myFunction(4, 3) * 2;
</code></pre>
<h3 id="函数是对象"><a href="#函数是对象" class="headerlink" title="函数是对象"></a>函数是对象</h3><p>在 JavaScript 中使用 typeof 操作符判断函数类型将返回 “function”<br>但是 JavaScript 函数描述为一个对象更加准确<br>JavaScript 函数有 属性 和 方法<br>arguments.length 属性返回函数调用过程接收到的参数个数</p>
<pre><code class="JavaScript">function myFunction(a, b) {return arguments.length;}
</code></pre>
<p>toString() 方法将函数作为一个字符串返回：</p>
<pre><code class="JavaScript">function myFunction(a, b) {return a * b;} 
var txt = myFunction.toString();

// 函数定义作为对象的属性，称之为对象方法
// 函数如果用于创建新的对象，称之为对象的构造函数
</code></pre>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>ES6 新增<br>箭头函数表达式的语法比普通函数表达式更简洁</p>
<pre><code class="JavaScript">(参数 1, 参数 2, …, 参数 N) =&gt; {函数声明}
(参数 1, 参数 2, …, 参数 N) =&gt; 表达式 (单一)
// 相当于：(参数 1, 参数 2, …, 参数 N) =&gt;{return 表达式;}

(单一参数) =&gt; {函数声明}
单一参数 =&gt; {函数声明}
// 只有一个参数

()=&gt; { 函数声明}
// 无参数

// ES5
var x = function(x, y) {return x * y;}
// ES6
const x = (x, y) =&gt; x * y;
</code></pre>
<p>有的箭头函数都没有自己的 this，不适合顶一个对象的方法<br>当我们使用箭头函数的时候，箭头函数会默认帮我们绑定外层 this 的值，所以在箭头函数中 this 的值和外层的 this 是一样的<br>箭头函数是不能提升的，所以需要在使用之前定义<br>使用 const 比使用 var 更安全，因为函数表达式始终是一个常量<br>如果函数部分只是一个语句，则可以省略 return 关键字和大括号 {}，这样做是一个比较好的习惯</p>
<pre><code class="JavaScript">const x = (x, y) =&gt; x * y;
// 等同于
const x = (x, y) =&gt; {return x * y};
</code></pre>
<hr>
<h2 id="JavaScript-函数参数"><a href="#JavaScript-函数参数" class="headerlink" title="JavaScript 函数参数"></a>JavaScript 函数参数</h2><p>JavaScript 函数对参数的值没有进行任何的检查</p>
<h3 id="函数显式参数-Parameters-与隐式参数-Arguments"><a href="#函数显式参数-Parameters-与隐式参数-Arguments" class="headerlink" title="函数显式参数 (Parameters) 与隐式参数 (Arguments)"></a>函数显式参数 (Parameters) 与隐式参数 (Arguments)</h3><p>函数显式参数在函数定义时列出<br>函数隐式参数在函数调用时传递给函数真正的值</p>
<pre><code class="JavaScript">functionName(parameter1, parameter2, parameter3) {// 要执行的代码……}
</code></pre>
<h3 id="参数规则"><a href="#参数规则" class="headerlink" title="参数规则"></a>参数规则</h3><p>JavaScript 函数定义显式参数时没有指定数据类型<br>JavaScript 函数对隐式参数没有进行类型检测<br>JavaScript 函数对隐式参数的个数没有进行检测</p>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>如果函数在调用时未提供隐式参数，参数会默认设置为： undefined<br>ES6 支持函数带有默认参数，就判断 undefined 和 || 的操作</p>
<pre><code class="JavaScript">function myFunction(x, y = 10) {
    // y is 10 if not passed or undefined
    return x + y;
}

myFunction(0, 2) // 输出 2
myFunction(5); // 输出 15, y 参数的默认值
</code></pre>
<h3 id="arguments-对象"><a href="#arguments-对象" class="headerlink" title="arguments 对象"></a>arguments 对象</h3><p>JavaScript 函数有个内置的对象 arguments 对象<br>argument 对象包含了函数调用的参数数组<br>通过这种方式可以很方便的找到最大的一个参数的值</p>
<pre><code class="JavaScript">x = findMax(1, 123, 500, 115, 44, 88);

function findMax(){var i, max = arguments[0];

    if(arguments.length &lt; 2) return max;

    for (i = 0; i &lt; arguments.length; i++) {if (arguments[i] &gt; max){max = arguments[i];
        }
    }
    return max;
}
</code></pre>
<p>或者创建一个函数用来统计所有数值的和：</p>
<pre><code class="JavaScript">x = sumAll(1, 123, 500, 115, 44, 88);

function sumAll() {
    var i, sum = 0;
    for (i = 0; i &lt; arguments.length; i++) {sum += arguments[i];
    }
    return sum;
}
</code></pre>
<h3 id="通过值传递参数"><a href="#通过值传递参数" class="headerlink" title="通过值传递参数"></a>通过值传递参数</h3><p>在函数中调用的参数是函数的隐式参数<br>JavaScript 隐式参数通过值来传递：函数仅仅只是获取值<br>如果函数修改参数的值，不会修改显式参数的初始值（在函数外定义）<br>隐式参数的改变在函数外是不可见的</p>
<h3 id="通过对象传递参数"><a href="#通过对象传递参数" class="headerlink" title="通过对象传递参数"></a>通过对象传递参数</h3><p>在 JavaScript 中，可以引用对象的值<br>因此我们在函数内部修改对象的属性就会修改其初始的值<br>修改对象属性可作用于函数外部（全局变量）<br>修改对象属性在函数外是可见的</p>
<hr>
<h2 id="JavaScript-函数调用"><a href="#JavaScript-函数调用" class="headerlink" title="JavaScript 函数调用"></a>JavaScript 函数调用</h2><p>JavaScript 函数有 4 种调用方式<br>每种方式的不同在于 this 的初始化</p>
<h3 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h3><p>一般而言，在 JavaScript 中，this 指向函数执行时的当前对象</p>
<h3 id="调用-JavaScript-函数"><a href="#调用-JavaScript-函数" class="headerlink" title="调用 JavaScript 函数"></a>调用 JavaScript 函数</h3><p>函数中的代码在函数被调用后执行</p>
<h3 id="作为一个函数调用"><a href="#作为一个函数调用" class="headerlink" title="作为一个函数调用 "></a>作为一个函数调用 </h3><pre><code class="JavaScript">function myFunction(a, b) {return a * b;}
myFunction(10, 2);           // myFunction(10, 2) 返回 20
</code></pre>
<p>以上函数不属于任何对象。但是在 JavaScript 中它始终是默认的全局对象<br>在 HTML 中默认的全局对象是 HTML 页面本身，所以函数是属于 HTML 页面<br>在浏览器中的页面对象是浏览器窗口 (window 对象)。以上函数会自动变为 window 对象的函数<br>myFunction()和 window.myFunction() 是一样的：</p>
<pre><code class="JavaScript">function myFunction(a, b) {return a * b;}
window.myFunction(10, 2);    // window.myFunction(10, 2) 返回 20
</code></pre>
<h3 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h3><p>当函数没有被自身的对象调用时 this 的值就会变成全局对象<br>在 web 浏览器中全局对象是浏览器窗口（window 对象）<br>该实例返回 this 的值是 window 对象：</p>
<pre><code class="JavaScript">function myFunction(){return this;}
myFunction();                // 返回 window 对象
// 函数作为全局对象调用，会使 this 的值成为全局对象
// 使用 window 对象作为一个变量容易造成程序崩溃
</code></pre>
<h3 id="函数作为方法调用"><a href="#函数作为方法调用" class="headerlink" title="函数作为方法调用"></a>函数作为方法调用</h3><p>在 JavaScript 中你可以将函数定义为对象的方法<br>以下实例创建了一个对象 (myObject), 对象有两个属性 (firstName 和 lastName), 及一个方法 (fullName)：</p>
<pre><code class="JavaScript">var myObject = {
    firstName:&quot;John&quot;,
    lastName: &quot;Doe&quot;,
    fullName: function (){return this.firstName + &quot; &quot; + this.lastName;}
}
myObject.fullName();         // 返回 &quot;John Doe&quot;
</code></pre>
<p>fullName 方法是一个函数，函数属于对象，myObject 是函数的所有者<br>this 对象，拥有 JavaScript 代码，实例中 this 的值为 myObject 对象<br>测试以下！修改 fullName 方法并返回 this 值：</p>
<pre><code class="JavaScript">var myObject = {
    firstName:&quot;John&quot;,
    lastName: &quot;Doe&quot;,
    fullName: function (){return this;}
}
myObject.fullName();          // 返回 [object Object] (所有者对象)
// 函数作为对象方法调用，会使得 this 的值成为对象本身
</code></pre>
<h3 id="使用构造函数调用函数"><a href="#使用构造函数调用函数" class="headerlink" title="使用构造函数调用函数"></a>使用构造函数调用函数</h3><p>如果函数调用前使用了 new 关键字, 则是调用了构造函数<br>这看起来就像创建了新的函数，但实际上 JavaScript 函数是重新创建的对象：</p>
<pre><code class="JavaScript">// 构造函数:
function myFunction(arg1, arg2) {
    this.firstName = arg1;
    this.lastName  = arg2;
}

// This    creates a new object
var x = new myFunction(&quot;John&quot;,&quot;Doe&quot;);
x.firstName;                             // 返回 &quot;John&quot;
// 构造函数的调用会创建一个新的对象。新对象会继承构造函数的属性和方法
// 构造函数中 this 关键字没有任何的值
//this 的值在函数调用实例化对象 (new object) 时创建
</code></pre>
<h3 id="作为函数方法调用函数"><a href="#作为函数方法调用函数" class="headerlink" title="作为函数方法调用函数"></a>作为函数方法调用函数</h3><p>在 JavaScript 中，函数是对象，JavaScript 函数有它的属性和方法<br>call()和 apply() 是预定义的函数方法，两个方法可用于调用函数，两个方法的第一个参数必须是对象本身</p>
<pre><code class="JavaScript">function myFunction(a, b) {return a * b;}
myObject = myFunction.call(myObject, 10, 2);     // 返回 20

function myFunction(a, b) {return a * b;}
myArray = [10, 2];
myObject = myFunction.apply(myObject, myArray);  // 返回 20
</code></pre>
<p>两个方法都使用了对象本身作为第一个参数，两者的区别在于第二个参数： apply 传入的是一个参数数组，也就是将多个参数组合成为一个数组传入，而 call 则作为 call 的参数传入（从第二个参数开始）<br>在 JavaScript 严格模式 (strict mode) 下, 在调用函数时第一个参数会成为 this 的值， 即使该参数不是一个对象<br>在 JavaScript 非严格模式 (non-strict mode) 下, 如果第一个参数的值是 null 或 undefined, 它将使用全局对象替代<br>通过 call()或 apply() 方法你可以设置 this 的值, 且作为已存在对象的新方法调用</p>
<hr>
<h2 id="JavaScript-闭包"><a href="#JavaScript-闭包" class="headerlink" title="JavaScript 闭包"></a>JavaScript 闭包</h2><p>JavaScript 变量可以是局部变量或全局变量<br>私有变量可以用到闭包</p>
<h3 id="全局变量-2"><a href="#全局变量-2" class="headerlink" title="全局变量"></a>全局变量</h3><p>函数可以访问由函数内部定义的变量</p>
<pre><code class="JavaScript">function myFunction() {
    var a = 4;
    return a * a;
}
</code></pre>
<p>函数也可以访问函数外部定义的变量</p>
<pre><code class="JavaScript">var a = 4;
function myFunction(){return a * a;}
</code></pre>
<p>后面一个实例中， a 是一个 全局 变量<br>在 web 页面中全局变量属于 window 对象<br>全局变量可应用于页面上的所有脚本<br>在第一个实例中， a 是一个 局部 变量<br>局部变量只能用于定义它函数内部，对于其他的函数或脚本代码是不可用的<br>全局和局部变量即便名称相同，它们也是两个不同的变量，修改其中一个，不会影响另一个的值<br>变量声明时如果不使用 var 关键字，那么它就是一个全局变量，即便它在函数内定义</p>
<h3 id="计数器困境"><a href="#计数器困境" class="headerlink" title="计数器困境"></a>计数器困境</h3><p>可以使用全局变量，函数设置计数器递增</p>
<pre><code class="JavaScript">var counter = 0;

function add(){return counter += 1;}

add();
add();
add();

// 计数器现在为 3
</code></pre>
<p>计数器数值在执行 add() 函数时发生变化<br>但问题来了，页面上的任何脚本都能改变计数器，即便没有调用 add() 函数<br>如果我在函数内声明计数器，如果没有调用函数将无法修改计数器的值：</p>
<pre><code class="JavaScript">function add() {
    var counter = 0;
    return counter += 1;
}

add();
add();
add();

// 本意是想输出 3, 但事与愿违，输出的都是 1 !
</code></pre>
<h3 id="JavaScript-内嵌函数"><a href="#JavaScript-内嵌函数" class="headerlink" title="JavaScript 内嵌函数"></a>JavaScript 内嵌函数</h3><p>所有函数都能访问全局变量<br>实际上，在 JavaScript 中，所有函数都能访问它们上一层的作用域<br>JavaScript 支持嵌套函数，嵌套函数可以访问上一层的函数变量<br>该实例中，内嵌函数 plus() 可以访问父函数的 counter 变量：</p>
<pre><code class="JavaScript">function add() {
    var counter = 0;
    function plus(){counter += 1;}
    plus();   
    return counter;
}
</code></pre>
<p>如果我们能在外部访问 plus() 函数，这样就能解决计数器的困境<br>我们同样需要确保 counter = 0 只执行一次<br>我们需要闭包</p>
<h3 id="JavaScript-闭包-1"><a href="#JavaScript-闭包-1" class="headerlink" title="JavaScript 闭包"></a>JavaScript 闭包</h3><p>自我调用</p>
<pre><code class="JavaScript">var add = (function () {
    var counter = 0;
    return function (){return counter += 1;}
})();

add();
add();
add();

// 计数器为 3
</code></pre>
<h3 id="实例解析"><a href="#实例解析" class="headerlink" title="实例解析"></a>实例解析</h3><p>变量 add 指定了函数自我调用的返回字值<br>自我调用函数只执行一次，设置计数器为 0，并返回函数表达式<br>add 变量可以作为一个函数使用，非常棒的部分是它可以访问函数上一层作用域的计数器<br>这个叫作 JavaScript 闭包，它使得函数拥有私有变量变成可能<br>计数器受匿名函数的作用域保护，只能通过 add 方法修改<br>闭包是一种保护私有变量的机制，在函数执行时形成私有的作用域，保护里面的私有变量不受外界干扰<br>直观的说就是形成一个不销毁的栈环境</p>
<hr>
<h1 id="JS-DOM"><a href="#JS-DOM" class="headerlink" title="JS DOM"></a>JS DOM</h1><h2 id="JavaScript-HTML-DOM-简介"><a href="#JavaScript-HTML-DOM-简介" class="headerlink" title="JavaScript HTML DOM 简介"></a>JavaScript HTML DOM 简介</h2><p>通过 HTML DOM，可访问 JavaScript HTML 文档的所有元素</p>
<h3 id="HTML-DOM（文档对象模型）"><a href="#HTML-DOM（文档对象模型）" class="headerlink" title="HTML DOM（文档对象模型）"></a>HTML DOM（文档对象模型）</h3><p>当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）<br>HTML DOM 模型被构造为对象的树：<br><img src="media/15859150613859/15861362970794.jpg" alt="-w517">通过可编程的对象模型，JavaScript 获得了足够的能力来创建动态的 HTML</p>
<ul>
<li>JavaScript 能够改变页面中的所有 HTML 元素</li>
<li>JavaScript 能够改变页面中的所有 HTML 属性</li>
<li>JavaScript 能够改变页面中的所有 CSS 样式</li>
<li>JavaScript 能够对页面中的所有事件作出反应</li>
</ul>
<h3 id="查找-HTML-元素"><a href="#查找-HTML-元素" class="headerlink" title="查找 HTML 元素"></a>查找 HTML 元素</h3><p>通常通过 JavaScript，操作 HTML 元素<br>必须首先找到元素</p>
<ul>
<li>通过 id getElementById</li>
<li>通过标签名 getElementByTagName</li>
<li>通过类名 getElementByClassName</li>
</ul>
<h3 id="通过-id-查找-HTML-元素"><a href="#通过-id-查找-HTML-元素" class="headerlink" title="通过 id 查找 HTML 元素"></a>通过 id 查找 HTML 元素</h3><p>在 DOM 中查找 HTML 元素的最简单的方法，是通过使用元素的 id</p>
<pre><code class="JavaScript">var x=document.getElementById(&quot;intro&quot;);
</code></pre>
<p>如果找到该元素，则该方法将以对象（在 x 中）的形式返回该元素<br>如果未找到该元素，则 x 将包含 null</p>
<h3 id="通过标签名查找-HTML-元素"><a href="#通过标签名查找-HTML-元素" class="headerlink" title="通过标签名查找 HTML 元素"></a>通过标签名查找 HTML 元素</h3><p>本例查找 id=”main” 的元素，然后查找 id=”main” 元素中的所有 </p><p> 元素：</p>
<pre><code class="JavaScript">var x=document.getElementById(&quot;main&quot;);
var y=x.getElementsByTagName(&quot;p&quot;);
</code></pre>
<h3 id="通过类名找到-HTML-元素"><a href="#通过类名找到-HTML-元素" class="headerlink" title="通过类名找到 HTML 元素"></a>通过类名找到 HTML 元素</h3><p>本例通过 getElementsByClassName 函数来查找 class=”intro” 的元素：</p>
<pre><code class="JavaScript">var x=document.getElementsByClassName(&quot;intro&quot;);
</code></pre>
<hr>
<h2 id="JavaScript-HTML-DOM-改变-HTML"><a href="#JavaScript-HTML-DOM-改变-HTML" class="headerlink" title="JavaScript HTML DOM - 改变 HTML"></a>JavaScript HTML DOM - 改变 HTML</h2><p>HTML DOM 允许 JavaScript 改变 HTML 元素的内容</p>
<h3 id="改变-HTML-输出流"><a href="#改变-HTML-输出流" class="headerlink" title="改变 HTML 输出流"></a>改变 HTML 输出流</h3><p>JavaScript 能够创建动态的 HTML 内容<br>在 JavaScript 中，<code>document.write()</code> 可用于直接向 HTML 输出流写内容</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;

&lt;script&gt;
document.write(Date());
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>绝对不要在文档 (DOM) 加载完成之后使用 document.write()，这会覆盖该文档</p>
<h3 id="改变-HTML-内容"><a href="#改变-HTML-内容" class="headerlink" title="改变 HTML 内容"></a>改变 HTML 内容</h3><p>修改 HTML 内容的最简单的方法是使用 <code>innerHTML</code> 属性</p>
<pre><code class="JavaScript">document.getElementById(id).innerHTML= 新的 HTML
</code></pre>
<pre><code class="html">&lt;html&gt;
&lt;body&gt;

&lt;p id=&quot;p1&quot;&gt;Hello World!&lt;/p&gt;

&lt;script&gt;
document.getElementById(&quot;p1&quot;).innerHTML=&quot;新文本!&quot;;
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;

&lt;h1 id=&quot;header&quot;&gt;Old Header&lt;/h1&gt;

&lt;script&gt;
var element=document.getElementById(&quot;header&quot;);
element.innerHTML=&quot;新标题&quot;;
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="改变-HTML-属性"><a href="#改变-HTML-属性" class="headerlink" title="改变 HTML 属性"></a>改变 HTML 属性</h3><p>语法</p>
<pre><code class="JavaScript">document.getElementById(id).attribute= 新属性值
</code></pre>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;

&lt;img id=&quot;image&quot; src=&quot;smiley.gif&quot;&gt;

&lt;script&gt;
document.getElementById(&quot;image&quot;).src=&quot;landscape.jpg&quot;;
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<hr>
<h2 id="JavaScript-HTML-DOM-改变-CSS"><a href="#JavaScript-HTML-DOM-改变-CSS" class="headerlink" title="JavaScript HTML DOM - 改变 CSS"></a>JavaScript HTML DOM - 改变 CSS</h2><p>HTML DOM 允许 JavaScript 改变 HTML 元素的样式</p>
<h3 id="改变-HTML-样式"><a href="#改变-HTML-样式" class="headerlink" title="改变 HTML 样式"></a>改变 HTML 样式</h3><p>语法</p>
<pre><code class="JavaScript">document.getElementById(id).style.property= 新样式
</code></pre>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt; 牛客教程 (nowcoder.com)&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;p id=&quot;p1&quot;&gt;Hello World!&lt;/p&gt;
    &lt;p id=&quot;p2&quot;&gt;Hello World!&lt;/p&gt;
    &lt;script&gt;
        document.getElementById(&quot;p2&quot;).style.color=&quot;blue&quot;;
        document.getElementById(&quot;p2&quot;).style.fontFamily=&quot;Arial&quot;;
        document.getElementById(&quot;p2&quot;).style.fontSize=&quot;larger&quot;;
    &lt;/script&gt;
    &lt;p&gt; 以上段落通过脚本修改。&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="使用事件"><a href="#使用事件" class="headerlink" title="使用事件"></a>使用事件</h3><p>HTML DOM 允许我们通过触发事件来执行代码</p>
<ul>
<li>元素被点击</li>
<li>页面加载完成</li>
<li>输入框被修改</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;

&lt;h1 id=&quot;id1&quot;&gt; 我的标题 1&lt;/h1&gt;
&lt;button type=&quot;button&quot;
onclick=&quot;document.getElementById(&#39;id1&#39;).style.color=&#39;red&#39;&quot;&gt;
点我!&lt;/button&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<hr>
<h2 id="JavaScript-HTML-DOM-事件"><a href="#JavaScript-HTML-DOM-事件" class="headerlink" title="JavaScript HTML DOM 事件"></a>JavaScript HTML DOM 事件</h2><p>HTML DOM 使 JavaScript 有能力对 HTML 事件做出反应</p>
<h3 id="对事件做出反应"><a href="#对事件做出反应" class="headerlink" title="对事件做出反应"></a>对事件做出反应</h3><p>我们可以在事件发生时执行 JavaScript，比如当用户在 HTML 元素上点击时<br>如需在用户点击某个元素时执行代码，请向一个 HTML 事件属性添加 JavaScript 代码：<br><code>onclick = JavaScript</code><br>HTML 事件的例子：</p>
<ul>
<li>当用户点击鼠标</li>
<li>当网页已加载</li>
<li>当图像已加载</li>
<li>当鼠标移动到元素上</li>
<li>当输入字段被改变</li>
<li>当提交 HTML 表单</li>
<li>当用户触发按键</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
&lt;h1 onclick=&quot;this.innerHTML=&#39;Ooops!&#39;&quot;&gt; 点击文本!&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;script&gt;
function changetext(id) {id.innerHTML=&quot;Ooops!&quot;;}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1 onclick=&quot;changetext(this)&quot;&gt; 点击文本!&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="HTML-事件属性"><a href="#HTML-事件属性" class="headerlink" title="HTML 事件属性"></a>HTML 事件属性</h3><p>如需向 HTML 元素分配事件，可以使用事件属性</p>
<pre><code class="html">&lt;button onclick=&quot;displayDate()&quot;&gt; 点这里 &lt;/button&gt;
// 在上面的例子中，名为 displayDate 的函数将在按钮被点击时执行
</code></pre>
<h3 id="使用-HTML-DOM-来分配事件"><a href="#使用-HTML-DOM-来分配事件" class="headerlink" title="使用 HTML DOM 来分配事件"></a>使用 HTML DOM 来分配事件</h3><p>HTML DOM 允许使用 JavaScript 来向 HTML 元素分配事件</p>
<pre><code class="html">&lt;script&gt;
    document.getElementById(&quot;myBtn&quot;).onclick=function(){displayDate()};
&lt;/script&gt;
// 在上面的例子中，名为 displayDate 的函数被分配给 id=&quot;myBtn&quot; 的 HTML 元素
按钮点击时 Javascript 函数将会被执行
</code></pre>
<h3 id="onload-和-onunload-事件"><a href="#onload-和-onunload-事件" class="headerlink" title="onload 和 onunload 事件"></a>onload 和 onunload 事件</h3><p>onload 和 onunload 事件会在用户进入或离开页面时被触发<br>onload 事件可用于检测访问者的浏览器类型和浏览器版本，并基于这些信息来加载网页的正确版本<br>onload 和 onunload 事件可用于处理 cookie</p>
<pre><code class="html">&lt;body onload = &quot;checkCookies()&quot;
</code></pre>
<h3 id="onchange-事件"><a href="#onchange-事件" class="headerlink" title="onchange 事件"></a>onchange 事件</h3><p>onchange 事件常结合对输入字段的验证来使用<br>下面是一个如何使用 onchange 的例子，当用户改变输入字段的内容时，会调用 upperCae() 函数</p>
<pre><code class="html">&lt;input type = &quot;text&quot; id = &quot;fname&quot; onchange = &quot;upperCase()&quot;&gt;
</code></pre>
<h3 id="onmouseover-和-onmouseout-事件"><a href="#onmouseover-和-onmouseout-事件" class="headerlink" title="onmouseover 和 onmouseout 事件"></a>onmouseover 和 onmouseout 事件</h3><p>onmouseover 和 onmouseout 事件可用于在用户的鼠标移动至 HTMl 元素上方或者移动出元素时触发函数</p>
<pre><code class="html">&lt;div onmouseover = &quot;mOver(this)&quot; onmouseout = &quot;mOut(this)&quot;&gt;Mouse Over Me&lt;/div&gt;
</code></pre>
<h3 id="onmousedown、onmouseup-以及-onclick-事件"><a href="#onmousedown、onmouseup-以及-onclick-事件" class="headerlink" title="onmousedown、onmouseup 以及 onclick 事件"></a>onmousedown、onmouseup 以及 onclick 事件</h3><p>onmousedownm，onmouseup 以及 onclick 构成了鼠标点击事件的所有部分，首先当点击鼠标摁钮时，会触发 onmousedown 事件，当释放鼠标摁钮时，会触发 onmouseup 事件，最后，当完成鼠标点击时，会触发 onclick 事件</p>
<hr>
<h2 id="JavaScript-HTML-DOM-EventListener"><a href="#JavaScript-HTML-DOM-EventListener" class="headerlink" title="JavaScript HTML DOM EventListener"></a>JavaScript HTML DOM EventListener</h2><h3 id="addEventListener-方法"><a href="#addEventListener-方法" class="headerlink" title="addEventListener() 方法"></a>addEventListener() 方法</h3><hr>
<p>title: JavaScript 基础汇总<br>date: 2020-04-03 17:10:48<br>tags:</p>
<ul>
<li>前端</li>
<li>面试<br>categories: </li>
<li>面试汇总</li>
</ul>
<hr>
<h1 id="JS-基础-1"><a href="#JS-基础-1" class="headerlink" title="JS 基础"></a>JS 基础</h1><!--more-->
<h2 id="JavaScript-简介-1"><a href="#JavaScript-简介-1" class="headerlink" title="JavaScript 简介"></a>JavaScript 简介</h2><p>JavaScript 是一种轻量级的编程脚本语言<br>ECMA-262 是 JavaScript 标准的官方名称<br>JavaScript 由 Brendan Eich 发明，它于 1995 年出现在 Netscape 中，并于 1997 年被 ECMA 采纳（一个标准协会）</p>
<hr>
<h2 id="JavaScript-用法-1"><a href="#JavaScript-用法-1" class="headerlink" title="JavaScript 用法"></a>JavaScript 用法</h2><h3 id="内部用法-1"><a href="#内部用法-1" class="headerlink" title="内部用法"></a>内部用法</h3><p>HTML 中的脚本必须位于 <code>&lt;script&gt; &lt;/script&gt;</code> 之间<br>脚本可被放置在 HTML 页面的 <code>&lt;body&gt; &lt;head&gt;</code> 部分中</p>
<h3 id="外部用法-1"><a href="#外部用法-1" class="headerlink" title="外部用法"></a>外部用法</h3><p>如需使用外部 JS 文件，请在 <code>&lt;script&gt;&lt;/script&gt;</code> 标签的 ‘src’ 属性中引入</p>
<hr>
<h2 id="JavaScript-输出-1"><a href="#JavaScript-输出-1" class="headerlink" title="JavaScript 输出"></a>JavaScript 输出</h2><p>JavaScript 没有任何打印或者输出的函数<br>JavaScript 可以通过不同的方式来输出数据：</p>
<ul>
<li>使用 <code>window.alert()</code> 弹出警告框</li>
<li>使用 <code>document.write()</code> 将内容写入 HTML 文档中</li>
<li>使用 <code>innerHTML</code> 写入到 HTML 元素</li>
<li>使用 <code>console.log()</code> 写入浏览器控制台</li>
<li>使用 <code>document.getElementById(id)</code> 来访问某个 HTML 元素，使用 ‘id’ 属性来标识 HTML 元素，并 <code>innerHTML</code> 来获取或者插入内容</li>
</ul>
<hr>
<h2 id="JavaScript-语法-1"><a href="#JavaScript-语法-1" class="headerlink" title="JavaScript 语法"></a>JavaScript 语法</h2><p>JavaScript 是一个程序语言，语法规则定义了语言结构</p>
<h3 id="JavaScript-字面量-1"><a href="#JavaScript-字面量-1" class="headerlink" title="JavaScript 字面量"></a>JavaScript 字面量</h3><p>在编程语言中，一般固定值成为字面量</p>
<ul>
<li>数字 <code>Number</code> 可以是整数或者小数或是科学计数<br>  <code>123 3.14</code></li>
<li>字符串 <code>String</code> 可以使用单引号或双引号<br>  <code>&quot;jack&quot; &#39;jack&#39;</code></li>
<li>数组 <code>Array</code> 定义一个数组<br>  <code>[20,3004,32,230]</code></li>
<li>对象 <code>Object</code> 定义一个对象<br>  <code>{firstName:&quot;jack&quot;,lastName:&quot;doe&quot;,age:40}</code></li>
<li>函数 <code>Function</code> 定义一个函数<br>  <code>function myFunction(a,b){return a+b}</code></li>
</ul>
<h3 id="JavaScript-变量-1"><a href="#JavaScript-变量-1" class="headerlink" title="JavaScript 变量"></a>JavaScript 变量</h3><p>编程语言中，变量用于存储数据值<br>JavaScript 使用关键字 <code>var</code> 来定义变量，使用 <code>=</code> 来为变量赋值</p>
<pre><code class="JavaScript">var x, length
x = 5
length = 6
</code></pre>
<p>变量可以通过变量名访问，通常可变，字面量是一个恒定的值<br>变量是一个名称，字面量是一个值</p>
<h3 id="JavaScript-操作符-1"><a href="#JavaScript-操作符-1" class="headerlink" title="JavaScript 操作符"></a>JavaScript 操作符</h3><p>JavaScript 使用算术运算符来计算值</p>
<pre><code class="JavaScript">(5+6)*10
</code></pre>
<p>JavaScript 使用赋值运算符给变量赋值</p>
<pre><code class="JavaScript">x = 5
y = 6
z = (x+y)*10
</code></pre>
<p>JavaScript 语言有多种类型运算符：</p>
<ul>
<li>赋值，算术和位运算符<br>  <code>= + - * /</code></li>
<li>条件，比较和逻辑运算符<br>  <code>== != &lt; &gt;</code></li>
</ul>
<h3 id="JavaScript-语句-2"><a href="#JavaScript-语句-2" class="headerlink" title="JavaScript 语句"></a>JavaScript 语句</h3><p>在 HTML 中，JavaScript 语句向浏览器发出的命令用分号分隔</p>
<pre><code class="JavaScript">x = 5 + 6
y = x * 5
</code></pre>
<h3 id="JavaScript-关键字-1"><a href="#JavaScript-关键字-1" class="headerlink" title="JavaScript 关键字"></a>JavaScript 关键字</h3><table>
<thead>
<tr>
<th style="text-align:center">abstract</th>
<th style="text-align:center">else</th>
<th style="text-align:center">instanceof</th>
<th style="text-align:center">super</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">enum</td>
<td style="text-align:center">int</td>
<td style="text-align:center">switch</td>
</tr>
<tr>
<td style="text-align:center">break</td>
<td style="text-align:center">export</td>
<td style="text-align:center">interface</td>
<td style="text-align:center">synchronized</td>
</tr>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">extends</td>
<td style="text-align:center">let</td>
<td style="text-align:center">this</td>
</tr>
<tr>
<td style="text-align:center">case</td>
<td style="text-align:center">false</td>
<td style="text-align:center">long</td>
<td style="text-align:center">throw</td>
</tr>
<tr>
<td style="text-align:center">catch</td>
<td style="text-align:center">final</td>
<td style="text-align:center">native</td>
<td style="text-align:center">throws</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">finally</td>
<td style="text-align:center">new</td>
<td style="text-align:center">transient</td>
</tr>
<tr>
<td style="text-align:center">class</td>
<td style="text-align:center">float</td>
<td style="text-align:center">null</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center">const</td>
<td style="text-align:center">for</td>
<td style="text-align:center">package</td>
<td style="text-align:center">try</td>
</tr>
<tr>
<td style="text-align:center">continue</td>
<td style="text-align:center">function</td>
<td style="text-align:center">private</td>
<td style="text-align:center">typeof</td>
</tr>
<tr>
<td style="text-align:center">debugger</td>
<td style="text-align:center">goto</td>
<td style="text-align:center">protected</td>
<td style="text-align:center">var</td>
</tr>
<tr>
<td style="text-align:center">default</td>
<td style="text-align:center">if</td>
<td style="text-align:center">public</td>
<td style="text-align:center">void</td>
</tr>
<tr>
<td style="text-align:center">delete</td>
<td style="text-align:center">implements</td>
<td style="text-align:center">return</td>
<td style="text-align:center">volatile</td>
</tr>
<tr>
<td style="text-align:center">do</td>
<td style="text-align:center">import</td>
<td style="text-align:center">short</td>
<td style="text-align:center">while</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">in</td>
<td style="text-align:center">static</td>
<td style="text-align:center">with</td>
</tr>
</tbody>
</table>
<h3 id="JavaScript-注释-2"><a href="#JavaScript-注释-2" class="headerlink" title="JavaScript 注释"></a>JavaScript 注释</h3><p>双斜杠 <code>//</code> 后的内容会被浏览器忽略</p>
<h3 id="JavaScript-数据类型-4"><a href="#JavaScript-数据类型-4" class="headerlink" title="JavaScript 数据类型"></a>JavaScript 数据类型</h3><pre><code class="JavaScript">var length = 16;                                  // Number 通过数字字面量赋值
var points = x * 10;                              // Number 通过表达式字面量赋值
var lastName = &quot;Johnson&quot;;                         // String 通过字符串字面量赋值
var cars = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;];              // Array  通过数组字面量赋值
var person = {firstName:&quot;John&quot;, lastName:&quot;Doe&quot;};  // Object 通过对象字面量赋值
</code></pre>
<h3 id="JavaScript-字符集-1"><a href="#JavaScript-字符集-1" class="headerlink" title="JavaScript 字符集"></a>JavaScript 字符集</h3><p>JavaScript 使用 Unicode 字符集</p>
<hr>
<h2 id="JavaScript-语句-3"><a href="#JavaScript-语句-3" class="headerlink" title="JavaScript 语句"></a>JavaScript 语句</h2><p>JavaScript 语句向浏览器发出命令告诉浏览器该做什么<br>下面的 JavaScript 语句向 id=”demo” 的 HTML 元素输出文本 “你好 Dolly” ：</p>
<pre><code class="JavaScript">document.getElementById(&quot;demo&quot;).innerHTML = &quot;你好 Dolly&quot;
</code></pre>
<h3 id="分号-1"><a href="#分号-1" class="headerlink" title="分号"></a>分号</h3><p>分号用于分隔 JavaScript 语句</p>
<pre><code class="JavaScript">a = 5;
b = 6;
c = a + b;
// 或
a = 5; b = 6; c = a + b;
</code></pre>
<h3 id="JavaScript-代码-1"><a href="#JavaScript-代码-1" class="headerlink" title="JavaScript 代码"></a>JavaScript 代码</h3><p>JavaScript 代码是 JavaScript 语句的序列<br>浏览器按照便携顺序依次执行每条语句</p>
<pre><code class="JavaScript">document.getElementById(&quot;demo&quot;).innerHTML = &quot;hello Dolly&quot;
document.getElementById(&quot;myDiv&quot;).innerHTML = &quot;how are you&quot;
</code></pre>
<h3 id="JavaScript-代码块-1"><a href="#JavaScript-代码块-1" class="headerlink" title="JavaScript 代码块"></a>JavaScript 代码块</h3><p>JavaScript 可以分批地组合起来<br>代码块以左花括号开始，以右花括号结束<br>代码块的作用是一并地执行语句序列</p>
<pre><code class="JavaScript">function myFunciton(){document.getElementById(&quot;demo&quot;).innerHTML = &quot;hello Dolly&quot;
    document.getElementById(&quot;myDiv&quot;).innerHTML = &quot;how are you&quot;
}
</code></pre>
<h3 id="JavaScript-语句标识符-1"><a href="#JavaScript-语句标识符-1" class="headerlink" title="JavaScript 语句标识符"></a>JavaScript 语句标识符</h3><p>JavaScript 语句通常以一个 语句标识符 为开始，并执行该语句<br>语句标识符是保留关键字不能作为变量名使用</p>
<table>
<thead>
<tr>
<th style="text-align:center">语句</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">break</td>
<td style="text-align:center">用于跳出循环</td>
</tr>
<tr>
<td style="text-align:center">catch</td>
<td style="text-align:center">语句块，在 try 语句块执行出错时执行 catch 语句块</td>
</tr>
<tr>
<td style="text-align:center">continue</td>
<td style="text-align:center">跳出循环中的一个迭代</td>
</tr>
<tr>
<td style="text-align:center">do…while</td>
<td style="text-align:center">执行一个语句块，在条件语句为 true 时继续执行该语句块</td>
</tr>
<tr>
<td style="text-align:center">for</td>
<td style="text-align:center">在条件语句为 true 时，可以将代码块执行指定的次数</td>
</tr>
<tr>
<td style="text-align:center">for…in</td>
<td style="text-align:center">用于遍历数组或者对象的属性（对数组或者对象的属性进行循环操作）</td>
</tr>
<tr>
<td style="text-align:center">function</td>
<td style="text-align:center">定义一个函数</td>
</tr>
<tr>
<td style="text-align:center">if…else</td>
<td style="text-align:center">用于基于不同的条件来执行不同的动作</td>
</tr>
<tr>
<td style="text-align:center">return</td>
<td style="text-align:center">退出函数</td>
</tr>
<tr>
<td style="text-align:center">switch</td>
<td style="text-align:center">用于基于不同的条件来执行不同的动作</td>
</tr>
<tr>
<td style="text-align:center">throw</td>
<td style="text-align:center">抛出（生成）错误</td>
</tr>
<tr>
<td style="text-align:center">try</td>
<td style="text-align:center">实现错误处理，与 catch 一同使用</td>
</tr>
<tr>
<td style="text-align:center">var</td>
<td style="text-align:center">声明一个变量</td>
</tr>
<tr>
<td style="text-align:center">while</td>
<td style="text-align:center">当条件语句为 true 时，执行语句块</td>
</tr>
</tbody>
</table>
<h3 id="空格-1"><a href="#空格-1" class="headerlink" title="空格"></a>空格</h3><p>JavaScript 会忽略多余的空格，可以向脚本添加空格，来提高其可读性</p>
<pre><code class="JavaScript">var person=&quot;Jack&quot;
var person = &quot;Jack&quot;
</code></pre>
<h3 id="对代码进行折行-1"><a href="#对代码进行折行-1" class="headerlink" title="对代码进行折行"></a>对代码进行折行</h3><p>可以在文本字符串中使用反斜杠对代码进行换行</p>
<pre><code class="JavaScript">document.write(&quot;你好 \n 世界!&quot;)
</code></pre>
<hr>
<h2 id="JavaScript-注释-3"><a href="#JavaScript-注释-3" class="headerlink" title="JavaScript 注释"></a>JavaScript 注释</h2><p>JavaScript 注释可用于提高代码可读性<br>JavaScript 不会执行注释</p>
<h3 id="JavaScript-单行注释-1"><a href="#JavaScript-单行注释-1" class="headerlink" title="JavaScript 单行注释"></a>JavaScript 单行注释</h3><p>单行注释以 <code>//</code> 开头</p>
<pre><code class="JavaScript">// 输出标题
document.getElementById(&quot;myH1&quot;).innerHTML = &quot;欢迎来到我的主页&quot;
// 输出段落
document.getElementById(&quot;myP&quot;).innerHTML = &quot;这是我的第一个段落&quot;
</code></pre>
<h3 id="JavaScript-多行注释-1"><a href="#JavaScript-多行注释-1" class="headerlink" title="JavaScript 多行注释"></a>JavaScript 多行注释</h3><p>多行注释以 <code>/*</code> 开始，以 <code>*/</code> 结尾</p>
<pre><code class="JavaScript">/*
下面的代码会输出
一个标题和
一个段落
*/
document.getElementById(&quot;myH1&quot;).innerHTML = &quot;欢迎来到我的主页&quot;
document.getElementById(&quot;myP&quot;).innerHTML = &quot;这是我的第一个段落&quot;
</code></pre>
<hr>
<p>##JavaScript 变量<br>变量是用于存储信息的“容器”</p>
<pre><code class="JavaScript">var x = 5
var y = 6
var z = x+y
</code></pre>
<p>变量可以使用短名称（x，y），也可以使用描述性更好的名称（age，sum）</p>
<ul>
<li>变量必须以字母开头</li>
<li>变量也能以 $ 和 _ 符号开头</li>
<li>变量名称对大小写敏感<br>JavaScript 语句和 JavaScript 变量都对大小写敏感</li>
</ul>
<h3 id="JavaScript-数据类型-5"><a href="#JavaScript-数据类型-5" class="headerlink" title="JavaScript 数据类型"></a>JavaScript 数据类型</h3><p>JavaScript 变量还能保存其他数据类型，比如文本值（name=”bill”)<br>在 JavaScript 中，类似“bill”这样一条文本被称为字符串<br>向变量分配文本值时，应该用双引号或单引号包围这个值<br>赋值为数值时，不要使用引号，不然会被当文本来处理</p>
<pre><code class="JavaScript">var pi = 3.14
var person = &quot;john doe&quot;
var answer = &quot;yes I am&quot;
</code></pre>
<h3 id="声明（创建）JavaScript-变量-1"><a href="#声明（创建）JavaScript-变量-1" class="headerlink" title="声明（创建）JavaScript 变量"></a>声明（创建）JavaScript 变量</h3><p>在 JavaScript 中创建变量通常称为“声明”变量<br>使用 <code>var</code> 关键词来声明变量</p>
<pre><code class="JavaScript">var carname
</code></pre>
<p>变量声明之后，该变量是空的（没有值）<br>如需向变量赋值，则需要使用等号</p>
<pre><code class="JavaScript">carname = &quot;volvo&quot;
</code></pre>
<p>不过，也可以在声明变量时就赋值</p>
<pre><code class="JavaScript">var carname = &quot;volvo&quot;
</code></pre>
<h3 id="一条语句，多个变量-1"><a href="#一条语句，多个变量-1" class="headerlink" title="一条语句，多个变量"></a>一条语句，多个变量</h3><p>可以在一条语句中声明多个变量，以 <code>var</code> 开头，并用逗号分隔</p>
<pre><code class="JavaScript">var name = &quot;Doe&quot;, age = &quot;30&quot;, job = &quot;teacher&quot;
// 也可以横跨多行
var name = &quot;Doe&quot;,
age = &quot;30&quot;,
job = &quot;teacher&quot;
</code></pre>
<p>一条语句声明的多个不可以赋同一个值</p>
<pre><code class="JavaScript">var x,y,z=1
//x,y 为 undefined，z 为 1
</code></pre>
<h3 id="Value-undefined-1"><a href="#Value-undefined-1" class="headerlink" title="Value=undefined"></a>Value=undefined</h3><p>未使用值来声明的变量，其值为 undefined</p>
<h3 id="重新声明-JavaScript-变量-1"><a href="#重新声明-JavaScript-变量-1" class="headerlink" title="重新声明 JavaScript 变量"></a>重新声明 JavaScript 变量</h3><p>如果重新声明 JavaScript 变量，该变量的值不会丢失</p>
<pre><code class="JavaScript">var x = &quot;xxx&quot;
var x
//x 的值依然为“xxx”
</code></pre>
<hr>
<h2 id="JavaScript-数据类型-6"><a href="#JavaScript-数据类型-6" class="headerlink" title="JavaScript 数据类型"></a>JavaScript 数据类型</h2><p>值类型（基本类型）：</p>
<ul>
<li>字符串 String</li>
<li>数字 Number</li>
<li>布尔 Boolean</li>
<li>空 Null</li>
<li>未定义 undefined</li>
<li>唯一值 Symbol</li>
</ul>
<p>引入数据类型：</p>
<ul>
<li>对象 Object</li>
<li>数组 Array</li>
<li>函数 Function</li>
</ul>
<h3 id="JavaScript-拥有动态类型-1"><a href="#JavaScript-拥有动态类型-1" class="headerlink" title="JavaScript 拥有动态类型"></a>JavaScript 拥有动态类型</h3><p>意味着相同的变量可用作不同的类型</p>
<pre><code class="JavaScript">var x   //x 为 undefined
var x = 5   //x 为数字
var x = &#39;Jk&quot;    //x 为字符串
</code></pre>
<h3 id="JavaScript-字符串-String-1"><a href="#JavaScript-字符串-String-1" class="headerlink" title="JavaScript 字符串 String"></a>JavaScript 字符串 String</h3><p>字符串是存储字符（如“Jack”）的变量<br>字符串可以是引号内的任意文本，单引号或双引号</p>
<pre><code class="JavaScript">var name = &quot;Jack 80D&quot;
var add = &quot;shanxi&#39;linfen&#39;&quot;
</code></pre>
<h3 id="JavaScript-数字-Number-1"><a href="#JavaScript-数字-Number-1" class="headerlink" title="JavaScript 数字 Number"></a>JavaScript 数字 Number</h3><p>JavaScript 只有一种数字类型，可以带小数点或是科学计数法</p>
<pre><code class="JavaScript">var x = 123
var y = 3.14
var z = 123e5
</code></pre>
<h3 id="JavaScript-布尔-Boolean-1"><a href="#JavaScript-布尔-Boolean-1" class="headerlink" title="JavaScript 布尔 Boolean"></a>JavaScript 布尔 Boolean</h3><p>布尔（逻辑）只有两个值，<code>true/false</code></p>
<h3 id="JavaScript-数组-Array-1"><a href="#JavaScript-数组-Array-1" class="headerlink" title="JavaScript 数组 Array"></a>JavaScript 数组 Array</h3><p>数组的下标是基于零的，所以第一个项目是 [0]，第二个是 [1]，以此类推</p>
<pre><code class="JavaScript">var x = new Array()x[0] = &quot;y&quot;
x[1] = &quot;h&quot;
x[2] = &quot;h&quot;
//or
var x = new Array(&quot;y&quot;,&quot;h&quot;,&quot;h&quot;)
//or
var x = [&quot;y&quot;,&quot;h&quot;,&quot;h&quot;]
</code></pre>
<h3 id="JavaScript-对象-Object-1"><a href="#JavaScript-对象-Object-1" class="headerlink" title="JavaScript 对象 Object"></a>JavaScript 对象 Object</h3><p>对象由花括号分隔，在括号内部，对象的属性以名称和值的形式 <code>name：value</code> 来定义，属性由逗号分隔</p>
<pre><code class="JavaScript">var person = {
    name: &quot;Yhh&quot;,
    age: &quot;18&quot;,
    id: 7281
}
// 两种寻址方式
name = person.name
name = person[&quot;name&quot;]
</code></pre>
<h3 id="undefined-和-Null-1"><a href="#undefined-和-Null-1" class="headerlink" title="undefined 和 Null"></a>undefined 和 Null</h3><p>undefined 表示变量不含有值<br>可以通过将变量的值设为 null 来清空变量</p>
<h3 id="声明变量类型-1"><a href="#声明变量类型-1" class="headerlink" title="声明变量类型"></a>声明变量类型</h3><p>可以使用关键词 <code>new</code> 来声明类型</p>
<pre><code class="JavaScript">var name = new String
var x = new Number
var y = new Boolean
var z = new Array
var i = new Object
</code></pre>
<p>JavaScript 变量均为对象，当声明一个变量时，就创建了一个新的对象</p>
<hr>
<h2 id="JavaScript-对象-2"><a href="#JavaScript-对象-2" class="headerlink" title="JavaScript 对象"></a>JavaScript 对象</h2><p>JavaScript 对象是拥有属性和方法的数据</p>
<h3 id="真是生活中的对象，属性，方法-1"><a href="#真是生活中的对象，属性，方法-1" class="headerlink" title="真是生活中的对象，属性，方法"></a>真是生活中的对象，属性，方法</h3><p>真实生活中，一辆汽车是一个对象<br>对象有它的属性，如重量颜色，方法有启动停止</p>
<table>
<thead>
<tr>
<th style="text-align:center">对象</th>
<th style="text-align:center">属性</th>
<th style="text-align:center">方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">car</td>
<td style="text-align:center">car.name = fiat<br>car.model = 500<br>car.weight = 800kg<br></td>
<td style="text-align:center">car.start()<br>car.brake()<br>car.stop()</td>
</tr>
</tbody>
</table>
<h3 id="JavaScript-对象-3"><a href="#JavaScript-对象-3" class="headerlink" title="JavaScript 对象"></a>JavaScript 对象</h3><p>JavaScript 对象是变量的容器</p>
<pre><code class="JavaScript">var car = &quot;fiat&quot;
//or
var car = {
    type: &quot;fiat&quot;,
    model: 500,
    color: &quot;white&quot;
}
</code></pre>
<h3 id="对象属性-1"><a href="#对象属性-1" class="headerlink" title="对象属性"></a>对象属性</h3><p>JavaScript 对象是变量的容器 ===JavaScript 对象是键值对的容器<br>键值对通常写法为 <code>name：value</code>（键 冒号 值）<br>键值对在 JavaScript 对象称为 对象属性<br>对象键值对的写法类似于：</p>
<ul>
<li>PHP 中的关联数组</li>
<li>Python 中的字典</li>
<li>C 语言中的哈希表</li>
<li>Java 中的哈希映射</li>
<li>Ruby 和 Perl 中的哈希表</li>
</ul>
<h3 id="访问对象属性-1"><a href="#访问对象属性-1" class="headerlink" title="访问对象属性"></a>访问对象属性</h3><p>两种方式</p>
<pre><code class="JavaScript">car.type
//or
car[&quot;type&quot;]
</code></pre>
<h3 id="对象方法-1"><a href="#对象方法-1" class="headerlink" title="对象方法"></a>对象方法</h3><p>对象的方法定义了一个函数，并作为对象的属性存储<br>对象方法通过添加（）调用</p>
<pre><code class="JavaScript">var person = {
    firstName: &quot;John&quot;,
    lastName: &quot;Doe&quot;,
    id: 5566,
    fullName: function (){return this.firstName + &quot; &quot; + this.lastName;}
};
person.fullName //function (){return this.firstName + &quot; &quot; + this.lastName;}
person.fullName() //John Doe
不加括号输出函数表达式
加括号输出函数执行结果
</code></pre>
<hr>
<h2 id="JavaScript-函数-1"><a href="#JavaScript-函数-1" class="headerlink" title="JavaScript 函数"></a>JavaScript 函数</h2><p>函数是由事件驱动的或者当它被调用时执行的可重复使用的代码块</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt; 测试实例 &lt;/title&gt;
    &lt;script&gt;
        function myFunction(){alert(&quot;Hello World!&quot;);
        }
    &lt;/script&gt;
&lt;/head&gt;
    &lt;button onclick=&quot;myFunction()&quot;&gt; 点我 &lt;/button&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="JavaScript-函数语法-1"><a href="#JavaScript-函数语法-1" class="headerlink" title="JavaScript 函数语法"></a>JavaScript 函数语法</h3><p>函数就是包裹在花括号内的代码块，前面使用了关键词 function</p>
<pre><code class="JavaScript">function functionName(){// 执行代码}
</code></pre>
<h3 id="调用带参数的函数-1"><a href="#调用带参数的函数-1" class="headerlink" title="调用带参数的函数"></a>调用带参数的函数</h3><p>在调用函数时，可以向其传递值，这些值被称为参数<br>可以发送任意多的参数，由逗号分隔<br>当声明函数时，把参数作为变量来声明<br>变量和参数必须以一致的顺序出现，第一个变量就是第一个被传递的参数的给定的值</p>
<pre><code class="html">&lt;p&gt; 点击这个按钮，来调用带参数的函数。&lt;/p&gt;
&lt;button onclick=&quot;myFunction(&#39;Harry Potter&#39;,&#39;Wizard&#39;)&quot;&gt; 点击这里 &lt;/button&gt;
&lt;script&gt;
    function myFunction(name,job) {alert(&quot;Welcome&quot; + name + &quot;, the&quot; + job);
    }
&lt;/script&gt;
</code></pre>
<h3 id="带有返回值的函数-1"><a href="#带有返回值的函数-1" class="headerlink" title="带有返回值的函数"></a>带有返回值的函数</h3><p>在使用 return 语句时，函数会停止执行，并返回指定的值</p>
<pre><code class="JavaScript">function myFunction() {
    var x=5;
    return x;
}
</code></pre>
<p>返回值可选</p>
<pre><code class="JavaScript">function myFunction(a,b) {if (a&gt;b) {return;}
    return a+b
}
当 a&gt;b 时，则直接退出函数，返回 undefined
当 a&lt;=b 时，则返回 a+b 的值
</code></pre>
<h3 id="局部-JavaScript-变量-1"><a href="#局部-JavaScript-变量-1" class="headerlink" title="局部 JavaScript 变量"></a>局部 JavaScript 变量</h3><p>在 JavaScript 函数内部声明的变量是局部变量，所以只能在函数内部访问，为局部作用域<br>可以在不同的函数中使用名称相同的局部变量<br>只要函数运行完毕，本地变量就会被删除</p>
<h3 id="全局-JavaScript-变量-1"><a href="#全局-JavaScript-变量-1" class="headerlink" title="全局 JavaScript 变量"></a>全局 JavaScript 变量</h3><p>在函数外声明的变量时全局变量，网页上所有的脚本和函数都可以访问</p>
<h3 id="JavaScript-变量的生存期-1"><a href="#JavaScript-变量的生存期-1" class="headerlink" title="JavaScript 变量的生存期"></a>JavaScript 变量的生存期</h3><p>JavaScript 变量的生命期从被声明开始<br>局部变量会在函数运行后删除<br>全局变量会在页面关闭后删除</p>
<h3 id="向未声明的-JavaScript-变量分配值-1"><a href="#向未声明的-JavaScript-变量分配值-1" class="headerlink" title="向未声明的 JavaScript 变量分配值"></a>向未声明的 JavaScript 变量分配值</h3><p>如果把值赋给尚未声明的变量，则该变量将被自动作为 window 的一个属性<br>非严格模式下给未声明的变量赋值创建的全局变量，是全局对象的可配置属性，可以删除</p>
<pre><code class="JavaScript">var x = 1; // 不可配置全局属性
y = 2; // 没有使用 var 声明，可配置全局属性

console.log(this.x); // 1
console.log(window.x); // 1

delete x; // false 无法删除
console.log(x); //1

delete y; //true 删除
console.log(y); // 已经删除 报错变量未定义
</code></pre>
<hr>
<h2 id="JavaScript-作用域-2"><a href="#JavaScript-作用域-2" class="headerlink" title="JavaScript 作用域"></a>JavaScript 作用域</h2><p>作用域是可访问变量的集合</p>
<h3 id="JavaScript-作用域-3"><a href="#JavaScript-作用域-3" class="headerlink" title="JavaScript 作用域"></a>JavaScript 作用域</h3><p>在 JavaScript 中，对象和函数都是变量<br>在 JavaScript 中，作用域为可访问变量，对象，函数的集合<br>JavaScript 函数作用域：作用域在函数内修改</p>
<h3 id="JavaScript-局部变量-1"><a href="#JavaScript-局部变量-1" class="headerlink" title="JavaScript 局部变量"></a>JavaScript 局部变量</h3><p>变量在函数内声明，为局部变量<br>局部变量：只能在函数内部访问</p>
<pre><code class="JavaScript">// 此处不能调用 carName 变量
function myFunction() {
    var carName = &quot;Volvo&quot;;
    // 函数内可调用 carName 变量
}
</code></pre>
<p>因为局部变量只作用于函数内，所以不同的函数可以使用相同名称的变量<br>局部变量在函数开始执行时创建，函数执行完后局部变量会自动销毁</p>
<h3 id="JavaScript-全局变量-1"><a href="#JavaScript-全局变量-1" class="headerlink" title="JavaScript 全局变量"></a>JavaScript 全局变量</h3><p>变量在函数外定义，为全局变量<br>全局作用域：网页中的所有脚本和函数均可使用</p>
<pre><code class="JavaScript">var carName = &quot;Volvo&quot;;
// 此处可调用 carName 变量
function myFunction(){// 函数内可调用 carName 变量}
</code></pre>
<p>如果变量在函数内没有声明（没有使用 var 关键字），该变量为全局变量</p>
<pre><code class="JavaScript">// 此处可调用 carName 变量
function myFunction() {
    carName = &quot;Volvo&quot;;
    // 此处可调用 carName 变量
}
</code></pre>
<h3 id="JavaScript-变量生命周期-1"><a href="#JavaScript-变量生命周期-1" class="headerlink" title="JavaScript 变量生命周期"></a>JavaScript 变量生命周期</h3><p>JavaScript 变量生命周期在它声明时初始化<br>局部变量在函数执行完毕后销毁<br>全局变量在页面关闭后销毁</p>
<h3 id="函数参数-1"><a href="#函数参数-1" class="headerlink" title="函数参数"></a>函数参数</h3><p>函数参数只在函数内起作用为局部变量</p>
<h3 id="HTML-中的全局变量-1"><a href="#HTML-中的全局变量-1" class="headerlink" title="HTML 中的全局变量"></a>HTML 中的全局变量</h3><p>在 HTML 中，全局变量是 window 对象：所有数据变量都属于 window 对象</p>
<pre><code class="JavaScript">// 此处可使用 window.carName
function myFunction(){carName = &quot;Volvo&quot;;}
</code></pre>
<p><strong> 全局变量，或者函数，可以覆盖 window 对象的变量或者函数<br>局部变量，包括 window 对象可以覆盖全局变量和函数 </strong></p>
<hr>
<h2 id="JavaScript-事件-1"><a href="#JavaScript-事件-1" class="headerlink" title="JavaScript 事件"></a>JavaScript 事件</h2><p>HTML 事件是发生在 HTML 元素上的事情<br>当在 HTML 页面中使用 JavaScript 时，JavaScript 可以触发这些事件</p>
<h3 id="HTML-事件-1"><a href="#HTML-事件-1" class="headerlink" title="HTML 事件"></a>HTML 事件</h3><p>HTML 事件可以是浏览器行为，也可以是用户行为</p>
<ul>
<li>HTML 页面加载完成</li>
<li>HTML input 字段改变</li>
<li>HTML 按钮被点击</li>
</ul>
<h3 id="常见的-HTML-事件-1"><a href="#常见的-HTML-事件-1" class="headerlink" title="常见的 HTML 事件"></a>常见的 HTML 事件</h3><table>
<thead>
<tr>
<th style="text-align:center">事件</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">onchange</td>
<td style="text-align:center">HTML 元素改变</td>
</tr>
<tr>
<td style="text-align:center">onclick</td>
<td style="text-align:center">用户点击 HTML 元素</td>
</tr>
<tr>
<td style="text-align:center">onmouseover</td>
<td style="text-align:center">移动鼠标</td>
</tr>
<tr>
<td style="text-align:center">onmouseout</td>
<td style="text-align:center">移开鼠标</td>
</tr>
<tr>
<td style="text-align:center">onkeydown</td>
<td style="text-align:center">按下键盘按键</td>
</tr>
<tr>
<td style="text-align:center">onload</td>
<td style="text-align:center">浏览器已加载完成</td>
</tr>
</tbody>
</table>
<h3 id="JavaScript-可以做什么-1"><a href="#JavaScript-可以做什么-1" class="headerlink" title="JavaScript 可以做什么"></a>JavaScript 可以做什么</h3><p>事件可以用于处理表单验证，用户输入，用户行为及浏览器动作:</p>
<ul>
<li>页面加载时触发事件</li>
<li>页面关闭时触发事件</li>
<li>用户点击按钮执行动作</li>
<li>验证用户输入内容的合法性</li>
</ul>
<p>可以使用多种方法来执行 JavaScript 事件代码：</p>
<ul>
<li>HTML 事件属性可以直接执行 JavaScript 代码</li>
<li>HTML 事件属性可以调用 JavaScript 函数</li>
<li>可以为 HTML 元素指定自己的事件处理程序</li>
<li>可以阻止事件的发生</li>
</ul>
<hr>
<h2 id="JavaScript-字符串-2"><a href="#JavaScript-字符串-2" class="headerlink" title="JavaScript 字符串"></a>JavaScript 字符串</h2><p>JavaScript 字符串用于存储和处理文本</p>
<h3 id="JavaScript-字符串-3"><a href="#JavaScript-字符串-3" class="headerlink" title="JavaScript 字符串"></a>JavaScript 字符串</h3><p>可以存储一系列字符，如“yhh”<br>可以是插入到引号中的任何字符，单引号或双引号<br>可以使用索引位置来访问字符串中的每个字符<br>字符串的索引从 0 开始，第一个字符索引值为 [0]，第二个是 [1]，以此类推<br>可以在字符串中添加转义字符来使用引号</p>
<pre><code class="JavaScript">var name = &quot;yyh7281&quot;
var name = &#39;yyh7281&#39;
name[3] //7
name[0] //y
var x = &quot;he is called \&quot;Jack\&quot;&quot;
</code></pre>
<h3 id="字符串长度-1"><a href="#字符串长度-1" class="headerlink" title="字符串长度"></a>字符串长度</h3><p>可以使用内置属性 <code>length</code> 来计算字符串的长度</p>
<pre><code class="JavaScript">var text = &quot;dhxahjsocnbdhehowcwncnhi&quot;
text.length //15
</code></pre>
<h3 id="特殊字符（转义字符）-1"><a href="#特殊字符（转义字符）-1" class="headerlink" title="特殊字符（转义字符）"></a>特殊字符（转义字符）</h3><table>
<thead>
<tr>
<th style="text-align:center">代码</th>
<th style="text-align:center">输出</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">‘</td>
<td style="text-align:center">单引号</td>
</tr>
<tr>
<td style="text-align:center">“</td>
<td style="text-align:center">双引号</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td style="text-align:center">反斜杠</td>
</tr>
<tr>
<td style="text-align:center">\n</td>
<td style="text-align:center">换行</td>
</tr>
<tr>
<td style="text-align:center">\r</td>
<td style="text-align:center">回车</td>
</tr>
<tr>
<td style="text-align:center">\t</td>
<td style="text-align:center">tab（制表符）</td>
</tr>
<tr>
<td style="text-align:center">\b</td>
<td style="text-align:center">退格符</td>
</tr>
<tr>
<td style="text-align:center">\f</td>
<td style="text-align:center">换页符</td>
</tr>
</tbody>
</table>
<h3 id="字符串可以是对象-1"><a href="#字符串可以是对象-1" class="headerlink" title="字符串可以是对象"></a>字符串可以是对象</h3><p>通常，JavaScript 字符串是原始值，可以使用字符创建<br>但也可以使用 new 关键字将字符串定义为一个对象</p>
<pre><code class="JavaScript">var x = &quot;yyh&quot;
var y = new String(&quot;hhhy&quot;)
typeof x //String
typeof y //Object
x === y //false 因为 x 为字符串，y 为对象
</code></pre>
<h3 id="字符串属性和方法-1"><a href="#字符串属性和方法-1" class="headerlink" title="字符串属性和方法"></a>字符串属性和方法</h3><p>原始值字符串，如 “John”, 没有属性和方法 (因为他们不是对象)<br>原始值可以使用 JavaScript 的属性和方法，因为 JavaScript 在执行方法和属性时可以把原始值当作对象</p>
<h3 id="字符串属性-1"><a href="#字符串属性-1" class="headerlink" title="字符串属性"></a>字符串属性</h3><table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">constructor</td>
<td style="text-align:center">返回创建字符串属性的函数</td>
</tr>
<tr>
<td style="text-align:center">length</td>
<td style="text-align:center">返回字符串的长度</td>
</tr>
<tr>
<td style="text-align:center">prototype</td>
<td style="text-align:center">允许向对象添加属性和方法</td>
</tr>
</tbody>
</table>
<h3 id="字符串方法-1"><a href="#字符串方法-1" class="headerlink" title="字符串方法"></a>字符串方法</h3><table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">charAt()</td>
<td style="text-align:center">返回指定索引位置的字符</td>
</tr>
<tr>
<td style="text-align:center">charCodeAt()</td>
<td style="text-align:center">返回指定索引位置字符的 Unicode 值</td>
</tr>
<tr>
<td style="text-align:center">concat()</td>
<td style="text-align:center">连接两个或多个字符串，返回连接后的字符串</td>
</tr>
<tr>
<td style="text-align:center">fromCharCode()</td>
<td style="text-align:center">将 Unicode 转换为字符串</td>
</tr>
<tr>
<td style="text-align:center">indexOf()</td>
<td style="text-align:center">返回字符串中检索指定字符第一次出现的位置</td>
</tr>
<tr>
<td style="text-align:center">lastIndexOf()</td>
<td style="text-align:center">返回字符串中检索指定字符最后一次出现的位置</td>
</tr>
<tr>
<td style="text-align:center">localeCompare()</td>
<td style="text-align:center">用本地特定的顺序来比较两个字符串</td>
</tr>
<tr>
<td style="text-align:center">match()</td>
<td style="text-align:center">找到一个或多个正则表达式的匹配</td>
</tr>
<tr>
<td style="text-align:center">replace()</td>
<td style="text-align:center">替换与正则表达式匹配的子串</td>
</tr>
<tr>
<td style="text-align:center">search()</td>
<td style="text-align:center">检索与正则表达式相匹配的值</td>
</tr>
<tr>
<td style="text-align:center">slice()</td>
<td style="text-align:center">提取字符串的片段，并在新的字符串中返回被提取的部分</td>
</tr>
<tr>
<td style="text-align:center">split()</td>
<td style="text-align:center">把字符串分割为子字符串数组</td>
</tr>
<tr>
<td style="text-align:center">substr()</td>
<td style="text-align:center">从起始索引号提取字符串中指定数目的字符</td>
</tr>
<tr>
<td style="text-align:center">substring()</td>
<td style="text-align:center">提取字符串中两个指定的索引号之间的字符</td>
</tr>
<tr>
<td style="text-align:center">toLowerCase()</td>
<td style="text-align:center">把字符串转换为小写</td>
</tr>
<tr>
<td style="text-align:center">toString()</td>
<td style="text-align:center">返回字符串对象值</td>
</tr>
<tr>
<td style="text-align:center">toUpperCase()</td>
<td style="text-align:center">把字符串转换为大写</td>
</tr>
<tr>
<td style="text-align:center">trim()</td>
<td style="text-align:center">移除字符串首尾空白</td>
</tr>
<tr>
<td style="text-align:center">valueOf()</td>
<td style="text-align:center">返回某个字符串对象的原始值</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="JavaScript-运算符-1"><a href="#JavaScript-运算符-1" class="headerlink" title="JavaScript 运算符"></a>JavaScript 运算符</h2><p>运算符 = 用于给 JavaScript 变量赋值<br>算术运算符 + 用于把值加起来</p>
<pre><code class="JavaScript">x = 3
y = 5
z = x+y
z //8
</code></pre>
<h3 id="JavaScript-算术运算符-1"><a href="#JavaScript-算术运算符-1" class="headerlink" title="JavaScript 算术运算符"></a>JavaScript 算术运算符</h3><table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">例子（y=5）</th>
<th style="text-align:center">x 运算结果</th>
<th style="text-align:center">y 运算结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">加法</td>
<td style="text-align:center">x=y+2</td>
<td style="text-align:center">7</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">减法</td>
<td style="text-align:center">x=y-2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">乘法</td>
<td style="text-align:center">x=y*2</td>
<td style="text-align:center">10</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">/</td>
<td style="text-align:center">除法</td>
<td style="text-align:center">x=y/5</td>
<td style="text-align:center">1</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:center">取模（余数）</td>
<td style="text-align:center">x=y%2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">++</td>
<td style="text-align:center">自增</td>
<td style="text-align:center">x=++y<br>x=y++</td>
<td style="text-align:center">6<br>5</td>
<td style="text-align:center">6<br>6</td>
</tr>
<tr>
<td style="text-align:center">–</td>
<td style="text-align:center">自减</td>
<td style="text-align:center">x=–y<br>x=y–</td>
<td style="text-align:center">4<br>5</td>
<td style="text-align:center">4<br>4</td>
</tr>
</tbody>
</table>
<h3 id="JavaScript-赋值运算符-1"><a href="#JavaScript-赋值运算符-1" class="headerlink" title="JavaScript 赋值运算符"></a>JavaScript 赋值运算符</h3><p><code>var x = 10 y = 5</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">例子</th>
<th style="text-align:center">等同于</th>
<th style="text-align:center">运算结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">=</td>
<td style="text-align:center">x=y</td>
<td style="text-align:center"></td>
<td style="text-align:center">x=5</td>
</tr>
<tr>
<td style="text-align:center">+=</td>
<td style="text-align:center">x+=y</td>
<td style="text-align:center">x=x+y</td>
<td style="text-align:center">x=15</td>
</tr>
<tr>
<td style="text-align:center">-=</td>
<td style="text-align:center">x-=y</td>
<td style="text-align:center">x=x-y</td>
<td style="text-align:center">x=5</td>
</tr>
<tr>
<td style="text-align:center">*=</td>
<td style="text-align:center">x*=y</td>
<td style="text-align:center">x=x*y</td>
<td style="text-align:center">x=50</td>
</tr>
<tr>
<td style="text-align:center">/=</td>
<td style="text-align:center">x/=y</td>
<td style="text-align:center">x=x/y</td>
<td style="text-align:center">x=2</td>
</tr>
<tr>
<td style="text-align:center">%=</td>
<td style="text-align:center">x%=y</td>
<td style="text-align:center">x=x%y</td>
<td style="text-align:center">x=0</td>
</tr>
</tbody>
</table>
<h3 id="用于字符串的-运算符-1"><a href="#用于字符串的-运算符-1" class="headerlink" title="用于字符串的 + 运算符"></a>用于字符串的 + 运算符</h3><ul>
<li>运算符永雨把文本值或字符串变量加起来（连接起来）</li>
</ul>
<pre><code class="JavaScript">text1 = &quot;hello&quot;
text2 = &quot;world&quot;
text3 = text1+text2 //&quot;helloworld&quot;
text4 = text1+&quot;&quot;+text2 //&quot;hello world&quot;
</code></pre>
<h3 id="对字符串和数字进行加法运算-1"><a href="#对字符串和数字进行加法运算-1" class="headerlink" title="对字符串和数字进行加法运算"></a>对字符串和数字进行加法运算</h3><p>两个数字相加，返回相加的和，数字与字符串相加，则返回字符串</p>
<pre><code class="JavaScript">x = 5+5 //10
y = &quot;3&quot;+5 //&quot;35&quot;
z = &quot;hello&quot;+5 //&quot;hello5&quot;
</code></pre>
<hr>
<h2 id="JavaScript-比较和逻辑运算符-1"><a href="#JavaScript-比较和逻辑运算符-1" class="headerlink" title="JavaScript 比较和逻辑运算符"></a>JavaScript 比较和逻辑运算符</h2><p>比较和逻辑运算符用于测试 true 或者 false</p>
<h3 id="比较运算符-1"><a href="#比较运算符-1" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>比较运算符在逻辑语句中使用，以测定变量或值是否相等<br><code>var x = 5</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">比较</th>
<th style="text-align:center">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">==</td>
<td style="text-align:center">等于</td>
<td style="text-align:center">x\==8<br>x==5</td>
<td style="text-align:center">false<br>true</td>
</tr>
<tr>
<td style="text-align:center">===</td>
<td style="text-align:center">绝对等于（值和类型均相等）</td>
<td style="text-align:center">x=\==“5”<br>x\===5</td>
<td style="text-align:center">false<br>true</td>
</tr>
<tr>
<td style="text-align:center">!=</td>
<td style="text-align:center">不等于</td>
<td style="text-align:center">x!=8</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center">!==</td>
<td style="text-align:center">不绝对等于（值和类型有一个或两个不相等）</td>
<td style="text-align:center">x!\==“5”<br>x!==5</td>
<td style="text-align:center">true<br>false</td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">大于</td>
<td style="text-align:center">x&gt;8</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">小于</td>
<td style="text-align:center">x&lt;8</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center">&gt;=</td>
<td style="text-align:center">大于等于</td>
<td style="text-align:center">x&gt;=8</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">&lt;=</td>
<td style="text-align:center">小于等于</td>
<td style="text-align:center">x&lt;=8</td>
<td style="text-align:center">true</td>
</tr>
</tbody>
</table>
<h3 id="逻辑运算符-1"><a href="#逻辑运算符-1" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符用于测定变量或值之间的逻辑<br><code>var x=6 y=3</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&amp;&amp;</td>
<td style="text-align:center">and</td>
<td style="text-align:center">(x&lt;10&amp;&amp;y&gt;1)//true</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td style="text-align:center">\</td>
<td style="text-align:center"></td>
<td>or</td>
<td>(x\==6 \</td>
<td>\</td>
<td>y==5)//true</td>
</tr>
<tr>
<td style="text-align:center">!</td>
<td style="text-align:center">not</td>
<td style="text-align:center">!(x==y)//true</td>
</tr>
</tbody>
</table>
<h3 id="条件运算符-1"><a href="#条件运算符-1" class="headerlink" title="条件运算符"></a>条件运算符</h3><p>JavaScript 还包含了基于某些条件对变量进行赋值的条件运算</p>
<pre><code class="JavaScript">name = (condition) ? value1 : value2 // 语法
yhh=(age&lt;18)?&quot;年龄不够&quot;:&quot;年龄已达到&quot; // 如果 age&lt;18 则赋值“年龄太小”，反之“年龄已达到”
</code></pre>
<hr>
<h2 id="JavaScript-if…else-语句-1"><a href="#JavaScript-if…else-语句-1" class="headerlink" title="JavaScript if…else 语句"></a>JavaScript if…else 语句</h2><p>条件语句用于基于不同的条件来执行不同的动作</p>
<h3 id="条件语句-1"><a href="#条件语句-1" class="headerlink" title="条件语句"></a>条件语句</h3><p>在 JavaScript 中，可以使用一下条件语句：</p>
<ul>
<li>if 语句 只有当指定条件为 true 时，使用该语句来执行代码</li>
<li>if…else 语句 当条件为 true 时执行代码，当条件为 false 时执行其他代码</li>
<li>if…else if…else 使用该语句来选择多个代码块之一来执行</li>
<li>switch 语句 使用该语句来选择多个代码块之一来执行</li>
</ul>
<h3 id="if-语句-1"><a href="#if-语句-1" class="headerlink" title="if 语句"></a>if 语句</h3><p>只有当指定条件为 true 时，该语句才会执行代码</p>
<pre><code class="JavaScript">if(condition){当条件为 true 时执行}

var x = 10
function z(){if(x&lt;20){return x}
}
z() //10 否则为 undefined
</code></pre>
<h3 id="if…else-语句-1"><a href="#if…else-语句-1" class="headerlink" title="if…else 语句"></a>if…else 语句</h3><p>使用 if…else 语句在条件为 true 时执行代码，在条件为 false 时执行其他代码</p>
<pre><code class="JavaScript">if (condition) {当条件为 true 时执行的代码}
else {当条件不为 true 时执行的代码}

var x = 10
function z(){if(x&lt;5){return x}else{return x+1}
}
z() //11
</code></pre>
<h3 id="if…else-if…else-语句-1"><a href="#if…else-if…else-语句-1" class="headerlink" title="if…else if…else 语句"></a>if…else if…else 语句</h3><p>使用 if….else if…else 语句来选择多个代码块之一来执行</p>
<pre><code class="JavaScript">if (condition1) {当条件 1 为 true 时执行的代码}
else if (condition2) {当条件 2 为 true 时执行的代码}
else {当条件 1 和 条件 2 都不为 true 时执行的代码}

var x = 10
function z(){if(x&lt;5){return x}else if(x&lt;15){return x+5}else{return x+1}
}
z() //15
</code></pre>
<hr>
<h2 id="JavaScript-switch-语句-2"><a href="#JavaScript-switch-语句-2" class="headerlink" title="JavaScript switch 语句"></a>JavaScript switch 语句</h2><p>switch 语句用于基于不同条件来执行不同的动作</p>
<h3 id="JavaScript-switch-语句-3"><a href="#JavaScript-switch-语句-3" class="headerlink" title="JavaScript switch 语句"></a>JavaScript switch 语句</h3><p>使用 switch 语句来选择要执行的多个代码块之一</p>
<pre><code class="JavaScript">switch(n){
    case 1:
        执行代码块 1
        break;
    case 2:
        执行代码块 2
        break;
    default:
        与 case1 和 case2 不同时执行
}
工作原理：首先设置表达式 n（通常是一个变量）。随后表达式的值会与结构中的每个 case 的值做比较
如果存在匹配，则与该 case 关联的代码块会被执行。请使用 break 来阻止代码自动地向下一个 case 运行

var d=new Date().getDay();
switch (d) {
  case 0:x=&quot;今天是星期日&quot;;
  break;
  case 1:x=&quot;今天是星期一&quot;;
  break;
  case 2:x=&quot;今天是星期二&quot;;
  break;
  case 3:x=&quot;今天是星期三&quot;;
  break;
  case 4:x=&quot;今天是星期四&quot;;
  break;
  case 5:x=&quot;今天是星期五&quot;;
  break;
  case 6:x=&quot;今天是星期六&quot;;
  break;
}
// 今天是星期六
</code></pre>
<h3 id="default-关键词-1"><a href="#default-关键词-1" class="headerlink" title="default 关键词"></a>default 关键词</h3><p>使用 default 关键词来规定匹配不存在时做的事情</p>
<pre><code class="JavaScript">var d=new Date().getDay();
switch (d) {
    case 666:x=&quot;今天是星期六&quot;;
    break;
    case 000:x=&quot;今天是星期日&quot;;
    break;
    default:
    x=&quot;期待周末&quot;;
}
// 期待周末
</code></pre>
<hr>
<h2 id="JavaScript-for-循环-1"><a href="#JavaScript-for-循环-1" class="headerlink" title="JavaScript for 循环"></a>JavaScript for 循环</h2><p>循环可以将代码块执行指定的次数</p>
<h3 id="JavaScript-循环-1"><a href="#JavaScript-循环-1" class="headerlink" title="JavaScript 循环"></a>JavaScript 循环</h3><p>如果需要一遍又一遍运行相同的代码，且每次的值都不同，那么可以使用循环</p>
<pre><code class="JavaScript">// 常规写法
document.write(x[0])
document.write(x[1])
document.write(x[2])
document.write(x[3])
document.write(x[4])
document.write(x[5])
//for 循环
for(let i=0;i&lt;x.length;i++){document.write(x[i]) 
}
</code></pre>
<h3 id="不同类型的循环-1"><a href="#不同类型的循环-1" class="headerlink" title="不同类型的循环"></a>不同类型的循环</h3><p>JavaScript 支持不同类型的循环：</p>
<ul>
<li>for 循环代码块一定的次数</li>
<li>for/in 循环遍历对象的属性</li>
<li>while 当指定的条件为 true 时循环指定的代码块</li>
<li>do/while 同样当指定的条件为 true 时循环指定的代码块</li>
</ul>
<h3 id="for-循环-1"><a href="#for-循环-1" class="headerlink" title="for 循环"></a>for 循环</h3><pre><code class="JavaScript">for(语句 1; 语句 2; 语句 3){被执行的代码块}
语句 1 （代码块）开始前执行
语句 2 定义运行循环（代码块）的条件
语句 3 在循环（代码块）已被执行之后执行

for (var i=0; i&lt;5; i++) {x+=i;}
</code></pre>
<h3 id="for-in-循环-1"><a href="#for-in-循环-1" class="headerlink" title="for/in 循环"></a>for/in 循环</h3><p>JavaScript for/in 语句循环遍历对象的属性</p>
<pre><code class="JavaScript">var person={fname:&quot;John&quot;,lname:&quot;Doe&quot;,age:25};
for (x in person) { // x 为属性名
    txt=txt + person[x];
}
//JohnDoe25
</code></pre>
<hr>
<h2 id="JavaScript-while-循环-1"><a href="#JavaScript-while-循环-1" class="headerlink" title="JavaScript while 循环"></a>JavaScript while 循环</h2><p>只要指定条件为 true，循环就可以一直执行代码块</p>
<h3 id="while-循环-1"><a href="#while-循环-1" class="headerlink" title="while 循环"></a>while 循环</h3><pre><code class="JavaScript">while(条件){代码块}

while(i&lt;5){
    x+=i
    i++
}
</code></pre>
<h3 id="do-while-循环-1"><a href="#do-while-循环-1" class="headerlink" title="do/while 循环"></a>do/while 循环</h3><p>do/while 循环是 while 循环的变体，该循环会在检查条件是否为真之前执行一次代码块，然后如果条件为真，则会重复循环，意味着代码至少会被执行一次</p>
<pre><code class="JavaScript">do{代码}
while(条件)

do{
    x+=i
    i++
}
while(i&gt;3)
</code></pre>
<h3 id="比较-for-跟-while-循环-1"><a href="#比较-for-跟-while-循环-1" class="headerlink" title="比较 for 跟 while 循环"></a>比较 for 跟 while 循环</h3><p>基本类似</p>
<hr>
<h2 id="JavaScript-break-和-continue-语句-1"><a href="#JavaScript-break-和-continue-语句-1" class="headerlink" title="JavaScript break 和 continue 语句"></a>JavaScript break 和 continue 语句</h2><p>break 语句用于跳出循环<br>continue 语句用于跳出循环中的一个迭代</p>
<h3 id="break-语句-1"><a href="#break-语句-1" class="headerlink" title="break 语句"></a>break 语句</h3><p>break 语句跳出循环后，会继续执行该循环之后的代码（如果有）</p>
<pre><code class="JavaScript">for (i=0;i&lt;10;i++) {if (i==3) {break;}
    x=x + &quot;The number is&quot; + i + &quot;&lt;br&gt;&quot;;
}
//0 1 2
</code></pre>
<h3 id="continue-语句-1"><a href="#continue-语句-1" class="headerlink" title="continue 语句"></a>continue 语句</h3><p>continue 语句中断循环中的的迭代，如果出现了指定的条件，然后继续循环中的下一个迭代</p>
<pre><code class="JavaScript">for (i=0;i&lt;10;i++) {if (i==3) {continue;}
    x=x + &quot;The number is&quot; + i + &quot;&lt;br&gt;&quot;;
}
//0 1 2 4 5 6 7 8 9 
</code></pre>
<h3 id="JavaScript-标签-1"><a href="#JavaScript-标签-1" class="headerlink" title="JavaScript 标签"></a>JavaScript 标签</h3><p>continue 语句（带有或不带标签引用）只能用在循环中<br>break 语句（不带标签引用）只能在循环或 switch 中<br>通过标签引用，break 语句可用于跳出任何 JavaScript 代码块</p>
<pre><code class="JavaScript">cars=[&quot;BMW&quot;,&quot;Volvo&quot;,&quot;Saab&quot;,&quot;Ford&quot;];
list: {document.write(cars[0] + &quot;&lt;br&gt;&quot;);
    document.write(cars[1] + &quot;&lt;br&gt;&quot;);
    document.write(cars[2] + &quot;&lt;br&gt;&quot;);
    break list;
    document.write(cars[3] + &quot;&lt;br&gt;&quot;);
    document.write(cars[4] + &quot;&lt;br&gt;&quot;);
    document.write(cars[5] + &quot;&lt;br&gt;&quot;);}
//&quot;BMW&quot;&quot;Volvo&quot;&quot;Saab&quot;
</code></pre>
<hr>
<h2 id="JavaScript-typeof、null、undefined-1"><a href="#JavaScript-typeof、null、undefined-1" class="headerlink" title="JavaScript typeof、null、undefined"></a>JavaScript typeof、null、undefined</h2><h3 id="typeof-操作符-2"><a href="#typeof-操作符-2" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h3><p>检测变量的数据类型</p>
<pre><code class="JavaScript">typeof &quot;John&quot;               //  返回 string
typeof 3.14                 //  返回 number
typeof false                //  返回 boolean
typeof [1,2,3]              //  返回 object
typeof {name:&#39;John&#39;,age:34} //  返回 object
</code></pre>
<h3 id="null-1"><a href="#null-1" class="headerlink" title="null"></a>null</h3><p>在 JavaScript 中 null 表示“什么都没有”<br>null 是一个只有一个值的特殊类型，表示一个空对象引用<br>用 typeof 检测 null 返回 object<br>可以设置 null 来清空对象</p>
<pre><code class="JavaScript">var person = null // 值为 null（空） 类型为对象
var person = undefined // 值为 undefined 类型为 undefined
</code></pre>
<h3 id="undefined-1"><a href="#undefined-1" class="headerlink" title="undefined"></a>undefined</h3><p>在 JavaScript 中，undefined 是一个没有设置值的变量<br>typeof 一个没有值的变量会返回 undefined</p>
<h3 id="undefined-和-null-的区别-1"><a href="#undefined-和-null-的区别-1" class="headerlink" title="undefined 和 null 的区别"></a>undefined 和 null 的区别</h3><p>null 和 undefined 的值相等，但类型不同</p>
<pre><code class="JavaScript">typeof undefined //undefined
typeof null //object
null === undefined //false
null == undefined //true
</code></pre>
<hr>
<h2 id="JavaScript-类型转换-2"><a href="#JavaScript-类型转换-2" class="headerlink" title="JavaScript 类型转换"></a>JavaScript 类型转换</h2><p>Number()转换为数字，String() 转换为字符串，Boolean() 转换为布尔值</p>
<h3 id="JavaScript-数据类型-7"><a href="#JavaScript-数据类型-7" class="headerlink" title="JavaScript 数据类型"></a>JavaScript 数据类型</h3><p>在 JavaScript 中有 5 种不同的数据类型</p>
<ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>object</li>
<li>function</li>
</ul>
<p>3 种对象类型</p>
<ul>
<li>Object</li>
<li>Date</li>
<li>Array</li>
</ul>
<p>2 种不包含任何值的数据类型</p>
<ul>
<li>null</li>
<li>undefined</li>
</ul>
<h3 id="typeof-操作符-3"><a href="#typeof-操作符-3" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h3><pre><code class="JavaScript">typeof &quot;john&quot;           //string
typeof 3.14             //number
typeof NaN              //number
typeof false            //boolean
typeof [1,2,3]          //object
typeof {name:&#39;y&#39;,age:30}//object
typeof new Date()       //object
typeof function(){}     //function
typeof x                //undefined
typeof null             //object
typeof undefined        //undefined
</code></pre>
<p>注意：</p>
<ul>
<li>NaN 的数据类型是 number</li>
<li>数组 Array 的数据类型是 object</li>
<li>日期 Date 的数据类型是 object</li>
<li>null 的数据类型是 object</li>
<li>未定义变量的数据类型是 undefined</li>
</ul>
<h3 id="constructor-属性-1"><a href="#constructor-属性-1" class="headerlink" title="constructor 属性"></a>constructor 属性</h3><p>constructor 属性返回所有 JavaScript 变量的构造函数</p>
<pre><code class="JavaScript">&quot;John&quot;.constructor                 // 返回函数 String(){[native code] }
(3.14).constructor                 // 返回函数 Number(){[native code] }
false.constructor                  // 返回函数 Boolean(){[native code] }
[1,2,3,4].constructor              // 返回函数 Array(){[native code] }
{name:&#39;John&#39;, age:34}.constructor  // 返回函数 Object(){[native code] }
new Date().constructor             // 返回函数 Date()    {[native code] }
function (){}.constructor         // 返回函数 Function(){[native code] }
</code></pre>
<h3 id="JavaScript-类型转换-3"><a href="#JavaScript-类型转换-3" class="headerlink" title="JavaScript 类型转换"></a>JavaScript 类型转换</h3><p>JavaScript 变量可以转换为新变量或其他数据类型</p>
<ul>
<li>通过使用 JavaScript 函数</li>
<li>通过 JavaScript 自身自动转换</li>
</ul>
<h3 id="将数字转换为字符串-1"><a href="#将数字转换为字符串-1" class="headerlink" title="将数字转换为字符串"></a>将数字转换为字符串</h3><pre><code class="JavaScript">String(x)       // 将变量 x 转换为字符串并返回 &quot;x&quot;
String(123)     // 将数字 123 转换为字符串并返回 &quot;123&quot;
String(100+23)  // 将数字表达式转换为字符串并返回 &quot;123&quot;

Number 方法 toString() 也有同样的效果
x.toString()        //&quot;x&quot;
(123).toString()    //&quot;123&quot;
(100+23).toString() //&quot;123&quot;
</code></pre>
<h3 id="将布尔值转换为字符串-1"><a href="#将布尔值转换为字符串-1" class="headerlink" title="将布尔值转换为字符串"></a>将布尔值转换为字符串</h3><p>全局方法 String() 可以将布尔值转换为字符串</p>
<pre><code class="JavaScript">String(false)   //&quot;false&quot;
String(true)    //&quot;true&quot;
false.toString()//&quot;false&quot;
true.toString() //&quot;true&quot;
</code></pre>
<h3 id="将日期转换为字符串-1"><a href="#将日期转换为字符串-1" class="headerlink" title="将日期转换为字符串"></a>将日期转换为字符串</h3><p>Date() 返回字符串</p>
<pre><code class="JavaScript">Date()// 返回 &quot;Sat Apr 04 2020 17:25:36 GMT+0800 ( 中国标准时间)&quot;
String(new Date())  // 返回 &quot;Sat Apr 04 2020 17:25:36 GMT+0800 (中国标准时间)&quot;
obj = new Date()obj.toString()  // 返回 &quot;Sat Apr 04 2020 17:25:36 GMT+0800 (中国标准时间)&quot;
</code></pre>
<p>Date 方法</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">getDate()</td>
<td style="text-align:center">从 Date 对象返回一个月中的某一天（1-31）</td>
</tr>
<tr>
<td style="text-align:center">getDay()</td>
<td style="text-align:center">从 Date 对象返回一周中的某一天（0-6）</td>
</tr>
<tr>
<td style="text-align:center">getFullYear()</td>
<td style="text-align:center">从 Date 对象以四位数字返回年份</td>
</tr>
<tr>
<td style="text-align:center">getMonth()</td>
<td style="text-align:center">从 Date 对象返回月份（0-11）</td>
</tr>
<tr>
<td style="text-align:center">getHours()</td>
<td style="text-align:center">返回 Date 对象的小时（0-23）</td>
</tr>
<tr>
<td style="text-align:center">getMinutes()</td>
<td style="text-align:center">返回 Date 对象的分钟（0-59）</td>
</tr>
<tr>
<td style="text-align:center">getSeconds()</td>
<td style="text-align:center">返回 Date 对象的秒数（0-59）</td>
</tr>
<tr>
<td style="text-align:center">getMilliseconds()</td>
<td style="text-align:center">返回 Date 对象的毫秒数（0-999）</td>
</tr>
<tr>
<td style="text-align:center">getTime()</td>
<td style="text-align:center">返回 1970 年 1 月 1 日至今的毫秒数</td>
</tr>
</tbody>
</table>
<h3 id="将字符串转换为数字-1"><a href="#将字符串转换为数字-1" class="headerlink" title="将字符串转换为数字"></a>将字符串转换为数字</h3><p>全局方法 Number() 可以将字符串转换为数字<br>空字符串转换为 0<br>其他的字符串会转换为 NaN（不是数字）</p>
<pre><code class="JavaScript">Number(&quot;3.14&quot;)  //3.14
Number(&quot; &quot;)     //0
Number(&quot;&quot;)      //0
Number(&quot;99 88&quot;) //NaN
</code></pre>
<h3 id="一元运算符-1"><a href="#一元运算符-1" class="headerlink" title="一元运算符 +"></a>一元运算符 +</h3><p>Operator + 可用于将变量转换为数字<br>如果变量不能转换，它仍是一个数字，但值为 NaN</p>
<pre><code class="JavaScript">var x = &quot;5&quot;
var y = +x      //5

var x = &quot;sdad&quot;
var y = +x      //NaN
</code></pre>
<h3 id="将布尔值转换为数字-1"><a href="#将布尔值转换为数字-1" class="headerlink" title="将布尔值转换为数字"></a>将布尔值转换为数字</h3><p>全局方法 Number() 将布尔值转换为数字</p>
<pre><code class="JavaScript">Number(false)   //0
Number(true)    //1
</code></pre>
<h3 id="将日期转换为数字-1"><a href="#将日期转换为数字-1" class="headerlink" title="将日期转换为数字"></a>将日期转换为数字</h3><p>全局方法 Number() 将日期转换为数字</p>
<pre><code class="JavaScript">obj = new Date()Number(obj)     //1585993392324
obj.getTime()   //1585993392324
</code></pre>
<h3 id="自动转换类型-1"><a href="#自动转换类型-1" class="headerlink" title="自动转换类型"></a>自动转换类型</h3><p>当 JavaScript 尝试操作一个“错误”的数据类型时，会自动转换为“正确“的数据类型</p>
<pre><code class="JavaScript">5 + null    //5         null 转换为 0
&quot;5&quot; + null  //&quot;5null&quot;   null 转换为 &quot;null&quot;
&quot;5&quot; + 1     //51        1 转换为 &quot;1&quot;
&quot;5&quot; - 1     //4         &quot;5&quot; 转换为 5
</code></pre>
<hr>
<h2 id="JavaScript-正则表达式-1"><a href="#JavaScript-正则表达式-1" class="headerlink" title="JavaScript 正则表达式"></a>JavaScript 正则表达式</h2><p>正则表达式（Regular Expression，在代码中常简写为 regex，regexp 或 RE）使用单个字符串来描述、匹配一系列符合某个句法规则的的字符串搜索模式<br>搜索模式可用于文本搜索和文本替换</p>
<h3 id="什么事正则表达式-1"><a href="#什么事正则表达式-1" class="headerlink" title="什么事正则表达式"></a>什么事正则表达式</h3><p>正则表达式是由一个字符序列形成的搜索模式<br>当你在文本中搜索数据时，你可以用搜索模式来描述你要查询的内容<br>正则表达式可以是一个简单的字符，或一个更复杂的模式<br>正则表达式可用于所有文本搜索和文本替换的操作</p>
<pre><code class="JavaScript">/ 正则表达式主体 / 修饰符（可选）
var patt = /nowcoder/i

/nowcoder/i 是一个正则表达式
nowcoder 是一个正则表达式主体（用于检索）
i 是一个修饰符（搜索不区分大小写）
</code></pre>
<h3 id="使用字符串方法-1"><a href="#使用字符串方法-1" class="headerlink" title="使用字符串方法"></a>使用字符串方法</h3><p>在 JavaScript 中，正则表达式通常用于两个字符串方法：search()和 replace()<br>search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置<br>replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串</p>
<h3 id="search-方法使用正则表达式-1"><a href="#search-方法使用正则表达式-1" class="headerlink" title="search() 方法使用正则表达式"></a>search() 方法使用正则表达式</h3><pre><code class="JavaScript">搜索字符串 &quot;Nowcoder&quot;, 并显示匹配的起始位置：
var str = &quot;Visit Nowcoder!&quot;
var n = str.search(/Nowcoder/i)
//6
search 方法可使用字符串作为参数。字符串参数会转换为正则表达式，搜索字符串 &quot;Nowcoder&quot;, 并显示匹配的起始位置：
var str = &quot;Visit Nowcoder!&quot;
var n = str.search(&quot;Nowcoder&quot;)
</code></pre>
<h3 id="replace-方法使用正则表达式-1"><a href="#replace-方法使用正则表达式-1" class="headerlink" title="replace() 方法使用正则表达式"></a>replace() 方法使用正则表达式</h3><pre><code class="JavaScript">使用正则表达式且不区分大小写将字符串中的 Microsoft 替换为 Nowcoder：
var str = document.getElementById(&quot;demo&quot;).innerHTML
var txt  = str.replace(/microsoft/i,&quot;Nowcoder&quot;)
//or
var txt = str.replace(&quot;Microsoft&quot;,&quot;Nowcoder&quot;)
</code></pre>
<h3 id="正则表达式修饰符-1"><a href="#正则表达式修饰符-1" class="headerlink" title="正则表达式修饰符"></a>正则表达式修饰符</h3><table>
<thead>
<tr>
<th style="text-align:center">修饰符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">i</td>
<td style="text-align:center">执行对大小写不敏感的匹配</td>
</tr>
<tr>
<td style="text-align:center">g</td>
<td style="text-align:center">执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）</td>
</tr>
<tr>
<td style="text-align:center">m</td>
<td style="text-align:center">执行多行匹配</td>
</tr>
</tbody>
</table>
<h3 id="使用-test-test-方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回-true，否则返回-false-1"><a href="#使用-test-test-方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回-true，否则返回-false-1" class="headerlink" title="使用 test()test() 方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false"></a>使用 test()test() 方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false</h3><pre><code class="JavaScript">/e/.test(&quot;The best things in life are free!&quot;) //true
字符串中含有“e”
</code></pre>
<h3 id="使用-exec-exec-方法用于检索字符串中的正则表达式的匹配，该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为-null-1"><a href="#使用-exec-exec-方法用于检索字符串中的正则表达式的匹配，该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为-null-1" class="headerlink" title="使用 exec()exec() 方法用于检索字符串中的正则表达式的匹配，该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null"></a>使用 exec()exec() 方法用于检索字符串中的正则表达式的匹配，该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null</h3><pre><code class="JavaScript">/e/.exec(&quot;The best things in life are free!&quot;) //e
字符串中含有“e”
</code></pre>
<hr>
<h2 id="JavaScript-错误-throw、try、catch-1"><a href="#JavaScript-错误-throw、try、catch-1" class="headerlink" title="JavaScript 错误 - throw、try、catch"></a>JavaScript 错误 - throw、try、catch</h2><p>try 语句测试代码块的错误<br>catch 语句处理错误<br>throw 语句创建自定义错误<br>finally 语句在 try 和 catch 语句之后，无论是否有触发异常，该语句都会执行</p>
<h3 id="JavaScript-错误-1"><a href="#JavaScript-错误-1" class="headerlink" title="JavaScript 错误"></a>JavaScript 错误</h3><p>当 JavaScript 引擎执行 JavaScript 代码时，会发生各种错误<br>可能是语法错误，通常是程序员造成的编码错误或错别字<br>可能是拼写错误或语言中缺少的功能（可能由于浏览器差异）<br>可能是由于来自服务器或用户的错误输出而导致的错误<br>当然，也可能是由于许多其他不可预知的因素</p>
<h3 id="JavaScript-抛出（throw）错误-1"><a href="#JavaScript-抛出（throw）错误-1" class="headerlink" title="JavaScript 抛出（throw）错误"></a>JavaScript 抛出（throw）错误</h3><p>当错误发生时，当事情出问题时，JavaScript 引擎通常会停止，并生成一个错误消息<br>描述这种情况的技术术语是：JavaScript 将抛出一个错误</p>
<h3 id="JavaScript-try-和-catch-1"><a href="#JavaScript-try-和-catch-1" class="headerlink" title="JavaScript try 和 catch"></a>JavaScript try 和 catch</h3><p>try 语句允许我们定义在执行时进行错误测试的代码块<br>catch 语句允许我们定义当 try 代码块发生错误时，所执行的代码块<br>JavaScript 语句 try 和 catch 是成对出现的</p>
<pre><code class="JavaScript">try {...    // 异常的抛出} catch(e) {...    // 异常的捕获与处理} finally {...    // 结束处理}

var txt=&quot;&quot;;
function message(){try {adddlert(&quot;Welcome guest!&quot;);
    } catch(err) {
        txt=&quot;本页有一个错误&quot;;
        txt+=&quot;错误描述：&quot; + err.message + &quot; &quot;;
        txt+=&quot;点击确定继续&quot;;
        alert(txt);
    }
}
</code></pre>
<h3 id="JavaScript-throw-和-finally-1"><a href="#JavaScript-throw-和-finally-1" class="headerlink" title="JavaScript throw 和 finally"></a>JavaScript throw 和 finally</h3><p>throw 语句允许我们创建自定义错误<br>正确的技术术语是：创建或抛出异常（exception）<br>如果把 throw 与 try 和 catch 一起使用，那么您能够控制程序流，并生成自定义的错误消息<br>finally 语句不论之前的 try 和 catch 中是否产生异常都会执行该代码块</p>
<pre><code class="JavaScript">function myFunction() {
  var message, x;
  message = document.getElementById(&quot;p01&quot;);
  message.innerHTML = &quot;&quot;;
  x = document.getElementById(&quot;demo&quot;).value;
  try {if(x == &quot;&quot;) throw&quot; 值是空的 &quot;;
    if(isNaN(x)) throw &quot;值不是一个数字&quot;;
    x = Number(x);
    if(x &gt; 10) throw &quot;太大&quot;;
    if(x &lt; 5) throw &quot;太小&quot;;
  }
  catch(err) {message.innerHTML = &quot;错误:&quot; + err + &quot;.&quot;;}
  finally {document.getElementById(&quot;demo&quot;).value = &quot;&quot;;
  }
}
</code></pre>
<hr>
<h2 id="JavaScript-调试-1"><a href="#JavaScript-调试-1" class="headerlink" title="JavaScript 调试"></a>JavaScript 调试</h2><h3 id="console-log-方法-1"><a href="#console-log-方法-1" class="headerlink" title="console.log() 方法"></a>console.log() 方法</h3><p>console.log() 打印 JavaScript 值</p>
<h3 id="设置断点-debugger-1"><a href="#设置断点-debugger-1" class="headerlink" title="设置断点 debugger"></a>设置断点 debugger</h3><p>debugger 关键字用于停止执行 JavaScript，并调用调试函数</p>
<pre><code class="JavaScript">开启 dubugger，则代码在第三行前停止执行
var x = 15 * 5;
debugger;
document.getElementbyId(&quot;demo&quot;).innerHTML = x;
</code></pre>
<hr>
<h2 id="JavaScript-变量提升-1"><a href="#JavaScript-变量提升-1" class="headerlink" title="JavaScript 变量提升"></a>JavaScript 变量提升</h2><p>JavaScript 中，函数及变量的声明都将被提升到函数的最顶端<br>JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明</p>
<pre><code class="JavaScript">x = 5; // 变量 x 设置为 5

elem = document.getElementById(&quot;demo&quot;); // 查找元素
elem.innerHTML = x;                     // 在元素中显示 x

var x; // 声明 x
// 等同于
var x; // 声明 x
x = 5; // 变量 x 设置为 5

elem = document.getElementById(&quot;demo&quot;); // 查找元素
elem.innerHTML = x;                     // 在元素中显示 x
</code></pre>
<h3 id="JavaScript-初始化不会提升-1"><a href="#JavaScript-初始化不会提升-1" class="headerlink" title="JavaScript 初始化不会提升"></a>JavaScript 初始化不会提升</h3><p>JavaScript 只有声明的变量会提升，初始化的不会</p>
<pre><code class="JavaScript">var x = 5; // 初始化 x
var y = 7; // 初始化 y

elem = document.getElementById(&quot;demo&quot;); // 查找元素
elem.innerHTML = x + &quot; &quot; + y;           // 显示 x 和 y
//5 7
var x = 5; // 初始化 x

elem = document.getElementById(&quot;demo&quot;); // 查找元素
elem.innerHTML = x + &quot; &quot; + y;           // 显示 x 和 y

var y = 7; // 初始化 y
//5 undefined
// 等同于
var x = 5; // 初始化 x
var y;     // 声明 y

elem = document.getElementById(&quot;demo&quot;); // 查找元素
elem.innerHTML = x + &quot; &quot; + y;           // 显示 x 和 y

y = 7;    // 设置 y 为 7
</code></pre>
<h3 id="在顶端声明变量-1"><a href="#在顶端声明变量-1" class="headerlink" title="在顶端声明变量"></a>在顶端声明变量</h3><p>为了避免这些问题，通常我们在每个作用域开始前声明这些变量，这也是正常的 JavaScript 解析步骤，易于我们理解<br>JavaScript 严格模式 (strict mode) 不允许使用未声明的变量</p>
<hr>
<h2 id="JavaScript-严格模式（use-strict）-1"><a href="#JavaScript-严格模式（use-strict）-1" class="headerlink" title="JavaScript 严格模式（use strict）"></a>JavaScript 严格模式（use strict）</h2><p>即在严格的条件下进行</p>
<h3 id="使用“use-strict”-指令-1"><a href="#使用“use-strict”-指令-1" class="headerlink" title="使用“use strict” 指令"></a>使用“use strict” 指令</h3><p>严格模式通过在脚本或函数的头部添加 <code>“use strict”</code> 表达式来声明<br>在函数内部声明是局部作用域<br>为什么要用严格模式：</p>
<ul>
<li>消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为</li>
<li>消除代码运行的一些不安全之处，保证代码运行的安全</li>
<li>提高编译器效率，增加运行速度</li>
<li>为未来新版本的 Javascript 做好铺垫</li>
</ul>
<hr>
<h2 id="JavaScript-使用误区-1"><a href="#JavaScript-使用误区-1" class="headerlink" title="JavaScript 使用误区"></a>JavaScript 使用误区</h2><h3 id="赋值运算符应用错误-1"><a href="#赋值运算符应用错误-1" class="headerlink" title="赋值运算符应用错误"></a>赋值运算符应用错误</h3><p>在 JavaScript 程序中如果在 if 条件语句中使用赋值运算符的等号 (=) 将会产生一个错误结果, 正确的方法是使用比较运算符的两个等号 (==)</p>
<pre><code class="JavaScript">var x = 0;
if (x == 10)    //false

var x = 0;
if (x = 10)     //true 

var x = 0;
if (x = 0)      //false
</code></pre>
<h3 id="比较运算符常见错误-1"><a href="#比较运算符常见错误-1" class="headerlink" title="比较运算符常见错误"></a>比较运算符常见错误</h3><p>在常规比较重，数据类型是被忽略的</p>
<pre><code class="JavaScript">var x = 10;
var y = &quot;10&quot;;
if (x == y)     //true

var x = 10;
var y = &quot;10&quot;;
if (x === y)    //false
</code></pre>
<p>switch 语句会使用恒等计算符（===）进行比较</p>
<pre><code class="JavaScript">var x = 10;
switch(x) {case 10: alert(&quot;Hello&quot;);
}   // 执行

var x = 10;
switch(x) {case &quot;10&quot;: alert(&quot;Hello&quot;);
}   // 不执行
</code></pre>
<h3 id="加法与连接注意事项-1"><a href="#加法与连接注意事项-1" class="headerlink" title="加法与连接注意事项"></a>加法与连接注意事项</h3><p>加法是两个数字相加<br>连接是两个字符串连接<br>JavaScript 的加法和连接都用 + 运算符</p>
<pre><code class="JavaScript">var x = 10 + 5;          // x 的结果为 15
var x = 10 + &quot;5&quot;;        // x 的结果为 &quot;105&quot;

var x = 10;
var y = 5;
var z = x + y;           // z 的结果为 15

var x = 10;
var y = &quot;5&quot;;
var z = x + y;           // z 的结果为 &quot;105&quot;
</code></pre>
<h3 id="浮点型数据使用注意事项-1"><a href="#浮点型数据使用注意事项-1" class="headerlink" title="浮点型数据使用注意事项"></a>浮点型数据使用注意事项</h3><p>JavaScript 中的所有数据都是以 64 位浮点型数据（float）来存储</p>
<pre><code class="JavaScript">var x = 0.1;
var y = 0.2;
var z = x + y            // z 的结果为 0.3
if (z == 0.3)            // 返回 false

可以用整数的乘除法来解决：
var z = (x * 10 + y * 10) / 10;       // z 的结果为 0.3
</code></pre>
<h3 id="JavaScript-字符串分行-1"><a href="#JavaScript-字符串分行-1" class="headerlink" title="JavaScript 字符串分行"></a>JavaScript 字符串分行</h3><pre><code class="JavaScript">var x =
&quot;Hello World!&quot;;

var x = &quot;Hello
World!&quot;;            // 报错

var x = &quot;Hello \nWorld!&quot;;
</code></pre>
<hr>
<h2 id="JavaScript-表单-1"><a href="#JavaScript-表单-1" class="headerlink" title="JavaScript 表单"></a>JavaScript 表单</h2><p>HTML 表单验证可以通过 JavaScript 完成</p>
<pre><code class="html">&lt;form name=&quot;myForm&quot; action=&quot;//www.nowcoder.com&quot;
      onsubmit=&quot;return validateForm()&quot; method=&quot;post&quot;&gt;
    名字: &lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
&lt;/form&gt;
</code></pre>
<pre><code class="js">function validateForm(){var x = document.forms[&quot;myForm&quot;][&quot;fname&quot;].value;
    if (x == null || x == &quot;&quot;) {alert(&quot; 需要输入名字。&quot;);
        return false;
    }
}
用于判断表单字段 (fname) 值是否存在， 如果不存在，就弹出信息，阻止表单提交
</code></pre>
<h3 id="JavaScript-验证输入的数字-1"><a href="#JavaScript-验证输入的数字-1" class="headerlink" title="JavaScript 验证输入的数字"></a>JavaScript 验证输入的数字</h3><pre><code class="js">function myFunction() {
    var x, text;

    // 获取 id=&quot;numb&quot; 的值
    x = document.getElementById(&quot;numb&quot;).value;

    // 如果输入的值 x 不是数字或者小于 1 或者大于 10，
    // 则提示错误 Not a Number or less than one or greater than 10
    if (isNaN(x) || x &lt; 1 || x &gt; 10){text = &quot;输入错误&quot;;} else {text = &quot;输入正确&quot;;}
    document.getElementById(&quot;demo&quot;).innerHTML = text;
}
</code></pre>
<h3 id="HTML-表单自动验证-1"><a href="#HTML-表单自动验证-1" class="headerlink" title="HTML 表单自动验证"></a>HTML 表单自动验证</h3><pre><code class="html">如果表单字段 (fname) 的值为空, required 属性会阻止表单提交：
&lt;form action=&quot;//www.nowcoder.com&quot; method=&quot;post&quot;&gt;
  &lt;input type=&quot;text&quot; name=&quot;fname&quot; required=&quot;required&quot;&gt;
  &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
&lt;/form&gt;
</code></pre>
<h3 id="数据验证-1"><a href="#数据验证-1" class="headerlink" title="数据验证"></a>数据验证</h3><p>数据验证用于确保用户输入的数据是有效的<br>典型的数据验证有：</p>
<ul>
<li>必需字段是否有输入?</li>
<li>用户是否输入了合法的数据?</li>
<li>在数字字段是否输入了文本?</li>
</ul>
<p>大多数情况下，数据验证用于确保用户正确输入数据<br>数据验证可以使用不同方法来定义，并通过多种方式来调用<br>服务端数据验证是在数据提交到服务器上后再验证<br>客户端数据验证是在数据发送到服务器前，在浏览器上完成验证</p>
<h3 id="HTML-约束验证-1"><a href="#HTML-约束验证-1" class="headerlink" title="HTML 约束验证"></a>HTML 约束验证</h3><p>HTML5 新增了 HTML 表单验证方式：约束验证<br>约束验证是表单被提交时浏览器用来实现验证的一种算法<br>HTML 约束验证基于：</p>
<ul>
<li>HTML 输入属性</li>
<li>CSS 伪类选择器</li>
<li>DOM 属性和方法</li>
</ul>
<p>约束验证 HTML 输入属性</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">disabled</td>
<td style="text-align:center">规定输入的元素不可用</td>
</tr>
<tr>
<td style="text-align:center">max</td>
<td style="text-align:center">规定输入元素的最大值</td>
</tr>
<tr>
<td style="text-align:center">min</td>
<td style="text-align:center">规定输入元素的最小值</td>
</tr>
<tr>
<td style="text-align:center">pattern</td>
<td style="text-align:center">规定输入元素值的模式</td>
</tr>
<tr>
<td style="text-align:center">required</td>
<td style="text-align:center">规定输入元素字段是必需的</td>
</tr>
<tr>
<td style="text-align:center">type</td>
<td style="text-align:center">规定输入元素的类型</td>
</tr>
</tbody>
</table>
<p>约束验证 CSS 伪类选择器</p>
<table>
<thead>
<tr>
<th style="text-align:center">选择器</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">:disabled</td>
<td style="text-align:center">选取属性为”disabled”属性的 input 元素</td>
</tr>
<tr>
<td style="text-align:center">:invalid</td>
<td style="text-align:center">选取无效的 input 元素</td>
</tr>
<tr>
<td style="text-align:center">:optional</td>
<td style="text-align:center">选择没有”required”属性的 input 元素</td>
</tr>
<tr>
<td style="text-align:center">:required</td>
<td style="text-align:center">选择有”required”属性的 input 元素</td>
</tr>
<tr>
<td style="text-align:center">:valid</td>
<td style="text-align:center">选取有效值的 input 元素</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="JavaScript-表单验证-1"><a href="#JavaScript-表单验证-1" class="headerlink" title="JavaScript 表单验证"></a>JavaScript 表单验证</h2><p>JavaScript 可用来在数据被送往服务器前对 HTML 表单中的这些输入数据进行验证<br>表单数据经常需要使用 JavaScript 来验证其正确性：</p>
<ul>
<li>验证表单数据是否为空？</li>
<li>验证输入是否是一个正确的 email 地址？</li>
<li>验证日期是否输入正确？</li>
<li>验证表单输入内容是否为数字型？</li>
</ul>
<h3 id="必填或必选项目-1"><a href="#必填或必选项目-1" class="headerlink" title="必填或必选项目"></a>必填或必选项目</h3><p>form 表单提交时调用函数检查用户是否已填写表单中的必填项目，假如为空，则发出警告</p>
<pre><code class="html">&lt;form name=&quot;myForm&quot; action=&quot;//www.nowcoder.com&quot;
    onsubmit=&quot;return validateForm()&quot; method=&quot;post&quot;&gt;
    姓: &lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
&lt;/form&gt;
</code></pre>
<pre><code class="js">function validateForm(){var x=document.forms[&quot;myForm&quot;][&quot;fname&quot;].value;
  if (x==null || x==&quot;&quot;) {alert(&quot; 姓必须填写 &quot;);
    return false;
  }
}
</code></pre>
<h3 id="E-mail-验证-1"><a href="#E-mail-验证-1" class="headerlink" title="E-mail 验证"></a>E-mail 验证</h3><p>函数检查用户输入的数据是否符合电子邮件地址的基本语法</p>
<pre><code class="html">&lt;form name=&quot;myForm&quot; action=&quot;//www.nowcoder.com&quot;
      onsubmit=&quot;return validateForm();&quot; method=&quot;post&quot;&gt;
    Email: &lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
&lt;/form&gt;
</code></pre>
<pre><code class="js">function validateForm(){var x=document.forms[&quot;myForm&quot;][&quot;email&quot;].value;
  var atpos=x.indexOf(&quot;@&quot;);
  var dotpos=x.lastIndexOf(&quot;.&quot;);
  if (atpos&lt;1 || dotpos&lt;atpos+2 || dotpos+2&gt;=x.length){alert(&quot;不是一个有效的 e-mail 地址&quot;);
    return false;
  }
}
// 输入的数据必须包含 @ 符号和点号 (.)。同时，@ 不可以是邮件地址的首字符，并且 @ 之后需有至少一个点号
</code></pre>
<hr>
<h2 id="JavaScript-this-关键字-1"><a href="#JavaScript-this-关键字-1" class="headerlink" title="JavaScript this 关键字"></a>JavaScript this 关键字</h2><p>面向对象语言中 this 表示当前对象的一个引用<br>但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变</p>
<ul>
<li>在方法中，this 表示该方法所属的对象</li>
<li>如果单独使用，this 表示全局对象</li>
<li>在函数中，this 表示全局对象</li>
<li>在函数中，在严格模式下，this 是未定义的 (undefined)</li>
<li>在事件中，this 表示接收事件的元素</li>
<li>类似 call()和 apply() 方法可以将 this 引用到任何对象</li>
</ul>
<h3 id="方法中的-this-1"><a href="#方法中的-this-1" class="headerlink" title="方法中的 this"></a>方法中的 this</h3><p>在对象方法中，this 指向调用它所在方法的对象</p>
<pre><code class="js">var person = {
  firstName: &quot;John&quot;,
  lastName : &quot;Doe&quot;,
  id       : 5566,
  fullName : function(){return this.firstName + &quot; &quot; + this.lastName;}
};
</code></pre>
<h3 id="单独使用-this-1"><a href="#单独使用-this-1" class="headerlink" title="单独使用 this"></a>单独使用 this</h3><p>单独使用 this，则指向全局对象（Global）<br>在浏览器中，window 就是该全局对象 [object Window]</p>
<pre><code class="js">var x = this //object Window
</code></pre>
<h3 id="函数中使用-this（默认）-1"><a href="#函数中使用-this（默认）-1" class="headerlink" title="函数中使用 this（默认）"></a>函数中使用 this（默认）</h3><p>在函数中，函数的所属者默认绑定到 this 上<br>//object Window</p>
<h3 id="函数中使用-this（严格模式）-1"><a href="#函数中使用-this（严格模式）-1" class="headerlink" title="函数中使用 this（严格模式）"></a>函数中使用 this（严格模式）</h3><p>严格模式下函数是没有绑定到 this 上的，this 为 undefined</p>
<h3 id="事件中的-this-1"><a href="#事件中的-this-1" class="headerlink" title="事件中的 this"></a>事件中的 this</h3><p>在 HTML 事件中，this 指向了接受事件的 HTML 元素</p>
<pre><code class="html">&lt;button onclick=&quot;this.style.display=&#39;none&#39;&quot;&gt;
点我后我就消失了
&lt;/button&gt;
</code></pre>
<h3 id="对象方法中绑定-1"><a href="#对象方法中绑定-1" class="headerlink" title="对象方法中绑定"></a>对象方法中绑定</h3><pre><code class="js">var person = {
  firstName  : &quot;John&quot;,
  lastName   : &quot;Doe&quot;,
  id         : 5566,
  myFunction : function(){return this;}
};//[object Object]

var person = {
  firstName: &quot;John&quot;,
  lastName : &quot;Doe&quot;,
  id       : 5566,
  fullName : function(){return this.firstName + &quot; &quot; + this.lastName;}
};//John Doe
this.firstName 表示 this（person）对象的 firstName 属性
</code></pre>
<h3 id="显式函数绑定-1"><a href="#显式函数绑定-1" class="headerlink" title="显式函数绑定"></a>显式函数绑定</h3><p>在 JavaScript 中函数也是对象，对象则有方法，apply 和 call 就是函数对象的方法，这两个方法异常强大，他们允许切换函数执行的上下文环境（context），即 this 绑定的对象<br>下面实例中，使用 person2 作为参数来调用 person1.fullName 方法时，this 将指向 person2，即便它是 person1 的方法</p>
<pre><code class="js">var person1 = {fullName: function() {return this.firstName + &quot; &quot; + this.lastName;}
}
var person2 = {
  firstName:&quot;John&quot;,
  lastName: &quot;Doe&quot;,
}
person1.fullName.call(person2);  // 返回 &quot;John Doe&quot;
</code></pre>
<hr>
<h2 id="JavaScript-let-和-const-1"><a href="#JavaScript-let-和-const-1" class="headerlink" title="JavaScript let 和 const"></a>JavaScript let 和 const</h2><p>ES6 新增加了两个重要的 Javascript 关键字：let 和 const<br>let 声明的变量只在 let 命令所在的代码块内有效<br>const 声明一个只读的常量，一旦声明，常量的值就不能改变<br>在 ES6 之前，Javascript 只有两种作用域：全局变量与函数内的局部变量</p>
<h3 id="全局变量-3"><a href="#全局变量-3" class="headerlink" title="全局变量"></a>全局变量</h3><p>在函数外声明的变量作用域是全局的<br>全局变量在 Javascript 程序的任何地方都可以访问</p>
<pre><code class="js">var carName = &quot;Volvo&quot;;
// 这里可以使用 carName 变量
function myFunction(){// 这里也可以使用 carName 变量}
</code></pre>
<h3 id="局部变量-2"><a href="#局部变量-2" class="headerlink" title="局部变量"></a>局部变量</h3><p>在函数内声明的变量作用域是局部的<br>函数内使用 var 声明的变量只能在函数内容访问，如果不使用 var 则是全局变量</p>
<pre><code class="js">// 这里不能使用 carName 变量
function myFunction() {
    var carName = &quot;Volvo&quot;;
    // 这里可以使用 carName 变量
}
// 这里不能使用 carName 变量
</code></pre>
<h3 id="JavaScript-块级作用域（Block-Scope）-1"><a href="#JavaScript-块级作用域（Block-Scope）-1" class="headerlink" title="JavaScript 块级作用域（Block Scope）"></a>JavaScript 块级作用域（Block Scope）</h3><p>使用 var 关键字声明的变量不具备块级作用域的特性，它在 {} 外依然能被访问到</p>
<pre><code class="js">{var x = 2;}
// 这里可以使用 x 变量
</code></pre>
<p>在 ES6 之前，是没有块级作用域的概念的<br>ES6 可以使用 let 关键字来实现块级作用域<br>let 声明的变量只在 let 命令所在的代码块 {} 内有效，在 {} 之外不能访问</p>
<pre><code class="js">{let x = 2;}
// 这里不能使用 x 变量
</code></pre>
<h3 id="重新定义变量-1"><a href="#重新定义变量-1" class="headerlink" title="重新定义变量"></a>重新定义变量</h3><p>使用 var 关键字重新声明变量可能会带来问题<br>在块中重新声明变量也会重新声明块外的变量</p>
<pre><code class="js">var x = 10;
// 这里输出 x 为 10
{
    var x = 2;
    // 这里输出 x 为 2
}
// 这里输出 x 为 2
</code></pre>
<h3 id="循环作用域-1"><a href="#循环作用域-1" class="headerlink" title="循环作用域"></a>循环作用域</h3><p>使用 var 关键字</p>
<pre><code class="js">var i = 5;
for (var i = 0; i &lt; 10; i++) {// 一些代码...}
// 这里输出 i 为 10
</code></pre>
<p>let 关键字</p>
<pre><code class="js">let i = 5;
for (let i = 0; i &lt; 10; i++) {// 一些代码...}
// 这里输出 i 为 5
</code></pre>
<p>在第一个实例中，使用了 var 关键字，它声明的变量是全局的，包括循环体内与循环体外<br>在第二个实例中，使用 let 关键字， 它声明的变量作用域只在循环体内，循环体外的变量不受影响</p>
<h3 id="局部变量-3"><a href="#局部变量-3" class="headerlink" title="局部变量"></a>局部变量</h3><p>在函数体内使用 var 和 let 关键字声明的变量有点类似</p>
<pre><code class="js">// 使用 var
function myFunction(){var carName = &quot;Volvo&quot;;   // 局部作用域}

// 使用 let
function myFunction(){let carName = &quot;Volvo&quot;;   //  局部作用域}
</code></pre>
<h3 id="全局变量-4"><a href="#全局变量-4" class="headerlink" title="全局变量"></a>全局变量</h3><p>在函数体内或代码块外使用 var 和 let 关键字声明的变量也有点类似<br>它们的作用域都是全局的</p>
<pre><code class="js">// 使用 var
var x = 2;       // 全局作用域

// 使用 let
let x = 2;       // 全局作用域
</code></pre>
<h3 id="HTML-代码中使用全局变量-1"><a href="#HTML-代码中使用全局变量-1" class="headerlink" title="HTML 代码中使用全局变量"></a>HTML 代码中使用全局变量</h3><p>在 JavaScript 中, 全局作用域是针对 JavaScript 环境<br>在 HTML 中, 全局作用域是针对 window 对象<br>使用 var 关键字声明的全局作用域变量属于 window 对象：</p>
<pre><code class="js">var carName = &quot;Volvo&quot;;
// 可以使用 window.carName 访问变量
</code></pre>
<p>使用 let 关键字声明的全局作用域变量不属于 window 对象</p>
<pre><code class="js">let carName = &quot;Volvo&quot;
// 不能使用 window.carName 访问变量
</code></pre>
<h3 id="重制变量-1"><a href="#重制变量-1" class="headerlink" title="重制变量"></a>重制变量</h3><p>使用 var 关键字声明的变量在任何地方都可以修改</p>
<pre><code class="js">var x = 2;
// x 为 2

var x = 3;
// 现在 x 为 3
</code></pre>
<p>在相同的作用域或块级作用域中，不能使用 let 关键字来重置 var 关键字声明的变量：</p>
<pre><code class="js">var x = 2;       // 合法
let x = 3;       // 不合法

{
    var x = 4;   // 合法
    let x = 5   // 不合法
}
</code></pre>
<p>在相同的作用域或块级作用域中，不能使用 let 关键字来重置 let 关键字声明的变量：</p>
<pre><code class="js">let x = 2;       // 合法
let x = 3;       // 不合法

{
    let x = 4;   // 合法
    let x = 5;   // 不合法
}
</code></pre>
<p>在相同的作用域或块级作用域中，不能使用 var 关键字来重置 let 关键字声明的变量：</p>
<pre><code class="js">let x = 2;       // 合法
var x = 3;       // 不合法

{
    let x = 4;   // 合法
    var x = 5;   // 不合法
}
</code></pre>
<p>let 关键字在不同作用域，或不同块级作用域中是可以重新声明赋值的：</p>
<pre><code class="js">let x = 2;       // 合法

{let x = 3;   // 合法}

{let x = 4;   // 合法}
</code></pre>
<h3 id="变量提升-1"><a href="#变量提升-1" class="headerlink" title="变量提升"></a>变量提升</h3><p>JavaScript 中，var 关键字定义的变量可以在使用后声明，也就是变量可以先使用再声明</p>
<pre><code class="js">// 在这里可以使用 carName 变量

var carName;
</code></pre>
<p>let 关键字定义的变量则不可以在使用后声明，也就是变量需要先声明再使用。</p>
<pre><code class="js">// 在这里不可以使用 carName 变量

let carName;
</code></pre>
<p>const 关键字定义的变量则不可以在使用后声明，也就是变量需要先声明再使用</p>
<pre><code class="js">carName = &quot;Volvo&quot;;    // 在这里不可以使用 carName 变量
const carName = &quot;Volvo&quot;;
</code></pre>
<h3 id="const-关键字-1"><a href="#const-关键字-1" class="headerlink" title="const 关键字"></a>const 关键字</h3><p>const 用于声明一个或多个常量，声明时必须进行初始化，且初始化后值不可再修改</p>
<pre><code class="js">const PI = 3.141592653589793;
PI = 3.14;      // 报错
PI = PI + 10;   // 报错
</code></pre>
<p>const 定义常量与使用 let 定义的变量相似：</p>
<ul>
<li>二者都是块级作用域</li>
<li>都不能和它所在作用域内的其他变量或函数拥有相同的名称</li>
</ul>
<p>两者还有以下两点区别：</p>
<ul>
<li>const 声明的常量必须初始化，而 let 声明的变量不用</li>
<li>const 定义常量的值不能通过再赋值修改，也不能再次声明。而 let 定义的变量值可以修改</li>
</ul>
<pre><code class="js">var x = 10;
// 这里输出 x 为 10
{
    const x = 2;
    // 这里输出 x 为 2
}
// 这里输出 x 为 10
</code></pre>
<p>const 声明的常量必须初始化：</p>
<pre><code class="js">// 错误写法
const PI;
PI = 3.14159265359;

// 正确写法
const PI = 3.14159265359;
</code></pre>
<h3 id="并非真正的常量-1"><a href="#并非真正的常量-1" class="headerlink" title="并非真正的常量"></a>并非真正的常量</h3><p>const 的本质: const 定义的变量并非常量，并非不可变，它定义了一个常量引用一个值。使用 const 定义的对象或者数组，其实是可变的。下面的代码并不会报错：</p>
<pre><code class="js">// 创建常量对象
const car = {type:&quot;Fiat&quot;, model:&quot;500&quot;, color:&quot;white&quot;};

// 修改属性:
car.color = &quot;red&quot;;

// 添加属性
car.owner = &quot;Johnson&quot;;
</code></pre>
<p>但是我们不能对常量对象重新赋值：</p>
<pre><code class="js">const car = {type:&quot;Fiat&quot;, model:&quot;500&quot;, color:&quot;white&quot;};
car = {type:&quot;Volvo&quot;, model:&quot;EX60&quot;, color:&quot;red&quot;};    // 错误
</code></pre>
<p>以下实例修改常量数组：</p>
<pre><code class="js">// 创建常量数组
const cars = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;];

// 修改元素
cars[0] = &quot;Toyota&quot;;

// 添加元素
cars.push(&quot;Audi&quot;);
</code></pre>
<p>但是我们不能对常量数组重新赋值：</p>
<pre><code class="js">const cars = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;];
cars = [&quot;Toyota&quot;, &quot;Volvo&quot;, &quot;Audi&quot;];    // 错误
</code></pre>
<h3 id="重置变量-1"><a href="#重置变量-1" class="headerlink" title="重置变量"></a>重置变量</h3><p>使用 var 关键字声明的变量在任何地方都可以修改</p>
<pre><code class="js">var x = 2;    //  合法
var x = 3;    //  合法
x = 4;        //  合法
</code></pre>
<p>在相同的作用域或块级作用域中，不能使用 const 关键字来重置 var 和 let 关键字声明的变量：</p>
<pre><code class="js">var x = 2;         // 合法
const x = 2;       // 不合法
{
    let x = 2;     // 合法
    const x = 2;   // 不合法
}
</code></pre>
<p>在相同的作用域或块级作用域中，不能使用 const 关键字来重置 const 关键字声明的变量：</p>
<pre><code class="js">const x = 2;       // 合法
const x = 3;       // 不合法
x = 3;             // 不合法
var x = 3;         // 不合法
let x = 3;         // 不合法

{
    const x = 2;   // 合法
    const x = 3;   // 不合法
    x = 3;         // 不合法
    var x = 3;     // 不合法
    let x = 3;     // 不合法
}
</code></pre>
<p>const 关键字在不同作用域，或不同块级作用域中是可以重新声明赋值的：</p>
<pre><code class="js">const x = 2;       // 合法

{const x = 3;   // 合法}

{const x = 4;   // 合法}
</code></pre>
<hr>
<h2 id="Javascript-JSON-1"><a href="#Javascript-JSON-1" class="headerlink" title="Javascript JSON"></a>Javascript JSON</h2><p>JSON 是用于存储和传输数据的格式<br>JSON 通常用于服务端向网页传递数据 </p>
<h3 id="什么是-JSON？-1"><a href="#什么是-JSON？-1" class="headerlink" title="什么是 JSON？"></a>什么是 JSON？</h3><p>JSON 英文全称 JavaScript Object Notation<br>JSON 是一种轻量级的数据交换格式<br>JSON 是独立的语言<br>JSON 易于理解<br>JSON 使用 JavaScript 语法，但是 JSON 格式仅仅是一个文本<br>文本可以被任何编程语言读取及作为数据格式传递</p>
<h3 id="JSON-实例-1"><a href="#JSON-实例-1" class="headerlink" title="JSON 实例"></a>JSON 实例</h3><p>JSON 语法定义了 sites 对象：3 条网站信息（对象）的数组：</p>
<pre><code class="js">{&quot;sites&quot;:[{&quot;name&quot;:&quot;Runoob&quot;, &quot;url&quot;:&quot;www.nowcoder.com&quot;},
    {&quot;name&quot;:&quot;Google&quot;, &quot;url&quot;:&quot;www.google.com&quot;},
    {&quot;name&quot;:&quot;Taobao&quot;, &quot;url&quot;:&quot;www.taobao.com&quot;}
]}
</code></pre>
<h3 id="JSON-格式化后为-JavaScript-对象-1"><a href="#JSON-格式化后为-JavaScript-对象-1" class="headerlink" title="JSON 格式化后为 JavaScript 对象"></a>JSON 格式化后为 JavaScript 对象</h3><p>JSON 格式在语法上与创建 JavaScript 对象代码是相同的<br>由于它们很相似，所以 JavaScript 程序可以很容易的将 JSON 数据转换为 JavaScript 对象</p>
<h3 id="JSON-语法规则-1"><a href="#JSON-语法规则-1" class="headerlink" title="JSON 语法规则"></a>JSON 语法规则</h3><p>数据为 键 / 值 对<br>数据由逗号分隔<br>大括号保存对象<br>方括号保存数组</p>
<h3 id="JSON-数据-一个名称对应一个值-1"><a href="#JSON-数据-一个名称对应一个值-1" class="headerlink" title="JSON 数据 - 一个名称对应一个值"></a>JSON 数据 - 一个名称对应一个值</h3><p>JSON 数据格式为 键 / 值 对，就像 JavaScript 对象属性<br>键 / 值对包括字段名称（在双引号中），后面一个冒号，然后是值：<br><code>&quot;name&quot;:&quot;Nowcoder&quot;</code></p>
<h3 id="JSON-对象-1"><a href="#JSON-对象-1" class="headerlink" title="JSON 对象"></a>JSON 对象</h3><p>JSON 对象保存在大括号内<br>就像在 JavaScript 中, 对象可以保存多个 键 / 值 对：<br><code>{&quot;name&quot;:&quot;Nowcoder&quot;, &quot;url&quot;:&quot;www.nowcoder.com&quot;}</code></p>
<h3 id="JSON-数组-1"><a href="#JSON-数组-1" class="headerlink" title="JSON 数组"></a>JSON 数组</h3><p>JSON 数组保存在中括号内<br>就像在 JavaScript 中, 数组可以包含对象：</p>
<pre><code class="js">&quot;sites&quot;:[{&quot;name&quot;:&quot;Nowcoder&quot;, &quot;url&quot;:&quot;www.nowcoder.com&quot;},
    {&quot;name&quot;:&quot;Google&quot;, &quot;url&quot;:&quot;www.google.com&quot;},
    {&quot;name&quot;:&quot;Taobao&quot;, &quot;url&quot;:&quot;www.taobao.com&quot;}
]
在以上实例中，对象 &quot;sites&quot; 是一个数组，包含了三个对象
每个对象为站点的信息（网站名和网站地址）
</code></pre>
<h3 id="JSON-字符串转换为-Javascript-对象-1"><a href="#JSON-字符串转换为-Javascript-对象-1" class="headerlink" title="JSON 字符串转换为 Javascript 对象"></a>JSON 字符串转换为 Javascript 对象</h3><p>通常我们从服务器中读取 JSON 数据，并在网页中显示数据<br>简单起见，我们网页中直接设置 JSON 字符串：<br>首先，创建 JavaScript 字符串，字符串为 JSON 格式的数据：</p>
<pre><code class="js">var text = &#39;{&quot;sites&quot;: [&#39; +
    &#39;{&quot;name&quot;:&quot;Nowcoder&quot;,&quot;url&quot;:&quot;www.nowcoder.com&quot;},&#39; +
    &#39;{&quot;name&quot;:&quot;Google&quot;,&quot;url&quot;:&quot;www.google.com&quot;},&#39; +
    &#39;{&quot;name&quot;:&quot;Taobao&quot;,&quot;url&quot;:&quot;www.taobao.com&quot;} ]}&#39;;

obj = JSON.parse(text); // 内置函数 JSON.parse() 将字符串转换为 JavaScript 对象
document.getElementById(&quot;demo&quot;).innerHTML = obj.sites[1].name + &quot; &quot; + obj.sites[1].url;
</code></pre>
<hr>
<h2 id="JavaScript-void-0-含义-1"><a href="#JavaScript-void-0-含义-1" class="headerlink" title="JavaScript:void(0) 含义"></a>JavaScript:void(0) 含义</h2><p>javascript:void(0) 中最关键的是 void 关键字， void 是 JavaScript 中非常重要的关键字，该操作符指定要计算一个表达式但是不返回值</p>
<pre><code class="html">语法格式：
&lt;head&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
&lt;!--
void func()javascript:void func()

或者

void(func())
javascript:void(func())
//--&gt;
&lt;/script&gt;
&lt;/head&gt;

&lt;a href=&quot;javascript:void(0)&quot;&gt; 单击此处什么也不会发生 &lt;/a&gt;
// 当用户链接时，void(0) 计算为 0，但 Javascript 上没有任何效果

&lt;head&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
&lt;!--
//--&gt;
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;a href=&quot;javascript:void(alert(&#39;Warning!!!&#39;))&quot;&gt; 点我!&lt;/a&gt;
&lt;/body&gt;
// 在用户点击链接后显示警告信息

&lt;head&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
&lt;!--
function getValue(){
  var a,b,c;
  a = void (b = 5, c = 7);
  document.write(&#39;a =&#39; + a + &#39;b =&#39; + b +&#39;c =&#39; + c);
}
//--&gt;
&lt;/script&gt;
&lt;/head&gt;
// 参数 a 返回 undefined
</code></pre>
<h3 id="href-”-”-与-href-”javascript-void-0-”-的区别-1"><a href="#href-”-”-与-href-”javascript-void-0-”-的区别-1" class="headerlink" title="href=”#” 与 href=”javascript:void(0)” 的区别"></a>href=”#” 与 href=”javascript:void(0)” 的区别</h3><p># 包含了一个位置信息，默认的锚是 #top 也就是网页的上端<br>而 javascript:void(0), 仅仅表示一个死链接<br>在页面很长的时候会使用 # 来定位页面的具体位置，格式为：# + id<br>如果你要定义一个死链接请使用 javascript:void(0) </p>
<pre><code class="html">&lt;a href=&quot;javascript:void(0);&quot;&gt; 点我没有反应的!&lt;/a&gt;
&lt;a href=&quot;#pos&quot;&gt; 点我定位到指定位置!&lt;/a&gt;
&lt;br&gt;
...
&lt;br&gt;
&lt;p id=&quot;pos&quot;&gt; 尾部定位点 &lt;/p&gt;
</code></pre>
<hr>
<h2 id="JavaScript-代码规范-2"><a href="#JavaScript-代码规范-2" class="headerlink" title="JavaScript 代码规范"></a>JavaScript 代码规范</h2><p>所有的 JavaScript 项目都适用同一种规范</p>
<h3 id="JavaScript-代码规范-3"><a href="#JavaScript-代码规范-3" class="headerlink" title="JavaScript 代码规范"></a>JavaScript 代码规范</h3><p>代码规范通常包括以下几个方面：</p>
<ul>
<li>变量和函数的命名规则</li>
<li>空格，缩进，注释的使用规则</li>
<li>其他常用规范</li>
</ul>
<p>规范的代码更易于阅读与维护</p>
<h3 id="变量名-1"><a href="#变量名-1" class="headerlink" title="变量名"></a>变量名</h3><p>一般使用驼峰法来命名</p>
<pre><code class="js">firstName = &quot;John&quot;;
lastName = &quot;Doe&quot;;

price = 19.90;
tax = 0.20;

fullPrice = price + (price * tax);
</code></pre>
<h3 id="空格与运算符-1"><a href="#空格与运算符-1" class="headerlink" title="空格与运算符"></a>空格与运算符</h3><p>通常运算符（= + - * /）前后需要添加空格</p>
<h3 id="代码缩进-1"><a href="#代码缩进-1" class="headerlink" title="代码缩进"></a>代码缩进</h3><p>通常使用 4 个空格来缩进代码块</p>
<h3 id="语句规则-1"><a href="#语句规则-1" class="headerlink" title="语句规则"></a>语句规则</h3><p>简单语句</p>
<ul>
<li>一条语句通常以分号来作为结束符</li>
</ul>
<p>复杂语句</p>
<ul>
<li>将左花括号放在第一行的结尾</li>
<li>左花括号前添加一空格</li>
<li>将右花括号独立放在一行</li>
<li>不要以分号结束一个复杂的声明</li>
</ul>
<pre><code class="js">var values = [&quot;Volvo&quot;, &quot;Saab&quot;, &quot;Fiat&quot;];

var person = {
    firstName: &quot;John&quot;,
    lastName: &quot;Doe&quot;,
    age: 50,
    eyeColor: &quot;blue&quot;
};

function toCelsius(fahrenheit) {return (5 / 9) * (fahrenheit - 32);
}

for (i = 0; i &lt; 5; i++) {x += i;}

if (time &lt; 20) {greeting = &quot;Good day&quot;;} else {greeting = &quot;Good evening&quot;;}
</code></pre>
<h3 id="对象规则-1"><a href="#对象规则-1" class="headerlink" title="对象规则"></a>对象规则</h3><p>对象定义的规则：</p>
<ul>
<li>将左花括号与类名放在同一行</li>
<li>冒号与属性值间有个空格</li>
<li>字符串使用双引号，数字不需要</li>
<li>最后一个属性 - 值对后面不要添加逗号</li>
<li>将右花括号独立放在一行，并以分号作为结束符号</li>
</ul>
<pre><code class="js">var person = {
    firstName: &quot;John&quot;,
    lastName: &quot;Doe&quot;,
    age: 50,
    eyeColor: &quot;blue&quot;
};
//or
var person = {firstName:&quot;John&quot;, lastName:&quot;Doe&quot;, age:50, eyeColor:&quot;blue&quot;};
</code></pre>
<h3 id="命名规则-1"><a href="#命名规则-1" class="headerlink" title="命名规则"></a>命名规则</h3><p>一般很多代码语言的命名规则都是类似的，例如:</p>
<ul>
<li>变量和函数为小驼峰法标识, 即除第一个单词之外，其他单词首字母大写（ lowerCamelCase）</li>
<li>全局变量为大写 (UPPERCASE)</li>
<li>常量 (如 PI) 为大写 (UPPERCASE)</li>
</ul>
<p>HTML 和 CSS 的横杠 (-) 字符:<br>HTML5 属性可以以 data- (如：data-quantity, data-price) 作为前缀<br>CSS 使用 - 来连接属性名 (font-size)</p>
<ul>
<li>通常在 JavaScript 中被认为是减法，所以不允许使用</li>
</ul>
<p>下划线:<br>很多程序员比较喜欢使用下划线 (如：date_of_birth), 特别是在 SQL 数据库中<br>PHP 语言通常都使用下划线</p>
<p>帕斯卡拼写法 (PascalCase):<br>帕斯卡拼写法 (PascalCase) 在 C 语言中语言较多</p>
<p>驼峰法：<br>JavaScript 中通常推荐使用驼峰法，jQuery 及其他 JavaScript 库都使用驼峰法<br>变量名不要以 $ 作为开始标记，会与很多 JavaScript 库冲突</p>
<hr>
<h1 id="JS-函数-1"><a href="#JS-函数-1" class="headerlink" title="JS 函数"></a>JS 函数</h1><h2 id="JavaScript-函数定义-1"><a href="#JavaScript-函数定义-1" class="headerlink" title="JavaScript 函数定义"></a>JavaScript 函数定义</h2><p>JavaScript 使用关键字 function 定义函数<br>函数可以通过声明定义，也可以是一个表达式</p>
<h3 id="函数声明-1"><a href="#函数声明-1" class="headerlink" title="函数声明"></a>函数声明</h3><p>函数声明后不会立即执行，会在我们需要的时候调用到</p>
<pre><code class="js">function functionName(parameters) {执行的代码}

function myFunction(a, b) {return a * b;}
</code></pre>
<h3 id="函数表达式-1"><a href="#函数表达式-1" class="headerlink" title="函数表达式"></a>函数表达式</h3><p>JavaScript 函数可以通过一个表达式定义<br>函数表达式可以存储在变量中</p>
<pre><code class="JavaScript">var x = function (a, b) {return a * b};

在函数表达式存储在变量后，变量也可作为一个函数使用：
var x = function (a, b) {return a * b};
var z = x(4, 3);

实际上，以上函数实际上是一个 匿名函数 (函数没有名称)
函数存储在变量中，不需要函数名称，通常通过变量名来调用
上述函数以分号结尾，因为它是一个执行语句
</code></pre>
<h3 id="Function-构造函数-1"><a href="#Function-构造函数-1" class="headerlink" title="Function() 构造函数"></a>Function() 构造函数</h3><p>函数通过关键字 function 定义<br>函数同样可以通过内置的 JavaScript 函数构造器（Function()）定义</p>
<pre><code class="JavaScript">var myFunction = new Function(&quot;a&quot;, &quot;b&quot;, &quot;return a * b&quot;);
var x = myFunction(4, 3);

// 等同于
var myFunction = function (a, b) {return a * b};
var x = myFunction(4, 3);
</code></pre>
<h3 id="函数提升-1"><a href="#函数提升-1" class="headerlink" title="函数提升"></a>函数提升</h3><p>提升（Hoisting）是 JavaScript 默认将当前作用域提升到前面去的的行为<br>提升（Hoisting）应用在变量的声明与函数的声明<br>因此，函数可以在声明之前调用：</p>
<pre><code class="JavaScript">myFunction(5);
function myFunction(y) {return y * y;}
使用表达式定义函数时无法提升
</code></pre>
<h3 id="自调用函数-1"><a href="#自调用函数-1" class="headerlink" title="自调用函数"></a>自调用函数</h3><p>函数表达式可以 “自调用”<br>自调用表达式会自动调用<br>如果表达式后面紧跟 () ，则会自动调用<br>不能自调用声明的函数<br>通过添加括号，来说明它是一个函数表达式：</p>
<pre><code class="JavaScript">(function () {var x = &quot;Hello!!&quot;;      // 我将调用自己})();
</code></pre>
<h3 id="函数可以作为一个值使用-1"><a href="#函数可以作为一个值使用-1" class="headerlink" title="函数可以作为一个值使用"></a>函数可以作为一个值使用</h3><p>JavaScript 函数作为一个值使用：</p>
<pre><code class="JavaScript">function myFunction(a, b) {return a * b;}

var x = myFunction(4, 3);
</code></pre>
<p>JavaScript 函数可作为表达式使用：</p>
<pre><code class="JavaScript">function myFunction(a, b) {return a * b;}

var x = myFunction(4, 3) * 2;
</code></pre>
<h3 id="函数是对象-1"><a href="#函数是对象-1" class="headerlink" title="函数是对象"></a>函数是对象</h3><p>在 JavaScript 中使用 typeof 操作符判断函数类型将返回 “function”<br>但是 JavaScript 函数描述为一个对象更加准确<br>JavaScript 函数有 属性 和 方法<br>arguments.length 属性返回函数调用过程接收到的参数个数</p>
<pre><code class="JavaScript">function myFunction(a, b) {return arguments.length;}
</code></pre>
<p>toString() 方法将函数作为一个字符串返回：</p>
<pre><code class="JavaScript">function myFunction(a, b) {return a * b;} 
var txt = myFunction.toString();

// 函数定义作为对象的属性，称之为对象方法
// 函数如果用于创建新的对象，称之为对象的构造函数
</code></pre>
<h3 id="箭头函数-1"><a href="#箭头函数-1" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>ES6 新增<br>箭头函数表达式的语法比普通函数表达式更简洁</p>
<pre><code class="JavaScript">(参数 1, 参数 2, …, 参数 N) =&gt; {函数声明}
(参数 1, 参数 2, …, 参数 N) =&gt; 表达式 (单一)
// 相当于：(参数 1, 参数 2, …, 参数 N) =&gt;{return 表达式;}

(单一参数) =&gt; {函数声明}
单一参数 =&gt; {函数声明}
// 只有一个参数

()=&gt; { 函数声明}
// 无参数

// ES5
var x = function(x, y) {return x * y;}
// ES6
const x = (x, y) =&gt; x * y;
</code></pre>
<p>有的箭头函数都没有自己的 this，不适合顶一个对象的方法<br>当我们使用箭头函数的时候，箭头函数会默认帮我们绑定外层 this 的值，所以在箭头函数中 this 的值和外层的 this 是一样的<br>箭头函数是不能提升的，所以需要在使用之前定义<br>使用 const 比使用 var 更安全，因为函数表达式始终是一个常量<br>如果函数部分只是一个语句，则可以省略 return 关键字和大括号 {}，这样做是一个比较好的习惯</p>
<pre><code class="JavaScript">const x = (x, y) =&gt; x * y;
// 等同于
const x = (x, y) =&gt; {return x * y};
</code></pre>
<hr>
<h2 id="JavaScript-函数参数-1"><a href="#JavaScript-函数参数-1" class="headerlink" title="JavaScript 函数参数"></a>JavaScript 函数参数</h2><p>JavaScript 函数对参数的值没有进行任何的检查</p>
<h3 id="函数显式参数-Parameters-与隐式参数-Arguments-1"><a href="#函数显式参数-Parameters-与隐式参数-Arguments-1" class="headerlink" title="函数显式参数 (Parameters) 与隐式参数 (Arguments)"></a>函数显式参数 (Parameters) 与隐式参数 (Arguments)</h3><p>函数显式参数在函数定义时列出<br>函数隐式参数在函数调用时传递给函数真正的值</p>
<pre><code class="JavaScript">functionName(parameter1, parameter2, parameter3) {// 要执行的代码……}
</code></pre>
<h3 id="参数规则-1"><a href="#参数规则-1" class="headerlink" title="参数规则"></a>参数规则</h3><p>JavaScript 函数定义显式参数时没有指定数据类型<br>JavaScript 函数对隐式参数没有进行类型检测<br>JavaScript 函数对隐式参数的个数没有进行检测</p>
<h3 id="默认参数-1"><a href="#默认参数-1" class="headerlink" title="默认参数"></a>默认参数</h3><p>如果函数在调用时未提供隐式参数，参数会默认设置为： undefined<br>ES6 支持函数带有默认参数，就判断 undefined 和 || 的操作</p>
<pre><code class="JavaScript">function myFunction(x, y = 10) {
    // y is 10 if not passed or undefined
    return x + y;
}

myFunction(0, 2) // 输出 2
myFunction(5); // 输出 15, y 参数的默认值
</code></pre>
<h3 id="arguments-对象-1"><a href="#arguments-对象-1" class="headerlink" title="arguments 对象"></a>arguments 对象</h3><p>JavaScript 函数有个内置的对象 arguments 对象<br>argument 对象包含了函数调用的参数数组<br>通过这种方式可以很方便的找到最大的一个参数的值</p>
<pre><code class="JavaScript">x = findMax(1, 123, 500, 115, 44, 88);

function findMax(){var i, max = arguments[0];

    if(arguments.length &lt; 2) return max;

    for (i = 0; i &lt; arguments.length; i++) {if (arguments[i] &gt; max){max = arguments[i];
        }
    }
    return max;
}
</code></pre>
<p>或者创建一个函数用来统计所有数值的和：</p>
<pre><code class="JavaScript">x = sumAll(1, 123, 500, 115, 44, 88);

function sumAll() {
    var i, sum = 0;
    for (i = 0; i &lt; arguments.length; i++) {sum += arguments[i];
    }
    return sum;
}
</code></pre>
<h3 id="通过值传递参数-1"><a href="#通过值传递参数-1" class="headerlink" title="通过值传递参数"></a>通过值传递参数</h3><p>在函数中调用的参数是函数的隐式参数<br>JavaScript 隐式参数通过值来传递：函数仅仅只是获取值<br>如果函数修改参数的值，不会修改显式参数的初始值（在函数外定义）<br>隐式参数的改变在函数外是不可见的</p>
<h3 id="通过对象传递参数-1"><a href="#通过对象传递参数-1" class="headerlink" title="通过对象传递参数"></a>通过对象传递参数</h3><p>在 JavaScript 中，可以引用对象的值<br>因此我们在函数内部修改对象的属性就会修改其初始的值<br>修改对象属性可作用于函数外部（全局变量）<br>修改对象属性在函数外是可见的</p>
<hr>
<h2 id="JavaScript-函数调用-1"><a href="#JavaScript-函数调用-1" class="headerlink" title="JavaScript 函数调用"></a>JavaScript 函数调用</h2><p>JavaScript 函数有 4 种调用方式<br>每种方式的不同在于 this 的初始化</p>
<h3 id="this-关键字-1"><a href="#this-关键字-1" class="headerlink" title="this 关键字"></a>this 关键字</h3><p>一般而言，在 JavaScript 中，this 指向函数执行时的当前对象</p>
<h3 id="调用-JavaScript-函数-1"><a href="#调用-JavaScript-函数-1" class="headerlink" title="调用 JavaScript 函数"></a>调用 JavaScript 函数</h3><p>函数中的代码在函数被调用后执行</p>
<h3 id="作为一个函数调用-1"><a href="#作为一个函数调用-1" class="headerlink" title="作为一个函数调用 "></a>作为一个函数调用 </h3><pre><code class="JavaScript">function myFunction(a, b) {return a * b;}
myFunction(10, 2);           // myFunction(10, 2) 返回 20
</code></pre>
<p>以上函数不属于任何对象。但是在 JavaScript 中它始终是默认的全局对象<br>在 HTML 中默认的全局对象是 HTML 页面本身，所以函数是属于 HTML 页面<br>在浏览器中的页面对象是浏览器窗口 (window 对象)。以上函数会自动变为 window 对象的函数<br>myFunction()和 window.myFunction() 是一样的：</p>
<pre><code class="JavaScript">function myFunction(a, b) {return a * b;}
window.myFunction(10, 2);    // window.myFunction(10, 2) 返回 20
</code></pre>
<h3 id="全局对象-1"><a href="#全局对象-1" class="headerlink" title="全局对象"></a>全局对象</h3><p>当函数没有被自身的对象调用时 this 的值就会变成全局对象<br>在 web 浏览器中全局对象是浏览器窗口（window 对象）<br>该实例返回 this 的值是 window 对象：</p>
<pre><code class="JavaScript">function myFunction(){return this;}
myFunction();                // 返回 window 对象
// 函数作为全局对象调用，会使 this 的值成为全局对象
// 使用 window 对象作为一个变量容易造成程序崩溃
</code></pre>
<h3 id="函数作为方法调用-1"><a href="#函数作为方法调用-1" class="headerlink" title="函数作为方法调用"></a>函数作为方法调用</h3><p>在 JavaScript 中你可以将函数定义为对象的方法<br>以下实例创建了一个对象 (myObject), 对象有两个属性 (firstName 和 lastName), 及一个方法 (fullName)：</p>
<pre><code class="JavaScript">var myObject = {
    firstName:&quot;John&quot;,
    lastName: &quot;Doe&quot;,
    fullName: function (){return this.firstName + &quot; &quot; + this.lastName;}
}
myObject.fullName();         // 返回 &quot;John Doe&quot;
</code></pre>
<p>fullName 方法是一个函数，函数属于对象，myObject 是函数的所有者<br>this 对象，拥有 JavaScript 代码，实例中 this 的值为 myObject 对象<br>测试以下！修改 fullName 方法并返回 this 值：</p>
<pre><code class="JavaScript">var myObject = {
    firstName:&quot;John&quot;,
    lastName: &quot;Doe&quot;,
    fullName: function (){return this;}
}
myObject.fullName();          // 返回 [object Object] (所有者对象)
// 函数作为对象方法调用，会使得 this 的值成为对象本身
</code></pre>
<h3 id="使用构造函数调用函数-1"><a href="#使用构造函数调用函数-1" class="headerlink" title="使用构造函数调用函数"></a>使用构造函数调用函数</h3><p>如果函数调用前使用了 new 关键字, 则是调用了构造函数<br>这看起来就像创建了新的函数，但实际上 JavaScript 函数是重新创建的对象：</p>
<pre><code class="JavaScript">// 构造函数:
function myFunction(arg1, arg2) {
    this.firstName = arg1;
    this.lastName  = arg2;
}

// This    creates a new object
var x = new myFunction(&quot;John&quot;,&quot;Doe&quot;);
x.firstName;                             // 返回 &quot;John&quot;
// 构造函数的调用会创建一个新的对象。新对象会继承构造函数的属性和方法
// 构造函数中 this 关键字没有任何的值
//this 的值在函数调用实例化对象 (new object) 时创建
</code></pre>
<h3 id="作为函数方法调用函数-1"><a href="#作为函数方法调用函数-1" class="headerlink" title="作为函数方法调用函数"></a>作为函数方法调用函数</h3><p>在 JavaScript 中，函数是对象，JavaScript 函数有它的属性和方法<br>call()和 apply() 是预定义的函数方法，两个方法可用于调用函数，两个方法的第一个参数必须是对象本身</p>
<pre><code class="JavaScript">function myFunction(a, b) {return a * b;}
myObject = myFunction.call(myObject, 10, 2);     // 返回 20

function myFunction(a, b) {return a * b;}
myArray = [10, 2];
myObject = myFunction.apply(myObject, myArray);  // 返回 20
</code></pre>
<p>两个方法都使用了对象本身作为第一个参数，两者的区别在于第二个参数： apply 传入的是一个参数数组，也就是将多个参数组合成为一个数组传入，而 call 则作为 call 的参数传入（从第二个参数开始）<br>在 JavaScript 严格模式 (strict mode) 下, 在调用函数时第一个参数会成为 this 的值， 即使该参数不是一个对象<br>在 JavaScript 非严格模式 (non-strict mode) 下, 如果第一个参数的值是 null 或 undefined, 它将使用全局对象替代<br>通过 call()或 apply() 方法你可以设置 this 的值, 且作为已存在对象的新方法调用</p>
<hr>
<h2 id="JavaScript-闭包-2"><a href="#JavaScript-闭包-2" class="headerlink" title="JavaScript 闭包"></a>JavaScript 闭包</h2><p>JavaScript 变量可以是局部变量或全局变量<br>私有变量可以用到闭包</p>
<h3 id="全局变量-5"><a href="#全局变量-5" class="headerlink" title="全局变量"></a>全局变量</h3><p>函数可以访问由函数内部定义的变量</p>
<pre><code class="JavaScript">function myFunction() {
    var a = 4;
    return a * a;
}
</code></pre>
<p>函数也可以访问函数外部定义的变量</p>
<pre><code class="JavaScript">var a = 4;
function myFunction(){return a * a;}
</code></pre>
<p>后面一个实例中， a 是一个 全局 变量<br>在 web 页面中全局变量属于 window 对象<br>全局变量可应用于页面上的所有脚本<br>在第一个实例中， a 是一个 局部 变量<br>局部变量只能用于定义它函数内部，对于其他的函数或脚本代码是不可用的<br>全局和局部变量即便名称相同，它们也是两个不同的变量，修改其中一个，不会影响另一个的值<br>变量声明时如果不使用 var 关键字，那么它就是一个全局变量，即便它在函数内定义</p>
<h3 id="计数器困境-1"><a href="#计数器困境-1" class="headerlink" title="计数器困境"></a>计数器困境</h3><p>可以使用全局变量，函数设置计数器递增</p>
<pre><code class="JavaScript">var counter = 0;

function add(){return counter += 1;}

add();
add();
add();

// 计数器现在为 3
</code></pre>
<p>计数器数值在执行 add() 函数时发生变化<br>但问题来了，页面上的任何脚本都能改变计数器，即便没有调用 add() 函数<br>如果我在函数内声明计数器，如果没有调用函数将无法修改计数器的值：</p>
<pre><code class="JavaScript">function add() {
    var counter = 0;
    return counter += 1;
}

add();
add();
add();

// 本意是想输出 3, 但事与愿违，输出的都是 1 !
</code></pre>
<h3 id="JavaScript-内嵌函数-1"><a href="#JavaScript-内嵌函数-1" class="headerlink" title="JavaScript 内嵌函数"></a>JavaScript 内嵌函数</h3><p>所有函数都能访问全局变量<br>实际上，在 JavaScript 中，所有函数都能访问它们上一层的作用域<br>JavaScript 支持嵌套函数，嵌套函数可以访问上一层的函数变量<br>该实例中，内嵌函数 plus() 可以访问父函数的 counter 变量：</p>
<pre><code class="JavaScript">function add() {
    var counter = 0;
    function plus(){counter += 1;}
    plus();   
    return counter;
}
</code></pre>
<p>如果我们能在外部访问 plus() 函数，这样就能解决计数器的困境<br>我们同样需要确保 counter = 0 只执行一次<br>我们需要闭包</p>
<h3 id="JavaScript-闭包-3"><a href="#JavaScript-闭包-3" class="headerlink" title="JavaScript 闭包"></a>JavaScript 闭包</h3><p>自我调用</p>
<pre><code class="JavaScript">var add = (function () {
    var counter = 0;
    return function (){return counter += 1;}
})();

add();
add();
add();

// 计数器为 3
</code></pre>
<h3 id="实例解析-1"><a href="#实例解析-1" class="headerlink" title="实例解析"></a>实例解析</h3><p>变量 add 指定了函数自我调用的返回字值<br>自我调用函数只执行一次，设置计数器为 0，并返回函数表达式<br>add 变量可以作为一个函数使用，非常棒的部分是它可以访问函数上一层作用域的计数器<br>这个叫作 JavaScript 闭包，它使得函数拥有私有变量变成可能<br>计数器受匿名函数的作用域保护，只能通过 add 方法修改<br>闭包是一种保护私有变量的机制，在函数执行时形成私有的作用域，保护里面的私有变量不受外界干扰<br>直观的说就是形成一个不销毁的栈环境</p>
<hr>
<h1 id="JS-DOM-1"><a href="#JS-DOM-1" class="headerlink" title="JS DOM"></a>JS DOM</h1><h2 id="JavaScript-HTML-DOM-简介-1"><a href="#JavaScript-HTML-DOM-简介-1" class="headerlink" title="JavaScript HTML DOM 简介"></a>JavaScript HTML DOM 简介</h2><p>通过 HTML DOM，可访问 JavaScript HTML 文档的所有元素</p>
<h3 id="HTML-DOM（文档对象模型）-1"><a href="#HTML-DOM（文档对象模型）-1" class="headerlink" title="HTML DOM（文档对象模型）"></a>HTML DOM（文档对象模型）</h3><p>当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）<br>HTML DOM 模型被构造为对象的树：<br><img src="media/15859150613859/15861362970794.jpg" alt="-w517">通过可编程的对象模型，JavaScript 获得了足够的能力来创建动态的 HTML</p>
<ul>
<li>JavaScript 能够改变页面中的所有 HTML 元素</li>
<li>JavaScript 能够改变页面中的所有 HTML 属性</li>
<li>JavaScript 能够改变页面中的所有 CSS 样式</li>
<li>JavaScript 能够对页面中的所有事件作出反应</li>
</ul>
<h3 id="查找-HTML-元素-1"><a href="#查找-HTML-元素-1" class="headerlink" title="查找 HTML 元素"></a>查找 HTML 元素</h3><p>通常通过 JavaScript，操作 HTML 元素<br>必须首先找到元素</p>
<ul>
<li>通过 id getElementById</li>
<li>通过标签名 getElementByTagName</li>
<li>通过类名 getElementByClassName</li>
</ul>
<h3 id="通过-id-查找-HTML-元素-1"><a href="#通过-id-查找-HTML-元素-1" class="headerlink" title="通过 id 查找 HTML 元素"></a>通过 id 查找 HTML 元素</h3><p>在 DOM 中查找 HTML 元素的最简单的方法，是通过使用元素的 id</p>
<pre><code class="JavaScript">var x=document.getElementById(&quot;intro&quot;);
</code></pre>
<p>如果找到该元素，则该方法将以对象（在 x 中）的形式返回该元素<br>如果未找到该元素，则 x 将包含 null</p>
<h3 id="通过标签名查找-HTML-元素-1"><a href="#通过标签名查找-HTML-元素-1" class="headerlink" title="通过标签名查找 HTML 元素"></a>通过标签名查找 HTML 元素</h3><p>本例查找 id=”main” 的元素，然后查找 id=”main” 元素中的所有 </p><p> 元素：</p>
<pre><code class="JavaScript">var x=document.getElementById(&quot;main&quot;);
var y=x.getElementsByTagName(&quot;p&quot;);
</code></pre>
<h3 id="通过类名找到-HTML-元素-1"><a href="#通过类名找到-HTML-元素-1" class="headerlink" title="通过类名找到 HTML 元素"></a>通过类名找到 HTML 元素</h3><p>本例通过 getElementsByClassName 函数来查找 class=”intro” 的元素：</p>
<pre><code class="JavaScript">var x=document.getElementsByClassName(&quot;intro&quot;);
</code></pre>
<hr>
<h2 id="JavaScript-HTML-DOM-改变-HTML-1"><a href="#JavaScript-HTML-DOM-改变-HTML-1" class="headerlink" title="JavaScript HTML DOM - 改变 HTML"></a>JavaScript HTML DOM - 改变 HTML</h2><p>HTML DOM 允许 JavaScript 改变 HTML 元素的内容</p>
<h3 id="改变-HTML-输出流-1"><a href="#改变-HTML-输出流-1" class="headerlink" title="改变 HTML 输出流"></a>改变 HTML 输出流</h3><p>JavaScript 能够创建动态的 HTML 内容<br>在 JavaScript 中，<code>document.write()</code> 可用于直接向 HTML 输出流写内容</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;

&lt;script&gt;
document.write(Date());
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>绝对不要在文档 (DOM) 加载完成之后使用 document.write()，这会覆盖该文档</p>
<h3 id="改变-HTML-内容-1"><a href="#改变-HTML-内容-1" class="headerlink" title="改变 HTML 内容"></a>改变 HTML 内容</h3><p>修改 HTML 内容的最简单的方法是使用 <code>innerHTML</code> 属性</p>
<pre><code class="JavaScript">document.getElementById(id).innerHTML= 新的 HTML
</code></pre>
<pre><code class="html">&lt;html&gt;
&lt;body&gt;

&lt;p id=&quot;p1&quot;&gt;Hello World!&lt;/p&gt;

&lt;script&gt;
document.getElementById(&quot;p1&quot;).innerHTML=&quot;新文本!&quot;;
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;

&lt;h1 id=&quot;header&quot;&gt;Old Header&lt;/h1&gt;

&lt;script&gt;
var element=document.getElementById(&quot;header&quot;);
element.innerHTML=&quot;新标题&quot;;
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="改变-HTML-属性-1"><a href="#改变-HTML-属性-1" class="headerlink" title="改变 HTML 属性"></a>改变 HTML 属性</h3><p>语法</p>
<pre><code class="JavaScript">document.getElementById(id).attribute= 新属性值
</code></pre>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;

&lt;img id=&quot;image&quot; src=&quot;smiley.gif&quot;&gt;

&lt;script&gt;
document.getElementById(&quot;image&quot;).src=&quot;landscape.jpg&quot;;
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<hr>
<h2 id="JavaScript-HTML-DOM-改变-CSS-1"><a href="#JavaScript-HTML-DOM-改变-CSS-1" class="headerlink" title="JavaScript HTML DOM - 改变 CSS"></a>JavaScript HTML DOM - 改变 CSS</h2><p>HTML DOM 允许 JavaScript 改变 HTML 元素的样式</p>
<h3 id="改变-HTML-样式-1"><a href="#改变-HTML-样式-1" class="headerlink" title="改变 HTML 样式"></a>改变 HTML 样式</h3><p>语法</p>
<pre><code class="JavaScript">document.getElementById(id).style.property= 新样式
</code></pre>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt; 牛客教程 (nowcoder.com)&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;p id=&quot;p1&quot;&gt;Hello World!&lt;/p&gt;
    &lt;p id=&quot;p2&quot;&gt;Hello World!&lt;/p&gt;
    &lt;script&gt;
        document.getElementById(&quot;p2&quot;).style.color=&quot;blue&quot;;
        document.getElementById(&quot;p2&quot;).style.fontFamily=&quot;Arial&quot;;
        document.getElementById(&quot;p2&quot;).style.fontSize=&quot;larger&quot;;
    &lt;/script&gt;
    &lt;p&gt; 以上段落通过脚本修改。&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="使用事件-1"><a href="#使用事件-1" class="headerlink" title="使用事件"></a>使用事件</h3><p>HTML DOM 允许我们通过触发事件来执行代码</p>
<ul>
<li>元素被点击</li>
<li>页面加载完成</li>
<li>输入框被修改</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;

&lt;h1 id=&quot;id1&quot;&gt; 我的标题 1&lt;/h1&gt;
&lt;button type=&quot;button&quot;
onclick=&quot;document.getElementById(&#39;id1&#39;).style.color=&#39;red&#39;&quot;&gt;
点我!&lt;/button&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<hr>
<h2 id="JavaScript-HTML-DOM-事件-1"><a href="#JavaScript-HTML-DOM-事件-1" class="headerlink" title="JavaScript HTML DOM 事件"></a>JavaScript HTML DOM 事件</h2><p>HTML DOM 使 JavaScript 有能力对 HTML 事件做出反应</p>
<h3 id="对事件做出反应-1"><a href="#对事件做出反应-1" class="headerlink" title="对事件做出反应"></a>对事件做出反应</h3><p>我们可以在事件发生时执行 JavaScript，比如当用户在 HTML 元素上点击时<br>如需在用户点击某个元素时执行代码，请向一个 HTML 事件属性添加 JavaScript 代码：<br><code>onclick = JavaScript</code><br>HTML 事件的例子：</p>
<ul>
<li>当用户点击鼠标</li>
<li>当网页已加载</li>
<li>当图像已加载</li>
<li>当鼠标移动到元素上</li>
<li>当输入字段被改变</li>
<li>当提交 HTML 表单</li>
<li>当用户触发按键</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
&lt;h1 onclick=&quot;this.innerHTML=&#39;Ooops!&#39;&quot;&gt; 点击文本!&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;script&gt;
function changetext(id) {id.innerHTML=&quot;Ooops!&quot;;}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1 onclick=&quot;changetext(this)&quot;&gt; 点击文本!&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="HTML-事件属性-1"><a href="#HTML-事件属性-1" class="headerlink" title="HTML 事件属性"></a>HTML 事件属性</h3><p>如需向 HTML 元素分配事件，可以使用事件属性</p>
<pre><code class="html">&lt;button onclick=&quot;displayDate()&quot;&gt; 点这里 &lt;/button&gt;
// 在上面的例子中，名为 displayDate 的函数将在按钮被点击时执行
</code></pre>
<h3 id="使用-HTML-DOM-来分配事件-1"><a href="#使用-HTML-DOM-来分配事件-1" class="headerlink" title="使用 HTML DOM 来分配事件"></a>使用 HTML DOM 来分配事件</h3><p>HTML DOM 允许使用 JavaScript 来向 HTML 元素分配事件</p>
<pre><code class="html">&lt;script&gt;
    document.getElementById(&quot;myBtn&quot;).onclick=function(){displayDate()};
&lt;/script&gt;
// 在上面的例子中，名为 displayDate 的函数被分配给 id=&quot;myBtn&quot; 的 HTML 元素
按钮点击时 Javascript 函数将会被执行
</code></pre>
<h3 id="onload-和-onunload-事件-1"><a href="#onload-和-onunload-事件-1" class="headerlink" title="onload 和 onunload 事件"></a>onload 和 onunload 事件</h3><p>onload 和 onunload 事件会在用户进入或离开页面时被触发<br>onload 事件可用于检测访问者的浏览器类型和浏览器版本，并基于这些信息来加载网页的正确版本<br>onload 和 onunload 事件可用于处理 cookie</p>
<pre><code class="html">&lt;body onload = &quot;checkCookies()&quot;
</code></pre>
<h3 id="onchange-事件-1"><a href="#onchange-事件-1" class="headerlink" title="onchange 事件"></a>onchange 事件</h3><p>onchange 事件常结合对输入字段的验证来使用<br>下面是一个如何使用 onchange 的例子，当用户改变输入字段的内容时，会调用 upperCae() 函数</p>
<pre><code class="html">&lt;input type = &quot;text&quot; id = &quot;fname&quot; onchange = &quot;upperCase()&quot;&gt;
</code></pre>
<h3 id="onmouseover-和-onmouseout-事件-1"><a href="#onmouseover-和-onmouseout-事件-1" class="headerlink" title="onmouseover 和 onmouseout 事件"></a>onmouseover 和 onmouseout 事件</h3><p>onmouseover 和 onmouseout 事件可用于在用户的鼠标移动至 HTMl 元素上方或者移动出元素时触发函数</p>
<pre><code class="html">&lt;div onmouseover = &quot;mOver(this)&quot; onmouseout = &quot;mOut(this)&quot;&gt;Mouse Over Me&lt;/div&gt;
</code></pre>
<h3 id="onmousedown、onmouseup-以及-onclick-事件-1"><a href="#onmousedown、onmouseup-以及-onclick-事件-1" class="headerlink" title="onmousedown、onmouseup 以及 onclick 事件"></a>onmousedown、onmouseup 以及 onclick 事件</h3><p>onmousedownm，onmouseup 以及 onclick 构成了鼠标点击事件的所有部分，首先当点击鼠标摁钮时，会触发 onmousedown 事件，当释放鼠标摁钮时，会触发 onmouseup 事件，最后，当完成鼠标点击时，会触发 onclick 事件</p>
<hr>
<h2 id="JavaScript-HTML-DOM-EventListener-1"><a href="#JavaScript-HTML-DOM-EventListener-1" class="headerlink" title="JavaScript HTML DOM EventListener"></a>JavaScript HTML DOM EventListener</h2><h3 id="addEventListener-方法-1"><a href="#addEventListener-方法-1" class="headerlink" title="addEventListener() 方法"></a>addEventListener() 方法</h3><hr>
<p>title: JavaScript 基础汇总<br>date: 2020-04-03 17:10:48<br>tags:</p>
<ul>
<li>前端</li>
<li>面试<br>categories: </li>
<li>面试汇总</li>
</ul>
<hr>
<h1 id="JS-基础-2"><a href="#JS-基础-2" class="headerlink" title="JS 基础"></a>JS 基础</h1><!--more-->
<h2 id="JavaScript-简介-2"><a href="#JavaScript-简介-2" class="headerlink" title="JavaScript 简介"></a>JavaScript 简介</h2><p>JavaScript 是一种轻量级的编程脚本语言<br>ECMA-262 是 JavaScript 标准的官方名称<br>JavaScript 由 Brendan Eich 发明，它于 1995 年出现在 Netscape 中，并于 1997 年被 ECMA 采纳（一个标准协会）</p>
<hr>
<h2 id="JavaScript-用法-2"><a href="#JavaScript-用法-2" class="headerlink" title="JavaScript 用法"></a>JavaScript 用法</h2><h3 id="内部用法-2"><a href="#内部用法-2" class="headerlink" title="内部用法"></a>内部用法</h3><p>HTML 中的脚本必须位于 <code>&lt;script&gt; &lt;/script&gt;</code> 之间<br>脚本可被放置在 HTML 页面的 <code>&lt;body&gt; &lt;head&gt;</code> 部分中</p>
<h3 id="外部用法-2"><a href="#外部用法-2" class="headerlink" title="外部用法"></a>外部用法</h3><p>如需使用外部 JS 文件，请在 <code>&lt;script&gt;&lt;/script&gt;</code> 标签的 ‘src’ 属性中引入</p>
<hr>
<h2 id="JavaScript-输出-2"><a href="#JavaScript-输出-2" class="headerlink" title="JavaScript 输出"></a>JavaScript 输出</h2><p>JavaScript 没有任何打印或者输出的函数<br>JavaScript 可以通过不同的方式来输出数据：</p>
<ul>
<li>使用 <code>window.alert()</code> 弹出警告框</li>
<li>使用 <code>document.write()</code> 将内容写入 HTML 文档中</li>
<li>使用 <code>innerHTML</code> 写入到 HTML 元素</li>
<li>使用 <code>console.log()</code> 写入浏览器控制台</li>
<li>使用 <code>document.getElementById(id)</code> 来访问某个 HTML 元素，使用 ‘id’ 属性来标识 HTML 元素，并 <code>innerHTML</code> 来获取或者插入内容</li>
</ul>
<hr>
<h2 id="JavaScript-语法-2"><a href="#JavaScript-语法-2" class="headerlink" title="JavaScript 语法"></a>JavaScript 语法</h2><p>JavaScript 是一个程序语言，语法规则定义了语言结构</p>
<h3 id="JavaScript-字面量-2"><a href="#JavaScript-字面量-2" class="headerlink" title="JavaScript 字面量"></a>JavaScript 字面量</h3><p>在编程语言中，一般固定值成为字面量</p>
<ul>
<li>数字 <code>Number</code> 可以是整数或者小数或是科学计数<br>  <code>123 3.14</code></li>
<li>字符串 <code>String</code> 可以使用单引号或双引号<br>  <code>&quot;jack&quot; &#39;jack&#39;</code></li>
<li>数组 <code>Array</code> 定义一个数组<br>  <code>[20,3004,32,230]</code></li>
<li>对象 <code>Object</code> 定义一个对象<br>  <code>{firstName:&quot;jack&quot;,lastName:&quot;doe&quot;,age:40}</code></li>
<li>函数 <code>Function</code> 定义一个函数<br>  <code>function myFunction(a,b){return a+b}</code></li>
</ul>
<h3 id="JavaScript-变量-2"><a href="#JavaScript-变量-2" class="headerlink" title="JavaScript 变量"></a>JavaScript 变量</h3><p>编程语言中，变量用于存储数据值<br>JavaScript 使用关键字 <code>var</code> 来定义变量，使用 <code>=</code> 来为变量赋值</p>
<pre><code class="JavaScript">var x, length
x = 5
length = 6
</code></pre>
<p>变量可以通过变量名访问，通常可变，字面量是一个恒定的值<br>变量是一个名称，字面量是一个值</p>
<h3 id="JavaScript-操作符-2"><a href="#JavaScript-操作符-2" class="headerlink" title="JavaScript 操作符"></a>JavaScript 操作符</h3><p>JavaScript 使用算术运算符来计算值</p>
<pre><code class="JavaScript">(5+6)*10
</code></pre>
<p>JavaScript 使用赋值运算符给变量赋值</p>
<pre><code class="JavaScript">x = 5
y = 6
z = (x+y)*10
</code></pre>
<p>JavaScript 语言有多种类型运算符：</p>
<ul>
<li>赋值，算术和位运算符<br>  <code>= + - * /</code></li>
<li>条件，比较和逻辑运算符<br>  <code>== != &lt; &gt;</code></li>
</ul>
<h3 id="JavaScript-语句-4"><a href="#JavaScript-语句-4" class="headerlink" title="JavaScript 语句"></a>JavaScript 语句</h3><p>在 HTML 中，JavaScript 语句向浏览器发出的命令用分号分隔</p>
<pre><code class="JavaScript">x = 5 + 6
y = x * 5
</code></pre>
<h3 id="JavaScript-关键字-2"><a href="#JavaScript-关键字-2" class="headerlink" title="JavaScript 关键字"></a>JavaScript 关键字</h3><table>
<thead>
<tr>
<th style="text-align:center">abstract</th>
<th style="text-align:center">else</th>
<th style="text-align:center">instanceof</th>
<th style="text-align:center">super</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">enum</td>
<td style="text-align:center">int</td>
<td style="text-align:center">switch</td>
</tr>
<tr>
<td style="text-align:center">break</td>
<td style="text-align:center">export</td>
<td style="text-align:center">interface</td>
<td style="text-align:center">synchronized</td>
</tr>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">extends</td>
<td style="text-align:center">let</td>
<td style="text-align:center">this</td>
</tr>
<tr>
<td style="text-align:center">case</td>
<td style="text-align:center">false</td>
<td style="text-align:center">long</td>
<td style="text-align:center">throw</td>
</tr>
<tr>
<td style="text-align:center">catch</td>
<td style="text-align:center">final</td>
<td style="text-align:center">native</td>
<td style="text-align:center">throws</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">finally</td>
<td style="text-align:center">new</td>
<td style="text-align:center">transient</td>
</tr>
<tr>
<td style="text-align:center">class</td>
<td style="text-align:center">float</td>
<td style="text-align:center">null</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center">const</td>
<td style="text-align:center">for</td>
<td style="text-align:center">package</td>
<td style="text-align:center">try</td>
</tr>
<tr>
<td style="text-align:center">continue</td>
<td style="text-align:center">function</td>
<td style="text-align:center">private</td>
<td style="text-align:center">typeof</td>
</tr>
<tr>
<td style="text-align:center">debugger</td>
<td style="text-align:center">goto</td>
<td style="text-align:center">protected</td>
<td style="text-align:center">var</td>
</tr>
<tr>
<td style="text-align:center">default</td>
<td style="text-align:center">if</td>
<td style="text-align:center">public</td>
<td style="text-align:center">void</td>
</tr>
<tr>
<td style="text-align:center">delete</td>
<td style="text-align:center">implements</td>
<td style="text-align:center">return</td>
<td style="text-align:center">volatile</td>
</tr>
<tr>
<td style="text-align:center">do</td>
<td style="text-align:center">import</td>
<td style="text-align:center">short</td>
<td style="text-align:center">while</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">in</td>
<td style="text-align:center">static</td>
<td style="text-align:center">with</td>
</tr>
</tbody>
</table>
<h3 id="JavaScript-注释-4"><a href="#JavaScript-注释-4" class="headerlink" title="JavaScript 注释"></a>JavaScript 注释</h3><p>双斜杠 <code>//</code> 后的内容会被浏览器忽略</p>
<h3 id="JavaScript-数据类型-8"><a href="#JavaScript-数据类型-8" class="headerlink" title="JavaScript 数据类型"></a>JavaScript 数据类型</h3><pre><code class="JavaScript">var length = 16;                                  // Number 通过数字字面量赋值
var points = x * 10;                              // Number 通过表达式字面量赋值
var lastName = &quot;Johnson&quot;;                         // String 通过字符串字面量赋值
var cars = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;];              // Array  通过数组字面量赋值
var person = {firstName:&quot;John&quot;, lastName:&quot;Doe&quot;};  // Object 通过对象字面量赋值
</code></pre>
<h3 id="JavaScript-字符集-2"><a href="#JavaScript-字符集-2" class="headerlink" title="JavaScript 字符集"></a>JavaScript 字符集</h3><p>JavaScript 使用 Unicode 字符集</p>
<hr>
<h2 id="JavaScript-语句-5"><a href="#JavaScript-语句-5" class="headerlink" title="JavaScript 语句"></a>JavaScript 语句</h2><p>JavaScript 语句向浏览器发出命令告诉浏览器该做什么<br>下面的 JavaScript 语句向 id=”demo” 的 HTML 元素输出文本 “你好 Dolly” ：</p>
<pre><code class="JavaScript">document.getElementById(&quot;demo&quot;).innerHTML = &quot;你好 Dolly&quot;
</code></pre>
<h3 id="分号-2"><a href="#分号-2" class="headerlink" title="分号"></a>分号</h3><p>分号用于分隔 JavaScript 语句</p>
<pre><code class="JavaScript">a = 5;
b = 6;
c = a + b;
// 或
a = 5; b = 6; c = a + b;
</code></pre>
<h3 id="JavaScript-代码-2"><a href="#JavaScript-代码-2" class="headerlink" title="JavaScript 代码"></a>JavaScript 代码</h3><p>JavaScript 代码是 JavaScript 语句的序列<br>浏览器按照便携顺序依次执行每条语句</p>
<pre><code class="JavaScript">document.getElementById(&quot;demo&quot;).innerHTML = &quot;hello Dolly&quot;
document.getElementById(&quot;myDiv&quot;).innerHTML = &quot;how are you&quot;
</code></pre>
<h3 id="JavaScript-代码块-2"><a href="#JavaScript-代码块-2" class="headerlink" title="JavaScript 代码块"></a>JavaScript 代码块</h3><p>JavaScript 可以分批地组合起来<br>代码块以左花括号开始，以右花括号结束<br>代码块的作用是一并地执行语句序列</p>
<pre><code class="JavaScript">function myFunciton(){document.getElementById(&quot;demo&quot;).innerHTML = &quot;hello Dolly&quot;
    document.getElementById(&quot;myDiv&quot;).innerHTML = &quot;how are you&quot;
}
</code></pre>
<h3 id="JavaScript-语句标识符-2"><a href="#JavaScript-语句标识符-2" class="headerlink" title="JavaScript 语句标识符"></a>JavaScript 语句标识符</h3><p>JavaScript 语句通常以一个 语句标识符 为开始，并执行该语句<br>语句标识符是保留关键字不能作为变量名使用</p>
<table>
<thead>
<tr>
<th style="text-align:center">语句</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">break</td>
<td style="text-align:center">用于跳出循环</td>
</tr>
<tr>
<td style="text-align:center">catch</td>
<td style="text-align:center">语句块，在 try 语句块执行出错时执行 catch 语句块</td>
</tr>
<tr>
<td style="text-align:center">continue</td>
<td style="text-align:center">跳出循环中的一个迭代</td>
</tr>
<tr>
<td style="text-align:center">do…while</td>
<td style="text-align:center">执行一个语句块，在条件语句为 true 时继续执行该语句块</td>
</tr>
<tr>
<td style="text-align:center">for</td>
<td style="text-align:center">在条件语句为 true 时，可以将代码块执行指定的次数</td>
</tr>
<tr>
<td style="text-align:center">for…in</td>
<td style="text-align:center">用于遍历数组或者对象的属性（对数组或者对象的属性进行循环操作）</td>
</tr>
<tr>
<td style="text-align:center">function</td>
<td style="text-align:center">定义一个函数</td>
</tr>
<tr>
<td style="text-align:center">if…else</td>
<td style="text-align:center">用于基于不同的条件来执行不同的动作</td>
</tr>
<tr>
<td style="text-align:center">return</td>
<td style="text-align:center">退出函数</td>
</tr>
<tr>
<td style="text-align:center">switch</td>
<td style="text-align:center">用于基于不同的条件来执行不同的动作</td>
</tr>
<tr>
<td style="text-align:center">throw</td>
<td style="text-align:center">抛出（生成）错误</td>
</tr>
<tr>
<td style="text-align:center">try</td>
<td style="text-align:center">实现错误处理，与 catch 一同使用</td>
</tr>
<tr>
<td style="text-align:center">var</td>
<td style="text-align:center">声明一个变量</td>
</tr>
<tr>
<td style="text-align:center">while</td>
<td style="text-align:center">当条件语句为 true 时，执行语句块</td>
</tr>
</tbody>
</table>
<h3 id="空格-2"><a href="#空格-2" class="headerlink" title="空格"></a>空格</h3><p>JavaScript 会忽略多余的空格，可以向脚本添加空格，来提高其可读性</p>
<pre><code class="JavaScript">var person=&quot;Jack&quot;
var person = &quot;Jack&quot;
</code></pre>
<h3 id="对代码进行折行-2"><a href="#对代码进行折行-2" class="headerlink" title="对代码进行折行"></a>对代码进行折行</h3><p>可以在文本字符串中使用反斜杠对代码进行换行</p>
<pre><code class="JavaScript">document.write(&quot;你好 \n 世界!&quot;)
</code></pre>
<hr>
<h2 id="JavaScript-注释-5"><a href="#JavaScript-注释-5" class="headerlink" title="JavaScript 注释"></a>JavaScript 注释</h2><p>JavaScript 注释可用于提高代码可读性<br>JavaScript 不会执行注释</p>
<h3 id="JavaScript-单行注释-2"><a href="#JavaScript-单行注释-2" class="headerlink" title="JavaScript 单行注释"></a>JavaScript 单行注释</h3><p>单行注释以 <code>//</code> 开头</p>
<pre><code class="JavaScript">// 输出标题
document.getElementById(&quot;myH1&quot;).innerHTML = &quot;欢迎来到我的主页&quot;
// 输出段落
document.getElementById(&quot;myP&quot;).innerHTML = &quot;这是我的第一个段落&quot;
</code></pre>
<h3 id="JavaScript-多行注释-2"><a href="#JavaScript-多行注释-2" class="headerlink" title="JavaScript 多行注释"></a>JavaScript 多行注释</h3><p>多行注释以 <code>/*</code> 开始，以 <code>*/</code> 结尾</p>
<pre><code class="JavaScript">/*
下面的代码会输出
一个标题和
一个段落
*/
document.getElementById(&quot;myH1&quot;).innerHTML = &quot;欢迎来到我的主页&quot;
document.getElementById(&quot;myP&quot;).innerHTML = &quot;这是我的第一个段落&quot;
</code></pre>
<hr>
<p>##JavaScript 变量<br>变量是用于存储信息的“容器”</p>
<pre><code class="JavaScript">var x = 5
var y = 6
var z = x+y
</code></pre>
<p>变量可以使用短名称（x，y），也可以使用描述性更好的名称（age，sum）</p>
<ul>
<li>变量必须以字母开头</li>
<li>变量也能以 $ 和 _ 符号开头</li>
<li>变量名称对大小写敏感<br>JavaScript 语句和 JavaScript 变量都对大小写敏感</li>
</ul>
<h3 id="JavaScript-数据类型-9"><a href="#JavaScript-数据类型-9" class="headerlink" title="JavaScript 数据类型"></a>JavaScript 数据类型</h3><p>JavaScript 变量还能保存其他数据类型，比如文本值（name=”bill”)<br>在 JavaScript 中，类似“bill”这样一条文本被称为字符串<br>向变量分配文本值时，应该用双引号或单引号包围这个值<br>赋值为数值时，不要使用引号，不然会被当文本来处理</p>
<pre><code class="JavaScript">var pi = 3.14
var person = &quot;john doe&quot;
var answer = &quot;yes I am&quot;
</code></pre>
<h3 id="声明（创建）JavaScript-变量-2"><a href="#声明（创建）JavaScript-变量-2" class="headerlink" title="声明（创建）JavaScript 变量"></a>声明（创建）JavaScript 变量</h3><p>在 JavaScript 中创建变量通常称为“声明”变量<br>使用 <code>var</code> 关键词来声明变量</p>
<pre><code class="JavaScript">var carname
</code></pre>
<p>变量声明之后，该变量是空的（没有值）<br>如需向变量赋值，则需要使用等号</p>
<pre><code class="JavaScript">carname = &quot;volvo&quot;
</code></pre>
<p>不过，也可以在声明变量时就赋值</p>
<pre><code class="JavaScript">var carname = &quot;volvo&quot;
</code></pre>
<h3 id="一条语句，多个变量-2"><a href="#一条语句，多个变量-2" class="headerlink" title="一条语句，多个变量"></a>一条语句，多个变量</h3><p>可以在一条语句中声明多个变量，以 <code>var</code> 开头，并用逗号分隔</p>
<pre><code class="JavaScript">var name = &quot;Doe&quot;, age = &quot;30&quot;, job = &quot;teacher&quot;
// 也可以横跨多行
var name = &quot;Doe&quot;,
age = &quot;30&quot;,
job = &quot;teacher&quot;
</code></pre>
<p>一条语句声明的多个不可以赋同一个值</p>
<pre><code class="JavaScript">var x,y,z=1
//x,y 为 undefined，z 为 1
</code></pre>
<h3 id="Value-undefined-2"><a href="#Value-undefined-2" class="headerlink" title="Value=undefined"></a>Value=undefined</h3><p>未使用值来声明的变量，其值为 undefined</p>
<h3 id="重新声明-JavaScript-变量-2"><a href="#重新声明-JavaScript-变量-2" class="headerlink" title="重新声明 JavaScript 变量"></a>重新声明 JavaScript 变量</h3><p>如果重新声明 JavaScript 变量，该变量的值不会丢失</p>
<pre><code class="JavaScript">var x = &quot;xxx&quot;
var x
//x 的值依然为“xxx”
</code></pre>
<hr>
<h2 id="JavaScript-数据类型-10"><a href="#JavaScript-数据类型-10" class="headerlink" title="JavaScript 数据类型"></a>JavaScript 数据类型</h2><p>值类型（基本类型）：</p>
<ul>
<li>字符串 String</li>
<li>数字 Number</li>
<li>布尔 Boolean</li>
<li>空 Null</li>
<li>未定义 undefined</li>
<li>唯一值 Symbol</li>
</ul>
<p>引入数据类型：</p>
<ul>
<li>对象 Object</li>
<li>数组 Array</li>
<li>函数 Function</li>
</ul>
<h3 id="JavaScript-拥有动态类型-2"><a href="#JavaScript-拥有动态类型-2" class="headerlink" title="JavaScript 拥有动态类型"></a>JavaScript 拥有动态类型</h3><p>意味着相同的变量可用作不同的类型</p>
<pre><code class="JavaScript">var x   //x 为 undefined
var x = 5   //x 为数字
var x = &#39;Jk&quot;    //x 为字符串
</code></pre>
<h3 id="JavaScript-字符串-String-2"><a href="#JavaScript-字符串-String-2" class="headerlink" title="JavaScript 字符串 String"></a>JavaScript 字符串 String</h3><p>字符串是存储字符（如“Jack”）的变量<br>字符串可以是引号内的任意文本，单引号或双引号</p>
<pre><code class="JavaScript">var name = &quot;Jack 80D&quot;
var add = &quot;shanxi&#39;linfen&#39;&quot;
</code></pre>
<h3 id="JavaScript-数字-Number-2"><a href="#JavaScript-数字-Number-2" class="headerlink" title="JavaScript 数字 Number"></a>JavaScript 数字 Number</h3><p>JavaScript 只有一种数字类型，可以带小数点或是科学计数法</p>
<pre><code class="JavaScript">var x = 123
var y = 3.14
var z = 123e5
</code></pre>
<h3 id="JavaScript-布尔-Boolean-2"><a href="#JavaScript-布尔-Boolean-2" class="headerlink" title="JavaScript 布尔 Boolean"></a>JavaScript 布尔 Boolean</h3><p>布尔（逻辑）只有两个值，<code>true/false</code></p>
<h3 id="JavaScript-数组-Array-2"><a href="#JavaScript-数组-Array-2" class="headerlink" title="JavaScript 数组 Array"></a>JavaScript 数组 Array</h3><p>数组的下标是基于零的，所以第一个项目是 [0]，第二个是 [1]，以此类推</p>
<pre><code class="JavaScript">var x = new Array()x[0] = &quot;y&quot;
x[1] = &quot;h&quot;
x[2] = &quot;h&quot;
//or
var x = new Array(&quot;y&quot;,&quot;h&quot;,&quot;h&quot;)
//or
var x = [&quot;y&quot;,&quot;h&quot;,&quot;h&quot;]
</code></pre>
<h3 id="JavaScript-对象-Object-2"><a href="#JavaScript-对象-Object-2" class="headerlink" title="JavaScript 对象 Object"></a>JavaScript 对象 Object</h3><p>对象由花括号分隔，在括号内部，对象的属性以名称和值的形式 <code>name：value</code> 来定义，属性由逗号分隔</p>
<pre><code class="JavaScript">var person = {
    name: &quot;Yhh&quot;,
    age: &quot;18&quot;,
    id: 7281
}
// 两种寻址方式
name = person.name
name = person[&quot;name&quot;]
</code></pre>
<h3 id="undefined-和-Null-2"><a href="#undefined-和-Null-2" class="headerlink" title="undefined 和 Null"></a>undefined 和 Null</h3><p>undefined 表示变量不含有值<br>可以通过将变量的值设为 null 来清空变量</p>
<h3 id="声明变量类型-2"><a href="#声明变量类型-2" class="headerlink" title="声明变量类型"></a>声明变量类型</h3><p>可以使用关键词 <code>new</code> 来声明类型</p>
<pre><code class="JavaScript">var name = new String
var x = new Number
var y = new Boolean
var z = new Array
var i = new Object
</code></pre>
<p>JavaScript 变量均为对象，当声明一个变量时，就创建了一个新的对象</p>
<hr>
<h2 id="JavaScript-对象-4"><a href="#JavaScript-对象-4" class="headerlink" title="JavaScript 对象"></a>JavaScript 对象</h2><p>JavaScript 对象是拥有属性和方法的数据</p>
<h3 id="真是生活中的对象，属性，方法-2"><a href="#真是生活中的对象，属性，方法-2" class="headerlink" title="真是生活中的对象，属性，方法"></a>真是生活中的对象，属性，方法</h3><p>真实生活中，一辆汽车是一个对象<br>对象有它的属性，如重量颜色，方法有启动停止</p>
<table>
<thead>
<tr>
<th style="text-align:center">对象</th>
<th style="text-align:center">属性</th>
<th style="text-align:center">方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">car</td>
<td style="text-align:center">car.name = fiat<br>car.model = 500<br>car.weight = 800kg<br></td>
<td style="text-align:center">car.start()<br>car.brake()<br>car.stop()</td>
</tr>
</tbody>
</table>
<h3 id="JavaScript-对象-5"><a href="#JavaScript-对象-5" class="headerlink" title="JavaScript 对象"></a>JavaScript 对象</h3><p>JavaScript 对象是变量的容器</p>
<pre><code class="JavaScript">var car = &quot;fiat&quot;
//or
var car = {
    type: &quot;fiat&quot;,
    model: 500,
    color: &quot;white&quot;
}
</code></pre>
<h3 id="对象属性-2"><a href="#对象属性-2" class="headerlink" title="对象属性"></a>对象属性</h3><p>JavaScript 对象是变量的容器 ===JavaScript 对象是键值对的容器<br>键值对通常写法为 <code>name：value</code>（键 冒号 值）<br>键值对在 JavaScript 对象称为 对象属性<br>对象键值对的写法类似于：</p>
<ul>
<li>PHP 中的关联数组</li>
<li>Python 中的字典</li>
<li>C 语言中的哈希表</li>
<li>Java 中的哈希映射</li>
<li>Ruby 和 Perl 中的哈希表</li>
</ul>
<h3 id="访问对象属性-2"><a href="#访问对象属性-2" class="headerlink" title="访问对象属性"></a>访问对象属性</h3><p>两种方式</p>
<pre><code class="JavaScript">car.type
//or
car[&quot;type&quot;]
</code></pre>
<h3 id="对象方法-2"><a href="#对象方法-2" class="headerlink" title="对象方法"></a>对象方法</h3><p>对象的方法定义了一个函数，并作为对象的属性存储<br>对象方法通过添加（）调用</p>
<pre><code class="JavaScript">var person = {
    firstName: &quot;John&quot;,
    lastName: &quot;Doe&quot;,
    id: 5566,
    fullName: function (){return this.firstName + &quot; &quot; + this.lastName;}
};
person.fullName //function (){return this.firstName + &quot; &quot; + this.lastName;}
person.fullName() //John Doe
不加括号输出函数表达式
加括号输出函数执行结果
</code></pre>
<hr>
<h2 id="JavaScript-函数-2"><a href="#JavaScript-函数-2" class="headerlink" title="JavaScript 函数"></a>JavaScript 函数</h2><p>函数是由事件驱动的或者当它被调用时执行的可重复使用的代码块</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt; 测试实例 &lt;/title&gt;
    &lt;script&gt;
        function myFunction(){alert(&quot;Hello World!&quot;);
        }
    &lt;/script&gt;
&lt;/head&gt;
    &lt;button onclick=&quot;myFunction()&quot;&gt; 点我 &lt;/button&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="JavaScript-函数语法-2"><a href="#JavaScript-函数语法-2" class="headerlink" title="JavaScript 函数语法"></a>JavaScript 函数语法</h3><p>函数就是包裹在花括号内的代码块，前面使用了关键词 function</p>
<pre><code class="JavaScript">function functionName(){// 执行代码}
</code></pre>
<h3 id="调用带参数的函数-2"><a href="#调用带参数的函数-2" class="headerlink" title="调用带参数的函数"></a>调用带参数的函数</h3><p>在调用函数时，可以向其传递值，这些值被称为参数<br>可以发送任意多的参数，由逗号分隔<br>当声明函数时，把参数作为变量来声明<br>变量和参数必须以一致的顺序出现，第一个变量就是第一个被传递的参数的给定的值</p>
<pre><code class="html">&lt;p&gt; 点击这个按钮，来调用带参数的函数。&lt;/p&gt;
&lt;button onclick=&quot;myFunction(&#39;Harry Potter&#39;,&#39;Wizard&#39;)&quot;&gt; 点击这里 &lt;/button&gt;
&lt;script&gt;
    function myFunction(name,job) {alert(&quot;Welcome&quot; + name + &quot;, the&quot; + job);
    }
&lt;/script&gt;
</code></pre>
<h3 id="带有返回值的函数-2"><a href="#带有返回值的函数-2" class="headerlink" title="带有返回值的函数"></a>带有返回值的函数</h3><p>在使用 return 语句时，函数会停止执行，并返回指定的值</p>
<pre><code class="JavaScript">function myFunction() {
    var x=5;
    return x;
}
</code></pre>
<p>返回值可选</p>
<pre><code class="JavaScript">function myFunction(a,b) {if (a&gt;b) {return;}
    return a+b
}
当 a&gt;b 时，则直接退出函数，返回 undefined
当 a&lt;=b 时，则返回 a+b 的值
</code></pre>
<h3 id="局部-JavaScript-变量-2"><a href="#局部-JavaScript-变量-2" class="headerlink" title="局部 JavaScript 变量"></a>局部 JavaScript 变量</h3><p>在 JavaScript 函数内部声明的变量是局部变量，所以只能在函数内部访问，为局部作用域<br>可以在不同的函数中使用名称相同的局部变量<br>只要函数运行完毕，本地变量就会被删除</p>
<h3 id="全局-JavaScript-变量-2"><a href="#全局-JavaScript-变量-2" class="headerlink" title="全局 JavaScript 变量"></a>全局 JavaScript 变量</h3><p>在函数外声明的变量时全局变量，网页上所有的脚本和函数都可以访问</p>
<h3 id="JavaScript-变量的生存期-2"><a href="#JavaScript-变量的生存期-2" class="headerlink" title="JavaScript 变量的生存期"></a>JavaScript 变量的生存期</h3><p>JavaScript 变量的生命期从被声明开始<br>局部变量会在函数运行后删除<br>全局变量会在页面关闭后删除</p>
<h3 id="向未声明的-JavaScript-变量分配值-2"><a href="#向未声明的-JavaScript-变量分配值-2" class="headerlink" title="向未声明的 JavaScript 变量分配值"></a>向未声明的 JavaScript 变量分配值</h3><p>如果把值赋给尚未声明的变量，则该变量将被自动作为 window 的一个属性<br>非严格模式下给未声明的变量赋值创建的全局变量，是全局对象的可配置属性，可以删除</p>
<pre><code class="JavaScript">var x = 1; // 不可配置全局属性
y = 2; // 没有使用 var 声明，可配置全局属性

console.log(this.x); // 1
console.log(window.x); // 1

delete x; // false 无法删除
console.log(x); //1

delete y; //true 删除
console.log(y); // 已经删除 报错变量未定义
</code></pre>
<hr>
<h2 id="JavaScript-作用域-4"><a href="#JavaScript-作用域-4" class="headerlink" title="JavaScript 作用域"></a>JavaScript 作用域</h2><p>作用域是可访问变量的集合</p>
<h3 id="JavaScript-作用域-5"><a href="#JavaScript-作用域-5" class="headerlink" title="JavaScript 作用域"></a>JavaScript 作用域</h3><p>在 JavaScript 中，对象和函数都是变量<br>在 JavaScript 中，作用域为可访问变量，对象，函数的集合<br>JavaScript 函数作用域：作用域在函数内修改</p>
<h3 id="JavaScript-局部变量-2"><a href="#JavaScript-局部变量-2" class="headerlink" title="JavaScript 局部变量"></a>JavaScript 局部变量</h3><p>变量在函数内声明，为局部变量<br>局部变量：只能在函数内部访问</p>
<pre><code class="JavaScript">// 此处不能调用 carName 变量
function myFunction() {
    var carName = &quot;Volvo&quot;;
    // 函数内可调用 carName 变量
}
</code></pre>
<p>因为局部变量只作用于函数内，所以不同的函数可以使用相同名称的变量<br>局部变量在函数开始执行时创建，函数执行完后局部变量会自动销毁</p>
<h3 id="JavaScript-全局变量-2"><a href="#JavaScript-全局变量-2" class="headerlink" title="JavaScript 全局变量"></a>JavaScript 全局变量</h3><p>变量在函数外定义，为全局变量<br>全局作用域：网页中的所有脚本和函数均可使用</p>
<pre><code class="JavaScript">var carName = &quot;Volvo&quot;;
// 此处可调用 carName 变量
function myFunction(){// 函数内可调用 carName 变量}
</code></pre>
<p>如果变量在函数内没有声明（没有使用 var 关键字），该变量为全局变量</p>
<pre><code class="JavaScript">// 此处可调用 carName 变量
function myFunction() {
    carName = &quot;Volvo&quot;;
    // 此处可调用 carName 变量
}
</code></pre>
<h3 id="JavaScript-变量生命周期-2"><a href="#JavaScript-变量生命周期-2" class="headerlink" title="JavaScript 变量生命周期"></a>JavaScript 变量生命周期</h3><p>JavaScript 变量生命周期在它声明时初始化<br>局部变量在函数执行完毕后销毁<br>全局变量在页面关闭后销毁</p>
<h3 id="函数参数-2"><a href="#函数参数-2" class="headerlink" title="函数参数"></a>函数参数</h3><p>函数参数只在函数内起作用为局部变量</p>
<h3 id="HTML-中的全局变量-2"><a href="#HTML-中的全局变量-2" class="headerlink" title="HTML 中的全局变量"></a>HTML 中的全局变量</h3><p>在 HTML 中，全局变量是 window 对象：所有数据变量都属于 window 对象</p>
<pre><code class="JavaScript">// 此处可使用 window.carName
function myFunction(){carName = &quot;Volvo&quot;;}
</code></pre>
<p><strong> 全局变量，或者函数，可以覆盖 window 对象的变量或者函数<br>局部变量，包括 window 对象可以覆盖全局变量和函数 </strong></p>
<hr>
<h2 id="JavaScript-事件-2"><a href="#JavaScript-事件-2" class="headerlink" title="JavaScript 事件"></a>JavaScript 事件</h2><p>HTML 事件是发生在 HTML 元素上的事情<br>当在 HTML 页面中使用 JavaScript 时，JavaScript 可以触发这些事件</p>
<h3 id="HTML-事件-2"><a href="#HTML-事件-2" class="headerlink" title="HTML 事件"></a>HTML 事件</h3><p>HTML 事件可以是浏览器行为，也可以是用户行为</p>
<ul>
<li>HTML 页面加载完成</li>
<li>HTML input 字段改变</li>
<li>HTML 按钮被点击</li>
</ul>
<h3 id="常见的-HTML-事件-2"><a href="#常见的-HTML-事件-2" class="headerlink" title="常见的 HTML 事件"></a>常见的 HTML 事件</h3><table>
<thead>
<tr>
<th style="text-align:center">事件</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">onchange</td>
<td style="text-align:center">HTML 元素改变</td>
</tr>
<tr>
<td style="text-align:center">onclick</td>
<td style="text-align:center">用户点击 HTML 元素</td>
</tr>
<tr>
<td style="text-align:center">onmouseover</td>
<td style="text-align:center">移动鼠标</td>
</tr>
<tr>
<td style="text-align:center">onmouseout</td>
<td style="text-align:center">移开鼠标</td>
</tr>
<tr>
<td style="text-align:center">onkeydown</td>
<td style="text-align:center">按下键盘按键</td>
</tr>
<tr>
<td style="text-align:center">onload</td>
<td style="text-align:center">浏览器已加载完成</td>
</tr>
</tbody>
</table>
<h3 id="JavaScript-可以做什么-2"><a href="#JavaScript-可以做什么-2" class="headerlink" title="JavaScript 可以做什么"></a>JavaScript 可以做什么</h3><p>事件可以用于处理表单验证，用户输入，用户行为及浏览器动作:</p>
<ul>
<li>页面加载时触发事件</li>
<li>页面关闭时触发事件</li>
<li>用户点击按钮执行动作</li>
<li>验证用户输入内容的合法性</li>
</ul>
<p>可以使用多种方法来执行 JavaScript 事件代码：</p>
<ul>
<li>HTML 事件属性可以直接执行 JavaScript 代码</li>
<li>HTML 事件属性可以调用 JavaScript 函数</li>
<li>可以为 HTML 元素指定自己的事件处理程序</li>
<li>可以阻止事件的发生</li>
</ul>
<hr>
<h2 id="JavaScript-字符串-4"><a href="#JavaScript-字符串-4" class="headerlink" title="JavaScript 字符串"></a>JavaScript 字符串</h2><p>JavaScript 字符串用于存储和处理文本</p>
<h3 id="JavaScript-字符串-5"><a href="#JavaScript-字符串-5" class="headerlink" title="JavaScript 字符串"></a>JavaScript 字符串</h3><p>可以存储一系列字符，如“yhh”<br>可以是插入到引号中的任何字符，单引号或双引号<br>可以使用索引位置来访问字符串中的每个字符<br>字符串的索引从 0 开始，第一个字符索引值为 [0]，第二个是 [1]，以此类推<br>可以在字符串中添加转义字符来使用引号</p>
<pre><code class="JavaScript">var name = &quot;yyh7281&quot;
var name = &#39;yyh7281&#39;
name[3] //7
name[0] //y
var x = &quot;he is called \&quot;Jack\&quot;&quot;
</code></pre>
<h3 id="字符串长度-2"><a href="#字符串长度-2" class="headerlink" title="字符串长度"></a>字符串长度</h3><p>可以使用内置属性 <code>length</code> 来计算字符串的长度</p>
<pre><code class="JavaScript">var text = &quot;dhxahjsocnbdhehowcwncnhi&quot;
text.length //15
</code></pre>
<h3 id="特殊字符（转义字符）-2"><a href="#特殊字符（转义字符）-2" class="headerlink" title="特殊字符（转义字符）"></a>特殊字符（转义字符）</h3><table>
<thead>
<tr>
<th style="text-align:center">代码</th>
<th style="text-align:center">输出</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">‘</td>
<td style="text-align:center">单引号</td>
</tr>
<tr>
<td style="text-align:center">“</td>
<td style="text-align:center">双引号</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td style="text-align:center">反斜杠</td>
</tr>
<tr>
<td style="text-align:center">\n</td>
<td style="text-align:center">换行</td>
</tr>
<tr>
<td style="text-align:center">\r</td>
<td style="text-align:center">回车</td>
</tr>
<tr>
<td style="text-align:center">\t</td>
<td style="text-align:center">tab（制表符）</td>
</tr>
<tr>
<td style="text-align:center">\b</td>
<td style="text-align:center">退格符</td>
</tr>
<tr>
<td style="text-align:center">\f</td>
<td style="text-align:center">换页符</td>
</tr>
</tbody>
</table>
<h3 id="字符串可以是对象-2"><a href="#字符串可以是对象-2" class="headerlink" title="字符串可以是对象"></a>字符串可以是对象</h3><p>通常，JavaScript 字符串是原始值，可以使用字符创建<br>但也可以使用 new 关键字将字符串定义为一个对象</p>
<pre><code class="JavaScript">var x = &quot;yyh&quot;
var y = new String(&quot;hhhy&quot;)
typeof x //String
typeof y //Object
x === y //false 因为 x 为字符串，y 为对象
</code></pre>
<h3 id="字符串属性和方法-2"><a href="#字符串属性和方法-2" class="headerlink" title="字符串属性和方法"></a>字符串属性和方法</h3><p>原始值字符串，如 “John”, 没有属性和方法 (因为他们不是对象)<br>原始值可以使用 JavaScript 的属性和方法，因为 JavaScript 在执行方法和属性时可以把原始值当作对象</p>
<h3 id="字符串属性-2"><a href="#字符串属性-2" class="headerlink" title="字符串属性"></a>字符串属性</h3><table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">constructor</td>
<td style="text-align:center">返回创建字符串属性的函数</td>
</tr>
<tr>
<td style="text-align:center">length</td>
<td style="text-align:center">返回字符串的长度</td>
</tr>
<tr>
<td style="text-align:center">prototype</td>
<td style="text-align:center">允许向对象添加属性和方法</td>
</tr>
</tbody>
</table>
<h3 id="字符串方法-2"><a href="#字符串方法-2" class="headerlink" title="字符串方法"></a>字符串方法</h3><table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">charAt()</td>
<td style="text-align:center">返回指定索引位置的字符</td>
</tr>
<tr>
<td style="text-align:center">charCodeAt()</td>
<td style="text-align:center">返回指定索引位置字符的 Unicode 值</td>
</tr>
<tr>
<td style="text-align:center">concat()</td>
<td style="text-align:center">连接两个或多个字符串，返回连接后的字符串</td>
</tr>
<tr>
<td style="text-align:center">fromCharCode()</td>
<td style="text-align:center">将 Unicode 转换为字符串</td>
</tr>
<tr>
<td style="text-align:center">indexOf()</td>
<td style="text-align:center">返回字符串中检索指定字符第一次出现的位置</td>
</tr>
<tr>
<td style="text-align:center">lastIndexOf()</td>
<td style="text-align:center">返回字符串中检索指定字符最后一次出现的位置</td>
</tr>
<tr>
<td style="text-align:center">localeCompare()</td>
<td style="text-align:center">用本地特定的顺序来比较两个字符串</td>
</tr>
<tr>
<td style="text-align:center">match()</td>
<td style="text-align:center">找到一个或多个正则表达式的匹配</td>
</tr>
<tr>
<td style="text-align:center">replace()</td>
<td style="text-align:center">替换与正则表达式匹配的子串</td>
</tr>
<tr>
<td style="text-align:center">search()</td>
<td style="text-align:center">检索与正则表达式相匹配的值</td>
</tr>
<tr>
<td style="text-align:center">slice()</td>
<td style="text-align:center">提取字符串的片段，并在新的字符串中返回被提取的部分</td>
</tr>
<tr>
<td style="text-align:center">split()</td>
<td style="text-align:center">把字符串分割为子字符串数组</td>
</tr>
<tr>
<td style="text-align:center">substr()</td>
<td style="text-align:center">从起始索引号提取字符串中指定数目的字符</td>
</tr>
<tr>
<td style="text-align:center">substring()</td>
<td style="text-align:center">提取字符串中两个指定的索引号之间的字符</td>
</tr>
<tr>
<td style="text-align:center">toLowerCase()</td>
<td style="text-align:center">把字符串转换为小写</td>
</tr>
<tr>
<td style="text-align:center">toString()</td>
<td style="text-align:center">返回字符串对象值</td>
</tr>
<tr>
<td style="text-align:center">toUpperCase()</td>
<td style="text-align:center">把字符串转换为大写</td>
</tr>
<tr>
<td style="text-align:center">trim()</td>
<td style="text-align:center">移除字符串首尾空白</td>
</tr>
<tr>
<td style="text-align:center">valueOf()</td>
<td style="text-align:center">返回某个字符串对象的原始值</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="JavaScript-运算符-2"><a href="#JavaScript-运算符-2" class="headerlink" title="JavaScript 运算符"></a>JavaScript 运算符</h2><p>运算符 = 用于给 JavaScript 变量赋值<br>算术运算符 + 用于把值加起来</p>
<pre><code class="JavaScript">x = 3
y = 5
z = x+y
z //8
</code></pre>
<h3 id="JavaScript-算术运算符-2"><a href="#JavaScript-算术运算符-2" class="headerlink" title="JavaScript 算术运算符"></a>JavaScript 算术运算符</h3><table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">例子（y=5）</th>
<th style="text-align:center">x 运算结果</th>
<th style="text-align:center">y 运算结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">加法</td>
<td style="text-align:center">x=y+2</td>
<td style="text-align:center">7</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">减法</td>
<td style="text-align:center">x=y-2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">乘法</td>
<td style="text-align:center">x=y*2</td>
<td style="text-align:center">10</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">/</td>
<td style="text-align:center">除法</td>
<td style="text-align:center">x=y/5</td>
<td style="text-align:center">1</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:center">取模（余数）</td>
<td style="text-align:center">x=y%2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">++</td>
<td style="text-align:center">自增</td>
<td style="text-align:center">x=++y<br>x=y++</td>
<td style="text-align:center">6<br>5</td>
<td style="text-align:center">6<br>6</td>
</tr>
<tr>
<td style="text-align:center">–</td>
<td style="text-align:center">自减</td>
<td style="text-align:center">x=–y<br>x=y–</td>
<td style="text-align:center">4<br>5</td>
<td style="text-align:center">4<br>4</td>
</tr>
</tbody>
</table>
<h3 id="JavaScript-赋值运算符-2"><a href="#JavaScript-赋值运算符-2" class="headerlink" title="JavaScript 赋值运算符"></a>JavaScript 赋值运算符</h3><p><code>var x = 10 y = 5</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">例子</th>
<th style="text-align:center">等同于</th>
<th style="text-align:center">运算结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">=</td>
<td style="text-align:center">x=y</td>
<td style="text-align:center"></td>
<td style="text-align:center">x=5</td>
</tr>
<tr>
<td style="text-align:center">+=</td>
<td style="text-align:center">x+=y</td>
<td style="text-align:center">x=x+y</td>
<td style="text-align:center">x=15</td>
</tr>
<tr>
<td style="text-align:center">-=</td>
<td style="text-align:center">x-=y</td>
<td style="text-align:center">x=x-y</td>
<td style="text-align:center">x=5</td>
</tr>
<tr>
<td style="text-align:center">*=</td>
<td style="text-align:center">x*=y</td>
<td style="text-align:center">x=x*y</td>
<td style="text-align:center">x=50</td>
</tr>
<tr>
<td style="text-align:center">/=</td>
<td style="text-align:center">x/=y</td>
<td style="text-align:center">x=x/y</td>
<td style="text-align:center">x=2</td>
</tr>
<tr>
<td style="text-align:center">%=</td>
<td style="text-align:center">x%=y</td>
<td style="text-align:center">x=x%y</td>
<td style="text-align:center">x=0</td>
</tr>
</tbody>
</table>
<h3 id="用于字符串的-运算符-2"><a href="#用于字符串的-运算符-2" class="headerlink" title="用于字符串的 + 运算符"></a>用于字符串的 + 运算符</h3><ul>
<li>运算符永雨把文本值或字符串变量加起来（连接起来）</li>
</ul>
<pre><code class="JavaScript">text1 = &quot;hello&quot;
text2 = &quot;world&quot;
text3 = text1+text2 //&quot;helloworld&quot;
text4 = text1+&quot;&quot;+text2 //&quot;hello world&quot;
</code></pre>
<h3 id="对字符串和数字进行加法运算-2"><a href="#对字符串和数字进行加法运算-2" class="headerlink" title="对字符串和数字进行加法运算"></a>对字符串和数字进行加法运算</h3><p>两个数字相加，返回相加的和，数字与字符串相加，则返回字符串</p>
<pre><code class="JavaScript">x = 5+5 //10
y = &quot;3&quot;+5 //&quot;35&quot;
z = &quot;hello&quot;+5 //&quot;hello5&quot;
</code></pre>
<hr>
<h2 id="JavaScript-比较和逻辑运算符-2"><a href="#JavaScript-比较和逻辑运算符-2" class="headerlink" title="JavaScript 比较和逻辑运算符"></a>JavaScript 比较和逻辑运算符</h2><p>比较和逻辑运算符用于测试 true 或者 false</p>
<h3 id="比较运算符-2"><a href="#比较运算符-2" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>比较运算符在逻辑语句中使用，以测定变量或值是否相等<br><code>var x = 5</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">比较</th>
<th style="text-align:center">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">==</td>
<td style="text-align:center">等于</td>
<td style="text-align:center">x\==8<br>x==5</td>
<td style="text-align:center">false<br>true</td>
</tr>
<tr>
<td style="text-align:center">===</td>
<td style="text-align:center">绝对等于（值和类型均相等）</td>
<td style="text-align:center">x=\==“5”<br>x\===5</td>
<td style="text-align:center">false<br>true</td>
</tr>
<tr>
<td style="text-align:center">!=</td>
<td style="text-align:center">不等于</td>
<td style="text-align:center">x!=8</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center">!==</td>
<td style="text-align:center">不绝对等于（值和类型有一个或两个不相等）</td>
<td style="text-align:center">x!\==“5”<br>x!==5</td>
<td style="text-align:center">true<br>false</td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">大于</td>
<td style="text-align:center">x&gt;8</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">小于</td>
<td style="text-align:center">x&lt;8</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center">&gt;=</td>
<td style="text-align:center">大于等于</td>
<td style="text-align:center">x&gt;=8</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">&lt;=</td>
<td style="text-align:center">小于等于</td>
<td style="text-align:center">x&lt;=8</td>
<td style="text-align:center">true</td>
</tr>
</tbody>
</table>
<h3 id="逻辑运算符-2"><a href="#逻辑运算符-2" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符用于测定变量或值之间的逻辑<br><code>var x=6 y=3</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&amp;&amp;</td>
<td style="text-align:center">and</td>
<td style="text-align:center">(x&lt;10&amp;&amp;y&gt;1)//true</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td style="text-align:center">\</td>
<td style="text-align:center"></td>
<td>or</td>
<td>(x\==6 \</td>
<td>\</td>
<td>y==5)//true</td>
</tr>
<tr>
<td style="text-align:center">!</td>
<td style="text-align:center">not</td>
<td style="text-align:center">!(x==y)//true</td>
</tr>
</tbody>
</table>
<h3 id="条件运算符-2"><a href="#条件运算符-2" class="headerlink" title="条件运算符"></a>条件运算符</h3><p>JavaScript 还包含了基于某些条件对变量进行赋值的条件运算</p>
<pre><code class="JavaScript">name = (condition) ? value1 : value2 // 语法
yhh=(age&lt;18)?&quot;年龄不够&quot;:&quot;年龄已达到&quot; // 如果 age&lt;18 则赋值“年龄太小”，反之“年龄已达到”
</code></pre>
<hr>
<h2 id="JavaScript-if…else-语句-2"><a href="#JavaScript-if…else-语句-2" class="headerlink" title="JavaScript if…else 语句"></a>JavaScript if…else 语句</h2><p>条件语句用于基于不同的条件来执行不同的动作</p>
<h3 id="条件语句-2"><a href="#条件语句-2" class="headerlink" title="条件语句"></a>条件语句</h3><p>在 JavaScript 中，可以使用一下条件语句：</p>
<ul>
<li>if 语句 只有当指定条件为 true 时，使用该语句来执行代码</li>
<li>if…else 语句 当条件为 true 时执行代码，当条件为 false 时执行其他代码</li>
<li>if…else if…else 使用该语句来选择多个代码块之一来执行</li>
<li>switch 语句 使用该语句来选择多个代码块之一来执行</li>
</ul>
<h3 id="if-语句-2"><a href="#if-语句-2" class="headerlink" title="if 语句"></a>if 语句</h3><p>只有当指定条件为 true 时，该语句才会执行代码</p>
<pre><code class="JavaScript">if(condition){当条件为 true 时执行}

var x = 10
function z(){if(x&lt;20){return x}
}
z() //10 否则为 undefined
</code></pre>
<h3 id="if…else-语句-2"><a href="#if…else-语句-2" class="headerlink" title="if…else 语句"></a>if…else 语句</h3><p>使用 if…else 语句在条件为 true 时执行代码，在条件为 false 时执行其他代码</p>
<pre><code class="JavaScript">if (condition) {当条件为 true 时执行的代码}
else {当条件不为 true 时执行的代码}

var x = 10
function z(){if(x&lt;5){return x}else{return x+1}
}
z() //11
</code></pre>
<h3 id="if…else-if…else-语句-2"><a href="#if…else-if…else-语句-2" class="headerlink" title="if…else if…else 语句"></a>if…else if…else 语句</h3><p>使用 if….else if…else 语句来选择多个代码块之一来执行</p>
<pre><code class="JavaScript">if (condition1) {当条件 1 为 true 时执行的代码}
else if (condition2) {当条件 2 为 true 时执行的代码}
else {当条件 1 和 条件 2 都不为 true 时执行的代码}

var x = 10
function z(){if(x&lt;5){return x}else if(x&lt;15){return x+5}else{return x+1}
}
z() //15
</code></pre>
<hr>
<h2 id="JavaScript-switch-语句-4"><a href="#JavaScript-switch-语句-4" class="headerlink" title="JavaScript switch 语句"></a>JavaScript switch 语句</h2><p>switch 语句用于基于不同条件来执行不同的动作</p>
<h3 id="JavaScript-switch-语句-5"><a href="#JavaScript-switch-语句-5" class="headerlink" title="JavaScript switch 语句"></a>JavaScript switch 语句</h3><p>使用 switch 语句来选择要执行的多个代码块之一</p>
<pre><code class="JavaScript">switch(n){
    case 1:
        执行代码块 1
        break;
    case 2:
        执行代码块 2
        break;
    default:
        与 case1 和 case2 不同时执行
}
工作原理：首先设置表达式 n（通常是一个变量）。随后表达式的值会与结构中的每个 case 的值做比较
如果存在匹配，则与该 case 关联的代码块会被执行。请使用 break 来阻止代码自动地向下一个 case 运行

var d=new Date().getDay();
switch (d) {
  case 0:x=&quot;今天是星期日&quot;;
  break;
  case 1:x=&quot;今天是星期一&quot;;
  break;
  case 2:x=&quot;今天是星期二&quot;;
  break;
  case 3:x=&quot;今天是星期三&quot;;
  break;
  case 4:x=&quot;今天是星期四&quot;;
  break;
  case 5:x=&quot;今天是星期五&quot;;
  break;
  case 6:x=&quot;今天是星期六&quot;;
  break;
}
// 今天是星期六
</code></pre>
<h3 id="default-关键词-2"><a href="#default-关键词-2" class="headerlink" title="default 关键词"></a>default 关键词</h3><p>使用 default 关键词来规定匹配不存在时做的事情</p>
<pre><code class="JavaScript">var d=new Date().getDay();
switch (d) {
    case 666:x=&quot;今天是星期六&quot;;
    break;
    case 000:x=&quot;今天是星期日&quot;;
    break;
    default:
    x=&quot;期待周末&quot;;
}
// 期待周末
</code></pre>
<hr>
<h2 id="JavaScript-for-循环-2"><a href="#JavaScript-for-循环-2" class="headerlink" title="JavaScript for 循环"></a>JavaScript for 循环</h2><p>循环可以将代码块执行指定的次数</p>
<h3 id="JavaScript-循环-2"><a href="#JavaScript-循环-2" class="headerlink" title="JavaScript 循环"></a>JavaScript 循环</h3><p>如果需要一遍又一遍运行相同的代码，且每次的值都不同，那么可以使用循环</p>
<pre><code class="JavaScript">// 常规写法
document.write(x[0])
document.write(x[1])
document.write(x[2])
document.write(x[3])
document.write(x[4])
document.write(x[5])
//for 循环
for(let i=0;i&lt;x.length;i++){document.write(x[i]) 
}
</code></pre>
<h3 id="不同类型的循环-2"><a href="#不同类型的循环-2" class="headerlink" title="不同类型的循环"></a>不同类型的循环</h3><p>JavaScript 支持不同类型的循环：</p>
<ul>
<li>for 循环代码块一定的次数</li>
<li>for/in 循环遍历对象的属性</li>
<li>while 当指定的条件为 true 时循环指定的代码块</li>
<li>do/while 同样当指定的条件为 true 时循环指定的代码块</li>
</ul>
<h3 id="for-循环-2"><a href="#for-循环-2" class="headerlink" title="for 循环"></a>for 循环</h3><pre><code class="JavaScript">for(语句 1; 语句 2; 语句 3){被执行的代码块}
语句 1 （代码块）开始前执行
语句 2 定义运行循环（代码块）的条件
语句 3 在循环（代码块）已被执行之后执行

for (var i=0; i&lt;5; i++) {x+=i;}
</code></pre>
<h3 id="for-in-循环-2"><a href="#for-in-循环-2" class="headerlink" title="for/in 循环"></a>for/in 循环</h3><p>JavaScript for/in 语句循环遍历对象的属性</p>
<pre><code class="JavaScript">var person={fname:&quot;John&quot;,lname:&quot;Doe&quot;,age:25};
for (x in person) { // x 为属性名
    txt=txt + person[x];
}
//JohnDoe25
</code></pre>
<hr>
<h2 id="JavaScript-while-循环-2"><a href="#JavaScript-while-循环-2" class="headerlink" title="JavaScript while 循环"></a>JavaScript while 循环</h2><p>只要指定条件为 true，循环就可以一直执行代码块</p>
<h3 id="while-循环-2"><a href="#while-循环-2" class="headerlink" title="while 循环"></a>while 循环</h3><pre><code class="JavaScript">while(条件){代码块}

while(i&lt;5){
    x+=i
    i++
}
</code></pre>
<h3 id="do-while-循环-2"><a href="#do-while-循环-2" class="headerlink" title="do/while 循环"></a>do/while 循环</h3><p>do/while 循环是 while 循环的变体，该循环会在检查条件是否为真之前执行一次代码块，然后如果条件为真，则会重复循环，意味着代码至少会被执行一次</p>
<pre><code class="JavaScript">do{代码}
while(条件)

do{
    x+=i
    i++
}
while(i&gt;3)
</code></pre>
<h3 id="比较-for-跟-while-循环-2"><a href="#比较-for-跟-while-循环-2" class="headerlink" title="比较 for 跟 while 循环"></a>比较 for 跟 while 循环</h3><p>基本类似</p>
<hr>
<h2 id="JavaScript-break-和-continue-语句-2"><a href="#JavaScript-break-和-continue-语句-2" class="headerlink" title="JavaScript break 和 continue 语句"></a>JavaScript break 和 continue 语句</h2><p>break 语句用于跳出循环<br>continue 语句用于跳出循环中的一个迭代</p>
<h3 id="break-语句-2"><a href="#break-语句-2" class="headerlink" title="break 语句"></a>break 语句</h3><p>break 语句跳出循环后，会继续执行该循环之后的代码（如果有）</p>
<pre><code class="JavaScript">for (i=0;i&lt;10;i++) {if (i==3) {break;}
    x=x + &quot;The number is&quot; + i + &quot;&lt;br&gt;&quot;;
}
//0 1 2
</code></pre>
<h3 id="continue-语句-2"><a href="#continue-语句-2" class="headerlink" title="continue 语句"></a>continue 语句</h3><p>continue 语句中断循环中的的迭代，如果出现了指定的条件，然后继续循环中的下一个迭代</p>
<pre><code class="JavaScript">for (i=0;i&lt;10;i++) {if (i==3) {continue;}
    x=x + &quot;The number is&quot; + i + &quot;&lt;br&gt;&quot;;
}
//0 1 2 4 5 6 7 8 9 
</code></pre>
<h3 id="JavaScript-标签-2"><a href="#JavaScript-标签-2" class="headerlink" title="JavaScript 标签"></a>JavaScript 标签</h3><p>continue 语句（带有或不带标签引用）只能用在循环中<br>break 语句（不带标签引用）只能在循环或 switch 中<br>通过标签引用，break 语句可用于跳出任何 JavaScript 代码块</p>
<pre><code class="JavaScript">cars=[&quot;BMW&quot;,&quot;Volvo&quot;,&quot;Saab&quot;,&quot;Ford&quot;];
list: {document.write(cars[0] + &quot;&lt;br&gt;&quot;);
    document.write(cars[1] + &quot;&lt;br&gt;&quot;);
    document.write(cars[2] + &quot;&lt;br&gt;&quot;);
    break list;
    document.write(cars[3] + &quot;&lt;br&gt;&quot;);
    document.write(cars[4] + &quot;&lt;br&gt;&quot;);
    document.write(cars[5] + &quot;&lt;br&gt;&quot;);}
//&quot;BMW&quot;&quot;Volvo&quot;&quot;Saab&quot;
</code></pre>
<hr>
<h2 id="JavaScript-typeof、null、undefined-2"><a href="#JavaScript-typeof、null、undefined-2" class="headerlink" title="JavaScript typeof、null、undefined"></a>JavaScript typeof、null、undefined</h2><h3 id="typeof-操作符-4"><a href="#typeof-操作符-4" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h3><p>检测变量的数据类型</p>
<pre><code class="JavaScript">typeof &quot;John&quot;               //  返回 string
typeof 3.14                 //  返回 number
typeof false                //  返回 boolean
typeof [1,2,3]              //  返回 object
typeof {name:&#39;John&#39;,age:34} //  返回 object
</code></pre>
<h3 id="null-2"><a href="#null-2" class="headerlink" title="null"></a>null</h3><p>在 JavaScript 中 null 表示“什么都没有”<br>null 是一个只有一个值的特殊类型，表示一个空对象引用<br>用 typeof 检测 null 返回 object<br>可以设置 null 来清空对象</p>
<pre><code class="JavaScript">var person = null // 值为 null（空） 类型为对象
var person = undefined // 值为 undefined 类型为 undefined
</code></pre>
<h3 id="undefined-2"><a href="#undefined-2" class="headerlink" title="undefined"></a>undefined</h3><p>在 JavaScript 中，undefined 是一个没有设置值的变量<br>typeof 一个没有值的变量会返回 undefined</p>
<h3 id="undefined-和-null-的区别-2"><a href="#undefined-和-null-的区别-2" class="headerlink" title="undefined 和 null 的区别"></a>undefined 和 null 的区别</h3><p>null 和 undefined 的值相等，但类型不同</p>
<pre><code class="JavaScript">typeof undefined //undefined
typeof null //object
null === undefined //false
null == undefined //true
</code></pre>
<hr>
<h2 id="JavaScript-类型转换-4"><a href="#JavaScript-类型转换-4" class="headerlink" title="JavaScript 类型转换"></a>JavaScript 类型转换</h2><p>Number()转换为数字，String() 转换为字符串，Boolean() 转换为布尔值</p>
<h3 id="JavaScript-数据类型-11"><a href="#JavaScript-数据类型-11" class="headerlink" title="JavaScript 数据类型"></a>JavaScript 数据类型</h3><p>在 JavaScript 中有 5 种不同的数据类型</p>
<ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>object</li>
<li>function</li>
</ul>
<p>3 种对象类型</p>
<ul>
<li>Object</li>
<li>Date</li>
<li>Array</li>
</ul>
<p>2 种不包含任何值的数据类型</p>
<ul>
<li>null</li>
<li>undefined</li>
</ul>
<h3 id="typeof-操作符-5"><a href="#typeof-操作符-5" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h3><pre><code class="JavaScript">typeof &quot;john&quot;           //string
typeof 3.14             //number
typeof NaN              //number
typeof false            //boolean
typeof [1,2,3]          //object
typeof {name:&#39;y&#39;,age:30}//object
typeof new Date()       //object
typeof function(){}     //function
typeof x                //undefined
typeof null             //object
typeof undefined        //undefined
</code></pre>
<p>注意：</p>
<ul>
<li>NaN 的数据类型是 number</li>
<li>数组 Array 的数据类型是 object</li>
<li>日期 Date 的数据类型是 object</li>
<li>null 的数据类型是 object</li>
<li>未定义变量的数据类型是 undefined</li>
</ul>
<h3 id="constructor-属性-2"><a href="#constructor-属性-2" class="headerlink" title="constructor 属性"></a>constructor 属性</h3><p>constructor 属性返回所有 JavaScript 变量的构造函数</p>
<pre><code class="JavaScript">&quot;John&quot;.constructor                 // 返回函数 String(){[native code] }
(3.14).constructor                 // 返回函数 Number(){[native code] }
false.constructor                  // 返回函数 Boolean(){[native code] }
[1,2,3,4].constructor              // 返回函数 Array(){[native code] }
{name:&#39;John&#39;, age:34}.constructor  // 返回函数 Object(){[native code] }
new Date().constructor             // 返回函数 Date()    {[native code] }
function (){}.constructor         // 返回函数 Function(){[native code] }
</code></pre>
<h3 id="JavaScript-类型转换-5"><a href="#JavaScript-类型转换-5" class="headerlink" title="JavaScript 类型转换"></a>JavaScript 类型转换</h3><p>JavaScript 变量可以转换为新变量或其他数据类型</p>
<ul>
<li>通过使用 JavaScript 函数</li>
<li>通过 JavaScript 自身自动转换</li>
</ul>
<h3 id="将数字转换为字符串-2"><a href="#将数字转换为字符串-2" class="headerlink" title="将数字转换为字符串"></a>将数字转换为字符串</h3><pre><code class="JavaScript">String(x)       // 将变量 x 转换为字符串并返回 &quot;x&quot;
String(123)     // 将数字 123 转换为字符串并返回 &quot;123&quot;
String(100+23)  // 将数字表达式转换为字符串并返回 &quot;123&quot;

Number 方法 toString() 也有同样的效果
x.toString()        //&quot;x&quot;
(123).toString()    //&quot;123&quot;
(100+23).toString() //&quot;123&quot;
</code></pre>
<h3 id="将布尔值转换为字符串-2"><a href="#将布尔值转换为字符串-2" class="headerlink" title="将布尔值转换为字符串"></a>将布尔值转换为字符串</h3><p>全局方法 String() 可以将布尔值转换为字符串</p>
<pre><code class="JavaScript">String(false)   //&quot;false&quot;
String(true)    //&quot;true&quot;
false.toString()//&quot;false&quot;
true.toString() //&quot;true&quot;
</code></pre>
<h3 id="将日期转换为字符串-2"><a href="#将日期转换为字符串-2" class="headerlink" title="将日期转换为字符串"></a>将日期转换为字符串</h3><p>Date() 返回字符串</p>
<pre><code class="JavaScript">Date()// 返回 &quot;Sat Apr 04 2020 17:25:36 GMT+0800 ( 中国标准时间)&quot;
String(new Date())  // 返回 &quot;Sat Apr 04 2020 17:25:36 GMT+0800 (中国标准时间)&quot;
obj = new Date()obj.toString()  // 返回 &quot;Sat Apr 04 2020 17:25:36 GMT+0800 (中国标准时间)&quot;
</code></pre>
<p>Date 方法</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">getDate()</td>
<td style="text-align:center">从 Date 对象返回一个月中的某一天（1-31）</td>
</tr>
<tr>
<td style="text-align:center">getDay()</td>
<td style="text-align:center">从 Date 对象返回一周中的某一天（0-6）</td>
</tr>
<tr>
<td style="text-align:center">getFullYear()</td>
<td style="text-align:center">从 Date 对象以四位数字返回年份</td>
</tr>
<tr>
<td style="text-align:center">getMonth()</td>
<td style="text-align:center">从 Date 对象返回月份（0-11）</td>
</tr>
<tr>
<td style="text-align:center">getHours()</td>
<td style="text-align:center">返回 Date 对象的小时（0-23）</td>
</tr>
<tr>
<td style="text-align:center">getMinutes()</td>
<td style="text-align:center">返回 Date 对象的分钟（0-59）</td>
</tr>
<tr>
<td style="text-align:center">getSeconds()</td>
<td style="text-align:center">返回 Date 对象的秒数（0-59）</td>
</tr>
<tr>
<td style="text-align:center">getMilliseconds()</td>
<td style="text-align:center">返回 Date 对象的毫秒数（0-999）</td>
</tr>
<tr>
<td style="text-align:center">getTime()</td>
<td style="text-align:center">返回 1970 年 1 月 1 日至今的毫秒数</td>
</tr>
</tbody>
</table>
<h3 id="将字符串转换为数字-2"><a href="#将字符串转换为数字-2" class="headerlink" title="将字符串转换为数字"></a>将字符串转换为数字</h3><p>全局方法 Number() 可以将字符串转换为数字<br>空字符串转换为 0<br>其他的字符串会转换为 NaN（不是数字）</p>
<pre><code class="JavaScript">Number(&quot;3.14&quot;)  //3.14
Number(&quot; &quot;)     //0
Number(&quot;&quot;)      //0
Number(&quot;99 88&quot;) //NaN
</code></pre>
<h3 id="一元运算符-2"><a href="#一元运算符-2" class="headerlink" title="一元运算符 +"></a>一元运算符 +</h3><p>Operator + 可用于将变量转换为数字<br>如果变量不能转换，它仍是一个数字，但值为 NaN</p>
<pre><code class="JavaScript">var x = &quot;5&quot;
var y = +x      //5

var x = &quot;sdad&quot;
var y = +x      //NaN
</code></pre>
<h3 id="将布尔值转换为数字-2"><a href="#将布尔值转换为数字-2" class="headerlink" title="将布尔值转换为数字"></a>将布尔值转换为数字</h3><p>全局方法 Number() 将布尔值转换为数字</p>
<pre><code class="JavaScript">Number(false)   //0
Number(true)    //1
</code></pre>
<h3 id="将日期转换为数字-2"><a href="#将日期转换为数字-2" class="headerlink" title="将日期转换为数字"></a>将日期转换为数字</h3><p>全局方法 Number() 将日期转换为数字</p>
<pre><code class="JavaScript">obj = new Date()Number(obj)     //1585993392324
obj.getTime()   //1585993392324
</code></pre>
<h3 id="自动转换类型-2"><a href="#自动转换类型-2" class="headerlink" title="自动转换类型"></a>自动转换类型</h3><p>当 JavaScript 尝试操作一个“错误”的数据类型时，会自动转换为“正确“的数据类型</p>
<pre><code class="JavaScript">5 + null    //5         null 转换为 0
&quot;5&quot; + null  //&quot;5null&quot;   null 转换为 &quot;null&quot;
&quot;5&quot; + 1     //51        1 转换为 &quot;1&quot;
&quot;5&quot; - 1     //4         &quot;5&quot; 转换为 5
</code></pre>
<hr>
<h2 id="JavaScript-正则表达式-2"><a href="#JavaScript-正则表达式-2" class="headerlink" title="JavaScript 正则表达式"></a>JavaScript 正则表达式</h2><p>正则表达式（Regular Expression，在代码中常简写为 regex，regexp 或 RE）使用单个字符串来描述、匹配一系列符合某个句法规则的的字符串搜索模式<br>搜索模式可用于文本搜索和文本替换</p>
<h3 id="什么事正则表达式-2"><a href="#什么事正则表达式-2" class="headerlink" title="什么事正则表达式"></a>什么事正则表达式</h3><p>正则表达式是由一个字符序列形成的搜索模式<br>当你在文本中搜索数据时，你可以用搜索模式来描述你要查询的内容<br>正则表达式可以是一个简单的字符，或一个更复杂的模式<br>正则表达式可用于所有文本搜索和文本替换的操作</p>
<pre><code class="JavaScript">/ 正则表达式主体 / 修饰符（可选）
var patt = /nowcoder/i

/nowcoder/i 是一个正则表达式
nowcoder 是一个正则表达式主体（用于检索）
i 是一个修饰符（搜索不区分大小写）
</code></pre>
<h3 id="使用字符串方法-2"><a href="#使用字符串方法-2" class="headerlink" title="使用字符串方法"></a>使用字符串方法</h3><p>在 JavaScript 中，正则表达式通常用于两个字符串方法：search()和 replace()<br>search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置<br>replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串</p>
<h3 id="search-方法使用正则表达式-2"><a href="#search-方法使用正则表达式-2" class="headerlink" title="search() 方法使用正则表达式"></a>search() 方法使用正则表达式</h3><pre><code class="JavaScript">搜索字符串 &quot;Nowcoder&quot;, 并显示匹配的起始位置：
var str = &quot;Visit Nowcoder!&quot;
var n = str.search(/Nowcoder/i)
//6
search 方法可使用字符串作为参数。字符串参数会转换为正则表达式，搜索字符串 &quot;Nowcoder&quot;, 并显示匹配的起始位置：
var str = &quot;Visit Nowcoder!&quot;
var n = str.search(&quot;Nowcoder&quot;)
</code></pre>
<h3 id="replace-方法使用正则表达式-2"><a href="#replace-方法使用正则表达式-2" class="headerlink" title="replace() 方法使用正则表达式"></a>replace() 方法使用正则表达式</h3><pre><code class="JavaScript">使用正则表达式且不区分大小写将字符串中的 Microsoft 替换为 Nowcoder：
var str = document.getElementById(&quot;demo&quot;).innerHTML
var txt  = str.replace(/microsoft/i,&quot;Nowcoder&quot;)
//or
var txt = str.replace(&quot;Microsoft&quot;,&quot;Nowcoder&quot;)
</code></pre>
<h3 id="正则表达式修饰符-2"><a href="#正则表达式修饰符-2" class="headerlink" title="正则表达式修饰符"></a>正则表达式修饰符</h3><table>
<thead>
<tr>
<th style="text-align:center">修饰符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">i</td>
<td style="text-align:center">执行对大小写不敏感的匹配</td>
</tr>
<tr>
<td style="text-align:center">g</td>
<td style="text-align:center">执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）</td>
</tr>
<tr>
<td style="text-align:center">m</td>
<td style="text-align:center">执行多行匹配</td>
</tr>
</tbody>
</table>
<h3 id="使用-test-test-方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回-true，否则返回-false-2"><a href="#使用-test-test-方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回-true，否则返回-false-2" class="headerlink" title="使用 test()test() 方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false"></a>使用 test()test() 方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false</h3><pre><code class="JavaScript">/e/.test(&quot;The best things in life are free!&quot;) //true
字符串中含有“e”
</code></pre>
<h3 id="使用-exec-exec-方法用于检索字符串中的正则表达式的匹配，该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为-null-2"><a href="#使用-exec-exec-方法用于检索字符串中的正则表达式的匹配，该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为-null-2" class="headerlink" title="使用 exec()exec() 方法用于检索字符串中的正则表达式的匹配，该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null"></a>使用 exec()exec() 方法用于检索字符串中的正则表达式的匹配，该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null</h3><pre><code class="JavaScript">/e/.exec(&quot;The best things in life are free!&quot;) //e
字符串中含有“e”
</code></pre>
<hr>
<h2 id="JavaScript-错误-throw、try、catch-2"><a href="#JavaScript-错误-throw、try、catch-2" class="headerlink" title="JavaScript 错误 - throw、try、catch"></a>JavaScript 错误 - throw、try、catch</h2><p>try 语句测试代码块的错误<br>catch 语句处理错误<br>throw 语句创建自定义错误<br>finally 语句在 try 和 catch 语句之后，无论是否有触发异常，该语句都会执行</p>
<h3 id="JavaScript-错误-2"><a href="#JavaScript-错误-2" class="headerlink" title="JavaScript 错误"></a>JavaScript 错误</h3><p>当 JavaScript 引擎执行 JavaScript 代码时，会发生各种错误<br>可能是语法错误，通常是程序员造成的编码错误或错别字<br>可能是拼写错误或语言中缺少的功能（可能由于浏览器差异）<br>可能是由于来自服务器或用户的错误输出而导致的错误<br>当然，也可能是由于许多其他不可预知的因素</p>
<h3 id="JavaScript-抛出（throw）错误-2"><a href="#JavaScript-抛出（throw）错误-2" class="headerlink" title="JavaScript 抛出（throw）错误"></a>JavaScript 抛出（throw）错误</h3><p>当错误发生时，当事情出问题时，JavaScript 引擎通常会停止，并生成一个错误消息<br>描述这种情况的技术术语是：JavaScript 将抛出一个错误</p>
<h3 id="JavaScript-try-和-catch-2"><a href="#JavaScript-try-和-catch-2" class="headerlink" title="JavaScript try 和 catch"></a>JavaScript try 和 catch</h3><p>try 语句允许我们定义在执行时进行错误测试的代码块<br>catch 语句允许我们定义当 try 代码块发生错误时，所执行的代码块<br>JavaScript 语句 try 和 catch 是成对出现的</p>
<pre><code class="JavaScript">try {...    // 异常的抛出} catch(e) {...    // 异常的捕获与处理} finally {...    // 结束处理}

var txt=&quot;&quot;;
function message(){try {adddlert(&quot;Welcome guest!&quot;);
    } catch(err) {
        txt=&quot;本页有一个错误&quot;;
        txt+=&quot;错误描述：&quot; + err.message + &quot; &quot;;
        txt+=&quot;点击确定继续&quot;;
        alert(txt);
    }
}
</code></pre>
<h3 id="JavaScript-throw-和-finally-2"><a href="#JavaScript-throw-和-finally-2" class="headerlink" title="JavaScript throw 和 finally"></a>JavaScript throw 和 finally</h3><p>throw 语句允许我们创建自定义错误<br>正确的技术术语是：创建或抛出异常（exception）<br>如果把 throw 与 try 和 catch 一起使用，那么您能够控制程序流，并生成自定义的错误消息<br>finally 语句不论之前的 try 和 catch 中是否产生异常都会执行该代码块</p>
<pre><code class="JavaScript">function myFunction() {
  var message, x;
  message = document.getElementById(&quot;p01&quot;);
  message.innerHTML = &quot;&quot;;
  x = document.getElementById(&quot;demo&quot;).value;
  try {if(x == &quot;&quot;) throw&quot; 值是空的 &quot;;
    if(isNaN(x)) throw &quot;值不是一个数字&quot;;
    x = Number(x);
    if(x &gt; 10) throw &quot;太大&quot;;
    if(x &lt; 5) throw &quot;太小&quot;;
  }
  catch(err) {message.innerHTML = &quot;错误:&quot; + err + &quot;.&quot;;}
  finally {document.getElementById(&quot;demo&quot;).value = &quot;&quot;;
  }
}
</code></pre>
<hr>
<h2 id="JavaScript-调试-2"><a href="#JavaScript-调试-2" class="headerlink" title="JavaScript 调试"></a>JavaScript 调试</h2><h3 id="console-log-方法-2"><a href="#console-log-方法-2" class="headerlink" title="console.log() 方法"></a>console.log() 方法</h3><p>console.log() 打印 JavaScript 值</p>
<h3 id="设置断点-debugger-2"><a href="#设置断点-debugger-2" class="headerlink" title="设置断点 debugger"></a>设置断点 debugger</h3><p>debugger 关键字用于停止执行 JavaScript，并调用调试函数</p>
<pre><code class="JavaScript">开启 dubugger，则代码在第三行前停止执行
var x = 15 * 5;
debugger;
document.getElementbyId(&quot;demo&quot;).innerHTML = x;
</code></pre>
<hr>
<h2 id="JavaScript-变量提升-2"><a href="#JavaScript-变量提升-2" class="headerlink" title="JavaScript 变量提升"></a>JavaScript 变量提升</h2><p>JavaScript 中，函数及变量的声明都将被提升到函数的最顶端<br>JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明</p>
<pre><code class="JavaScript">x = 5; // 变量 x 设置为 5

elem = document.getElementById(&quot;demo&quot;); // 查找元素
elem.innerHTML = x;                     // 在元素中显示 x

var x; // 声明 x
// 等同于
var x; // 声明 x
x = 5; // 变量 x 设置为 5

elem = document.getElementById(&quot;demo&quot;); // 查找元素
elem.innerHTML = x;                     // 在元素中显示 x
</code></pre>
<h3 id="JavaScript-初始化不会提升-2"><a href="#JavaScript-初始化不会提升-2" class="headerlink" title="JavaScript 初始化不会提升"></a>JavaScript 初始化不会提升</h3><p>JavaScript 只有声明的变量会提升，初始化的不会</p>
<pre><code class="JavaScript">var x = 5; // 初始化 x
var y = 7; // 初始化 y

elem = document.getElementById(&quot;demo&quot;); // 查找元素
elem.innerHTML = x + &quot; &quot; + y;           // 显示 x 和 y
//5 7
var x = 5; // 初始化 x

elem = document.getElementById(&quot;demo&quot;); // 查找元素
elem.innerHTML = x + &quot; &quot; + y;           // 显示 x 和 y

var y = 7; // 初始化 y
//5 undefined
// 等同于
var x = 5; // 初始化 x
var y;     // 声明 y

elem = document.getElementById(&quot;demo&quot;); // 查找元素
elem.innerHTML = x + &quot; &quot; + y;           // 显示 x 和 y

y = 7;    // 设置 y 为 7
</code></pre>
<h3 id="在顶端声明变量-2"><a href="#在顶端声明变量-2" class="headerlink" title="在顶端声明变量"></a>在顶端声明变量</h3><p>为了避免这些问题，通常我们在每个作用域开始前声明这些变量，这也是正常的 JavaScript 解析步骤，易于我们理解<br>JavaScript 严格模式 (strict mode) 不允许使用未声明的变量</p>
<hr>
<h2 id="JavaScript-严格模式（use-strict）-2"><a href="#JavaScript-严格模式（use-strict）-2" class="headerlink" title="JavaScript 严格模式（use strict）"></a>JavaScript 严格模式（use strict）</h2><p>即在严格的条件下进行</p>
<h3 id="使用“use-strict”-指令-2"><a href="#使用“use-strict”-指令-2" class="headerlink" title="使用“use strict” 指令"></a>使用“use strict” 指令</h3><p>严格模式通过在脚本或函数的头部添加 <code>“use strict”</code> 表达式来声明<br>在函数内部声明是局部作用域<br>为什么要用严格模式：</p>
<ul>
<li>消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为</li>
<li>消除代码运行的一些不安全之处，保证代码运行的安全</li>
<li>提高编译器效率，增加运行速度</li>
<li>为未来新版本的 Javascript 做好铺垫</li>
</ul>
<hr>
<h2 id="JavaScript-使用误区-2"><a href="#JavaScript-使用误区-2" class="headerlink" title="JavaScript 使用误区"></a>JavaScript 使用误区</h2><h3 id="赋值运算符应用错误-2"><a href="#赋值运算符应用错误-2" class="headerlink" title="赋值运算符应用错误"></a>赋值运算符应用错误</h3><p>在 JavaScript 程序中如果在 if 条件语句中使用赋值运算符的等号 (=) 将会产生一个错误结果, 正确的方法是使用比较运算符的两个等号 (==)</p>
<pre><code class="JavaScript">var x = 0;
if (x == 10)    //false

var x = 0;
if (x = 10)     //true 

var x = 0;
if (x = 0)      //false
</code></pre>
<h3 id="比较运算符常见错误-2"><a href="#比较运算符常见错误-2" class="headerlink" title="比较运算符常见错误"></a>比较运算符常见错误</h3><p>在常规比较重，数据类型是被忽略的</p>
<pre><code class="JavaScript">var x = 10;
var y = &quot;10&quot;;
if (x == y)     //true

var x = 10;
var y = &quot;10&quot;;
if (x === y)    //false
</code></pre>
<p>switch 语句会使用恒等计算符（===）进行比较</p>
<pre><code class="JavaScript">var x = 10;
switch(x) {case 10: alert(&quot;Hello&quot;);
}   // 执行

var x = 10;
switch(x) {case &quot;10&quot;: alert(&quot;Hello&quot;);
}   // 不执行
</code></pre>
<h3 id="加法与连接注意事项-2"><a href="#加法与连接注意事项-2" class="headerlink" title="加法与连接注意事项"></a>加法与连接注意事项</h3><p>加法是两个数字相加<br>连接是两个字符串连接<br>JavaScript 的加法和连接都用 + 运算符</p>
<pre><code class="JavaScript">var x = 10 + 5;          // x 的结果为 15
var x = 10 + &quot;5&quot;;        // x 的结果为 &quot;105&quot;

var x = 10;
var y = 5;
var z = x + y;           // z 的结果为 15

var x = 10;
var y = &quot;5&quot;;
var z = x + y;           // z 的结果为 &quot;105&quot;
</code></pre>
<h3 id="浮点型数据使用注意事项-2"><a href="#浮点型数据使用注意事项-2" class="headerlink" title="浮点型数据使用注意事项"></a>浮点型数据使用注意事项</h3><p>JavaScript 中的所有数据都是以 64 位浮点型数据（float）来存储</p>
<pre><code class="JavaScript">var x = 0.1;
var y = 0.2;
var z = x + y            // z 的结果为 0.3
if (z == 0.3)            // 返回 false

可以用整数的乘除法来解决：
var z = (x * 10 + y * 10) / 10;       // z 的结果为 0.3
</code></pre>
<h3 id="JavaScript-字符串分行-2"><a href="#JavaScript-字符串分行-2" class="headerlink" title="JavaScript 字符串分行"></a>JavaScript 字符串分行</h3><pre><code class="JavaScript">var x =
&quot;Hello World!&quot;;

var x = &quot;Hello
World!&quot;;            // 报错

var x = &quot;Hello \nWorld!&quot;;
</code></pre>
<hr>
<h2 id="JavaScript-表单-2"><a href="#JavaScript-表单-2" class="headerlink" title="JavaScript 表单"></a>JavaScript 表单</h2><p>HTML 表单验证可以通过 JavaScript 完成</p>
<pre><code class="html">&lt;form name=&quot;myForm&quot; action=&quot;//www.nowcoder.com&quot;
      onsubmit=&quot;return validateForm()&quot; method=&quot;post&quot;&gt;
    名字: &lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
&lt;/form&gt;
</code></pre>
<pre><code class="js">function validateForm(){var x = document.forms[&quot;myForm&quot;][&quot;fname&quot;].value;
    if (x == null || x == &quot;&quot;) {alert(&quot; 需要输入名字。&quot;);
        return false;
    }
}
用于判断表单字段 (fname) 值是否存在， 如果不存在，就弹出信息，阻止表单提交
</code></pre>
<h3 id="JavaScript-验证输入的数字-2"><a href="#JavaScript-验证输入的数字-2" class="headerlink" title="JavaScript 验证输入的数字"></a>JavaScript 验证输入的数字</h3><pre><code class="js">function myFunction() {
    var x, text;

    // 获取 id=&quot;numb&quot; 的值
    x = document.getElementById(&quot;numb&quot;).value;

    // 如果输入的值 x 不是数字或者小于 1 或者大于 10，
    // 则提示错误 Not a Number or less than one or greater than 10
    if (isNaN(x) || x &lt; 1 || x &gt; 10){text = &quot;输入错误&quot;;} else {text = &quot;输入正确&quot;;}
    document.getElementById(&quot;demo&quot;).innerHTML = text;
}
</code></pre>
<h3 id="HTML-表单自动验证-2"><a href="#HTML-表单自动验证-2" class="headerlink" title="HTML 表单自动验证"></a>HTML 表单自动验证</h3><pre><code class="html">如果表单字段 (fname) 的值为空, required 属性会阻止表单提交：
&lt;form action=&quot;//www.nowcoder.com&quot; method=&quot;post&quot;&gt;
  &lt;input type=&quot;text&quot; name=&quot;fname&quot; required=&quot;required&quot;&gt;
  &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
&lt;/form&gt;
</code></pre>
<h3 id="数据验证-2"><a href="#数据验证-2" class="headerlink" title="数据验证"></a>数据验证</h3><p>数据验证用于确保用户输入的数据是有效的<br>典型的数据验证有：</p>
<ul>
<li>必需字段是否有输入?</li>
<li>用户是否输入了合法的数据?</li>
<li>在数字字段是否输入了文本?</li>
</ul>
<p>大多数情况下，数据验证用于确保用户正确输入数据<br>数据验证可以使用不同方法来定义，并通过多种方式来调用<br>服务端数据验证是在数据提交到服务器上后再验证<br>客户端数据验证是在数据发送到服务器前，在浏览器上完成验证</p>
<h3 id="HTML-约束验证-2"><a href="#HTML-约束验证-2" class="headerlink" title="HTML 约束验证"></a>HTML 约束验证</h3><p>HTML5 新增了 HTML 表单验证方式：约束验证<br>约束验证是表单被提交时浏览器用来实现验证的一种算法<br>HTML 约束验证基于：</p>
<ul>
<li>HTML 输入属性</li>
<li>CSS 伪类选择器</li>
<li>DOM 属性和方法</li>
</ul>
<p>约束验证 HTML 输入属性</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">disabled</td>
<td style="text-align:center">规定输入的元素不可用</td>
</tr>
<tr>
<td style="text-align:center">max</td>
<td style="text-align:center">规定输入元素的最大值</td>
</tr>
<tr>
<td style="text-align:center">min</td>
<td style="text-align:center">规定输入元素的最小值</td>
</tr>
<tr>
<td style="text-align:center">pattern</td>
<td style="text-align:center">规定输入元素值的模式</td>
</tr>
<tr>
<td style="text-align:center">required</td>
<td style="text-align:center">规定输入元素字段是必需的</td>
</tr>
<tr>
<td style="text-align:center">type</td>
<td style="text-align:center">规定输入元素的类型</td>
</tr>
</tbody>
</table>
<p>约束验证 CSS 伪类选择器</p>
<table>
<thead>
<tr>
<th style="text-align:center">选择器</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">:disabled</td>
<td style="text-align:center">选取属性为”disabled”属性的 input 元素</td>
</tr>
<tr>
<td style="text-align:center">:invalid</td>
<td style="text-align:center">选取无效的 input 元素</td>
</tr>
<tr>
<td style="text-align:center">:optional</td>
<td style="text-align:center">选择没有”required”属性的 input 元素</td>
</tr>
<tr>
<td style="text-align:center">:required</td>
<td style="text-align:center">选择有”required”属性的 input 元素</td>
</tr>
<tr>
<td style="text-align:center">:valid</td>
<td style="text-align:center">选取有效值的 input 元素</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="JavaScript-表单验证-2"><a href="#JavaScript-表单验证-2" class="headerlink" title="JavaScript 表单验证"></a>JavaScript 表单验证</h2><p>JavaScript 可用来在数据被送往服务器前对 HTML 表单中的这些输入数据进行验证<br>表单数据经常需要使用 JavaScript 来验证其正确性：</p>
<ul>
<li>验证表单数据是否为空？</li>
<li>验证输入是否是一个正确的 email 地址？</li>
<li>验证日期是否输入正确？</li>
<li>验证表单输入内容是否为数字型？</li>
</ul>
<h3 id="必填或必选项目-2"><a href="#必填或必选项目-2" class="headerlink" title="必填或必选项目"></a>必填或必选项目</h3><p>form 表单提交时调用函数检查用户是否已填写表单中的必填项目，假如为空，则发出警告</p>
<pre><code class="html">&lt;form name=&quot;myForm&quot; action=&quot;//www.nowcoder.com&quot;
    onsubmit=&quot;return validateForm()&quot; method=&quot;post&quot;&gt;
    姓: &lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
&lt;/form&gt;
</code></pre>
<pre><code class="js">function validateForm(){var x=document.forms[&quot;myForm&quot;][&quot;fname&quot;].value;
  if (x==null || x==&quot;&quot;) {alert(&quot; 姓必须填写 &quot;);
    return false;
  }
}
</code></pre>
<h3 id="E-mail-验证-2"><a href="#E-mail-验证-2" class="headerlink" title="E-mail 验证"></a>E-mail 验证</h3><p>函数检查用户输入的数据是否符合电子邮件地址的基本语法</p>
<pre><code class="html">&lt;form name=&quot;myForm&quot; action=&quot;//www.nowcoder.com&quot;
      onsubmit=&quot;return validateForm();&quot; method=&quot;post&quot;&gt;
    Email: &lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
&lt;/form&gt;
</code></pre>
<pre><code class="js">function validateForm(){var x=document.forms[&quot;myForm&quot;][&quot;email&quot;].value;
  var atpos=x.indexOf(&quot;@&quot;);
  var dotpos=x.lastIndexOf(&quot;.&quot;);
  if (atpos&lt;1 || dotpos&lt;atpos+2 || dotpos+2&gt;=x.length){alert(&quot;不是一个有效的 e-mail 地址&quot;);
    return false;
  }
}
// 输入的数据必须包含 @ 符号和点号 (.)。同时，@ 不可以是邮件地址的首字符，并且 @ 之后需有至少一个点号
</code></pre>
<hr>
<h2 id="JavaScript-this-关键字-2"><a href="#JavaScript-this-关键字-2" class="headerlink" title="JavaScript this 关键字"></a>JavaScript this 关键字</h2><p>面向对象语言中 this 表示当前对象的一个引用<br>但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变</p>
<ul>
<li>在方法中，this 表示该方法所属的对象</li>
<li>如果单独使用，this 表示全局对象</li>
<li>在函数中，this 表示全局对象</li>
<li>在函数中，在严格模式下，this 是未定义的 (undefined)</li>
<li>在事件中，this 表示接收事件的元素</li>
<li>类似 call()和 apply() 方法可以将 this 引用到任何对象</li>
</ul>
<h3 id="方法中的-this-2"><a href="#方法中的-this-2" class="headerlink" title="方法中的 this"></a>方法中的 this</h3><p>在对象方法中，this 指向调用它所在方法的对象</p>
<pre><code class="js">var person = {
  firstName: &quot;John&quot;,
  lastName : &quot;Doe&quot;,
  id       : 5566,
  fullName : function(){return this.firstName + &quot; &quot; + this.lastName;}
};
</code></pre>
<h3 id="单独使用-this-2"><a href="#单独使用-this-2" class="headerlink" title="单独使用 this"></a>单独使用 this</h3><p>单独使用 this，则指向全局对象（Global）<br>在浏览器中，window 就是该全局对象 [object Window]</p>
<pre><code class="js">var x = this //object Window
</code></pre>
<h3 id="函数中使用-this（默认）-2"><a href="#函数中使用-this（默认）-2" class="headerlink" title="函数中使用 this（默认）"></a>函数中使用 this（默认）</h3><p>在函数中，函数的所属者默认绑定到 this 上<br>//object Window</p>
<h3 id="函数中使用-this（严格模式）-2"><a href="#函数中使用-this（严格模式）-2" class="headerlink" title="函数中使用 this（严格模式）"></a>函数中使用 this（严格模式）</h3><p>严格模式下函数是没有绑定到 this 上的，this 为 undefined</p>
<h3 id="事件中的-this-2"><a href="#事件中的-this-2" class="headerlink" title="事件中的 this"></a>事件中的 this</h3><p>在 HTML 事件中，this 指向了接受事件的 HTML 元素</p>
<pre><code class="html">&lt;button onclick=&quot;this.style.display=&#39;none&#39;&quot;&gt;
点我后我就消失了
&lt;/button&gt;
</code></pre>
<h3 id="对象方法中绑定-2"><a href="#对象方法中绑定-2" class="headerlink" title="对象方法中绑定"></a>对象方法中绑定</h3><pre><code class="js">var person = {
  firstName  : &quot;John&quot;,
  lastName   : &quot;Doe&quot;,
  id         : 5566,
  myFunction : function(){return this;}
};//[object Object]

var person = {
  firstName: &quot;John&quot;,
  lastName : &quot;Doe&quot;,
  id       : 5566,
  fullName : function(){return this.firstName + &quot; &quot; + this.lastName;}
};//John Doe
this.firstName 表示 this（person）对象的 firstName 属性
</code></pre>
<h3 id="显式函数绑定-2"><a href="#显式函数绑定-2" class="headerlink" title="显式函数绑定"></a>显式函数绑定</h3><p>在 JavaScript 中函数也是对象，对象则有方法，apply 和 call 就是函数对象的方法，这两个方法异常强大，他们允许切换函数执行的上下文环境（context），即 this 绑定的对象<br>下面实例中，使用 person2 作为参数来调用 person1.fullName 方法时，this 将指向 person2，即便它是 person1 的方法</p>
<pre><code class="js">var person1 = {fullName: function() {return this.firstName + &quot; &quot; + this.lastName;}
}
var person2 = {
  firstName:&quot;John&quot;,
  lastName: &quot;Doe&quot;,
}
person1.fullName.call(person2);  // 返回 &quot;John Doe&quot;
</code></pre>
<hr>
<h2 id="JavaScript-let-和-const-2"><a href="#JavaScript-let-和-const-2" class="headerlink" title="JavaScript let 和 const"></a>JavaScript let 和 const</h2><p>ES6 新增加了两个重要的 Javascript 关键字：let 和 const<br>let 声明的变量只在 let 命令所在的代码块内有效<br>const 声明一个只读的常量，一旦声明，常量的值就不能改变<br>在 ES6 之前，Javascript 只有两种作用域：全局变量与函数内的局部变量</p>
<h3 id="全局变量-6"><a href="#全局变量-6" class="headerlink" title="全局变量"></a>全局变量</h3><p>在函数外声明的变量作用域是全局的<br>全局变量在 Javascript 程序的任何地方都可以访问</p>
<pre><code class="js">var carName = &quot;Volvo&quot;;
// 这里可以使用 carName 变量
function myFunction(){// 这里也可以使用 carName 变量}
</code></pre>
<h3 id="局部变量-4"><a href="#局部变量-4" class="headerlink" title="局部变量"></a>局部变量</h3><p>在函数内声明的变量作用域是局部的<br>函数内使用 var 声明的变量只能在函数内容访问，如果不使用 var 则是全局变量</p>
<pre><code class="js">// 这里不能使用 carName 变量
function myFunction() {
    var carName = &quot;Volvo&quot;;
    // 这里可以使用 carName 变量
}
// 这里不能使用 carName 变量
</code></pre>
<h3 id="JavaScript-块级作用域（Block-Scope）-2"><a href="#JavaScript-块级作用域（Block-Scope）-2" class="headerlink" title="JavaScript 块级作用域（Block Scope）"></a>JavaScript 块级作用域（Block Scope）</h3><p>使用 var 关键字声明的变量不具备块级作用域的特性，它在 {} 外依然能被访问到</p>
<pre><code class="js">{var x = 2;}
// 这里可以使用 x 变量
</code></pre>
<p>在 ES6 之前，是没有块级作用域的概念的<br>ES6 可以使用 let 关键字来实现块级作用域<br>let 声明的变量只在 let 命令所在的代码块 {} 内有效，在 {} 之外不能访问</p>
<pre><code class="js">{let x = 2;}
// 这里不能使用 x 变量
</code></pre>
<h3 id="重新定义变量-2"><a href="#重新定义变量-2" class="headerlink" title="重新定义变量"></a>重新定义变量</h3><p>使用 var 关键字重新声明变量可能会带来问题<br>在块中重新声明变量也会重新声明块外的变量</p>
<pre><code class="js">var x = 10;
// 这里输出 x 为 10
{
    var x = 2;
    // 这里输出 x 为 2
}
// 这里输出 x 为 2
</code></pre>
<h3 id="循环作用域-2"><a href="#循环作用域-2" class="headerlink" title="循环作用域"></a>循环作用域</h3><p>使用 var 关键字</p>
<pre><code class="js">var i = 5;
for (var i = 0; i &lt; 10; i++) {// 一些代码...}
// 这里输出 i 为 10
</code></pre>
<p>let 关键字</p>
<pre><code class="js">let i = 5;
for (let i = 0; i &lt; 10; i++) {// 一些代码...}
// 这里输出 i 为 5
</code></pre>
<p>在第一个实例中，使用了 var 关键字，它声明的变量是全局的，包括循环体内与循环体外<br>在第二个实例中，使用 let 关键字， 它声明的变量作用域只在循环体内，循环体外的变量不受影响</p>
<h3 id="局部变量-5"><a href="#局部变量-5" class="headerlink" title="局部变量"></a>局部变量</h3><p>在函数体内使用 var 和 let 关键字声明的变量有点类似</p>
<pre><code class="js">// 使用 var
function myFunction(){var carName = &quot;Volvo&quot;;   // 局部作用域}

// 使用 let
function myFunction(){let carName = &quot;Volvo&quot;;   //  局部作用域}
</code></pre>
<h3 id="全局变量-7"><a href="#全局变量-7" class="headerlink" title="全局变量"></a>全局变量</h3><p>在函数体内或代码块外使用 var 和 let 关键字声明的变量也有点类似<br>它们的作用域都是全局的</p>
<pre><code class="js">// 使用 var
var x = 2;       // 全局作用域

// 使用 let
let x = 2;       // 全局作用域
</code></pre>
<h3 id="HTML-代码中使用全局变量-2"><a href="#HTML-代码中使用全局变量-2" class="headerlink" title="HTML 代码中使用全局变量"></a>HTML 代码中使用全局变量</h3><p>在 JavaScript 中, 全局作用域是针对 JavaScript 环境<br>在 HTML 中, 全局作用域是针对 window 对象<br>使用 var 关键字声明的全局作用域变量属于 window 对象：</p>
<pre><code class="js">var carName = &quot;Volvo&quot;;
// 可以使用 window.carName 访问变量
</code></pre>
<p>使用 let 关键字声明的全局作用域变量不属于 window 对象</p>
<pre><code class="js">let carName = &quot;Volvo&quot;
// 不能使用 window.carName 访问变量
</code></pre>
<h3 id="重制变量-2"><a href="#重制变量-2" class="headerlink" title="重制变量"></a>重制变量</h3><p>使用 var 关键字声明的变量在任何地方都可以修改</p>
<pre><code class="js">var x = 2;
// x 为 2

var x = 3;
// 现在 x 为 3
</code></pre>
<p>在相同的作用域或块级作用域中，不能使用 let 关键字来重置 var 关键字声明的变量：</p>
<pre><code class="js">var x = 2;       // 合法
let x = 3;       // 不合法

{
    var x = 4;   // 合法
    let x = 5   // 不合法
}
</code></pre>
<p>在相同的作用域或块级作用域中，不能使用 let 关键字来重置 let 关键字声明的变量：</p>
<pre><code class="js">let x = 2;       // 合法
let x = 3;       // 不合法

{
    let x = 4;   // 合法
    let x = 5;   // 不合法
}
</code></pre>
<p>在相同的作用域或块级作用域中，不能使用 var 关键字来重置 let 关键字声明的变量：</p>
<pre><code class="js">let x = 2;       // 合法
var x = 3;       // 不合法

{
    let x = 4;   // 合法
    var x = 5;   // 不合法
}
</code></pre>
<p>let 关键字在不同作用域，或不同块级作用域中是可以重新声明赋值的：</p>
<pre><code class="js">let x = 2;       // 合法

{let x = 3;   // 合法}

{let x = 4;   // 合法}
</code></pre>
<h3 id="变量提升-2"><a href="#变量提升-2" class="headerlink" title="变量提升"></a>变量提升</h3><p>JavaScript 中，var 关键字定义的变量可以在使用后声明，也就是变量可以先使用再声明</p>
<pre><code class="js">// 在这里可以使用 carName 变量

var carName;
</code></pre>
<p>let 关键字定义的变量则不可以在使用后声明，也就是变量需要先声明再使用。</p>
<pre><code class="js">// 在这里不可以使用 carName 变量

let carName;
</code></pre>
<p>const 关键字定义的变量则不可以在使用后声明，也就是变量需要先声明再使用</p>
<pre><code class="js">carName = &quot;Volvo&quot;;    // 在这里不可以使用 carName 变量
const carName = &quot;Volvo&quot;;
</code></pre>
<h3 id="const-关键字-2"><a href="#const-关键字-2" class="headerlink" title="const 关键字"></a>const 关键字</h3><p>const 用于声明一个或多个常量，声明时必须进行初始化，且初始化后值不可再修改</p>
<pre><code class="js">const PI = 3.141592653589793;
PI = 3.14;      // 报错
PI = PI + 10;   // 报错
</code></pre>
<p>const 定义常量与使用 let 定义的变量相似：</p>
<ul>
<li>二者都是块级作用域</li>
<li>都不能和它所在作用域内的其他变量或函数拥有相同的名称</li>
</ul>
<p>两者还有以下两点区别：</p>
<ul>
<li>const 声明的常量必须初始化，而 let 声明的变量不用</li>
<li>const 定义常量的值不能通过再赋值修改，也不能再次声明。而 let 定义的变量值可以修改</li>
</ul>
<pre><code class="js">var x = 10;
// 这里输出 x 为 10
{
    const x = 2;
    // 这里输出 x 为 2
}
// 这里输出 x 为 10
</code></pre>
<p>const 声明的常量必须初始化：</p>
<pre><code class="js">// 错误写法
const PI;
PI = 3.14159265359;

// 正确写法
const PI = 3.14159265359;
</code></pre>
<h3 id="并非真正的常量-2"><a href="#并非真正的常量-2" class="headerlink" title="并非真正的常量"></a>并非真正的常量</h3><p>const 的本质: const 定义的变量并非常量，并非不可变，它定义了一个常量引用一个值。使用 const 定义的对象或者数组，其实是可变的。下面的代码并不会报错：</p>
<pre><code class="js">// 创建常量对象
const car = {type:&quot;Fiat&quot;, model:&quot;500&quot;, color:&quot;white&quot;};

// 修改属性:
car.color = &quot;red&quot;;

// 添加属性
car.owner = &quot;Johnson&quot;;
</code></pre>
<p>但是我们不能对常量对象重新赋值：</p>
<pre><code class="js">const car = {type:&quot;Fiat&quot;, model:&quot;500&quot;, color:&quot;white&quot;};
car = {type:&quot;Volvo&quot;, model:&quot;EX60&quot;, color:&quot;red&quot;};    // 错误
</code></pre>
<p>以下实例修改常量数组：</p>
<pre><code class="js">// 创建常量数组
const cars = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;];

// 修改元素
cars[0] = &quot;Toyota&quot;;

// 添加元素
cars.push(&quot;Audi&quot;);
</code></pre>
<p>但是我们不能对常量数组重新赋值：</p>
<pre><code class="js">const cars = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;];
cars = [&quot;Toyota&quot;, &quot;Volvo&quot;, &quot;Audi&quot;];    // 错误
</code></pre>
<h3 id="重置变量-2"><a href="#重置变量-2" class="headerlink" title="重置变量"></a>重置变量</h3><p>使用 var 关键字声明的变量在任何地方都可以修改</p>
<pre><code class="js">var x = 2;    //  合法
var x = 3;    //  合法
x = 4;        //  合法
</code></pre>
<p>在相同的作用域或块级作用域中，不能使用 const 关键字来重置 var 和 let 关键字声明的变量：</p>
<pre><code class="js">var x = 2;         // 合法
const x = 2;       // 不合法
{
    let x = 2;     // 合法
    const x = 2;   // 不合法
}
</code></pre>
<p>在相同的作用域或块级作用域中，不能使用 const 关键字来重置 const 关键字声明的变量：</p>
<pre><code class="js">const x = 2;       // 合法
const x = 3;       // 不合法
x = 3;             // 不合法
var x = 3;         // 不合法
let x = 3;         // 不合法

{
    const x = 2;   // 合法
    const x = 3;   // 不合法
    x = 3;         // 不合法
    var x = 3;     // 不合法
    let x = 3;     // 不合法
}
</code></pre>
<p>const 关键字在不同作用域，或不同块级作用域中是可以重新声明赋值的：</p>
<pre><code class="js">const x = 2;       // 合法

{const x = 3;   // 合法}

{const x = 4;   // 合法}
</code></pre>
<hr>
<h2 id="Javascript-JSON-2"><a href="#Javascript-JSON-2" class="headerlink" title="Javascript JSON"></a>Javascript JSON</h2><p>JSON 是用于存储和传输数据的格式<br>JSON 通常用于服务端向网页传递数据 </p>
<h3 id="什么是-JSON？-2"><a href="#什么是-JSON？-2" class="headerlink" title="什么是 JSON？"></a>什么是 JSON？</h3><p>JSON 英文全称 JavaScript Object Notation<br>JSON 是一种轻量级的数据交换格式<br>JSON 是独立的语言<br>JSON 易于理解<br>JSON 使用 JavaScript 语法，但是 JSON 格式仅仅是一个文本<br>文本可以被任何编程语言读取及作为数据格式传递</p>
<h3 id="JSON-实例-2"><a href="#JSON-实例-2" class="headerlink" title="JSON 实例"></a>JSON 实例</h3><p>JSON 语法定义了 sites 对象：3 条网站信息（对象）的数组：</p>
<pre><code class="js">{&quot;sites&quot;:[{&quot;name&quot;:&quot;Runoob&quot;, &quot;url&quot;:&quot;www.nowcoder.com&quot;},
    {&quot;name&quot;:&quot;Google&quot;, &quot;url&quot;:&quot;www.google.com&quot;},
    {&quot;name&quot;:&quot;Taobao&quot;, &quot;url&quot;:&quot;www.taobao.com&quot;}
]}
</code></pre>
<h3 id="JSON-格式化后为-JavaScript-对象-2"><a href="#JSON-格式化后为-JavaScript-对象-2" class="headerlink" title="JSON 格式化后为 JavaScript 对象"></a>JSON 格式化后为 JavaScript 对象</h3><p>JSON 格式在语法上与创建 JavaScript 对象代码是相同的<br>由于它们很相似，所以 JavaScript 程序可以很容易的将 JSON 数据转换为 JavaScript 对象</p>
<h3 id="JSON-语法规则-2"><a href="#JSON-语法规则-2" class="headerlink" title="JSON 语法规则"></a>JSON 语法规则</h3><p>数据为 键 / 值 对<br>数据由逗号分隔<br>大括号保存对象<br>方括号保存数组</p>
<h3 id="JSON-数据-一个名称对应一个值-2"><a href="#JSON-数据-一个名称对应一个值-2" class="headerlink" title="JSON 数据 - 一个名称对应一个值"></a>JSON 数据 - 一个名称对应一个值</h3><p>JSON 数据格式为 键 / 值 对，就像 JavaScript 对象属性<br>键 / 值对包括字段名称（在双引号中），后面一个冒号，然后是值：<br><code>&quot;name&quot;:&quot;Nowcoder&quot;</code></p>
<h3 id="JSON-对象-2"><a href="#JSON-对象-2" class="headerlink" title="JSON 对象"></a>JSON 对象</h3><p>JSON 对象保存在大括号内<br>就像在 JavaScript 中, 对象可以保存多个 键 / 值 对：<br><code>{&quot;name&quot;:&quot;Nowcoder&quot;, &quot;url&quot;:&quot;www.nowcoder.com&quot;}</code></p>
<h3 id="JSON-数组-2"><a href="#JSON-数组-2" class="headerlink" title="JSON 数组"></a>JSON 数组</h3><p>JSON 数组保存在中括号内<br>就像在 JavaScript 中, 数组可以包含对象：</p>
<pre><code class="js">&quot;sites&quot;:[{&quot;name&quot;:&quot;Nowcoder&quot;, &quot;url&quot;:&quot;www.nowcoder.com&quot;},
    {&quot;name&quot;:&quot;Google&quot;, &quot;url&quot;:&quot;www.google.com&quot;},
    {&quot;name&quot;:&quot;Taobao&quot;, &quot;url&quot;:&quot;www.taobao.com&quot;}
]
在以上实例中，对象 &quot;sites&quot; 是一个数组，包含了三个对象
每个对象为站点的信息（网站名和网站地址）
</code></pre>
<h3 id="JSON-字符串转换为-Javascript-对象-2"><a href="#JSON-字符串转换为-Javascript-对象-2" class="headerlink" title="JSON 字符串转换为 Javascript 对象"></a>JSON 字符串转换为 Javascript 对象</h3><p>通常我们从服务器中读取 JSON 数据，并在网页中显示数据<br>简单起见，我们网页中直接设置 JSON 字符串：<br>首先，创建 JavaScript 字符串，字符串为 JSON 格式的数据：</p>
<pre><code class="js">var text = &#39;{&quot;sites&quot;: [&#39; +
    &#39;{&quot;name&quot;:&quot;Nowcoder&quot;,&quot;url&quot;:&quot;www.nowcoder.com&quot;},&#39; +
    &#39;{&quot;name&quot;:&quot;Google&quot;,&quot;url&quot;:&quot;www.google.com&quot;},&#39; +
    &#39;{&quot;name&quot;:&quot;Taobao&quot;,&quot;url&quot;:&quot;www.taobao.com&quot;} ]}&#39;;

obj = JSON.parse(text); // 内置函数 JSON.parse() 将字符串转换为 JavaScript 对象
document.getElementById(&quot;demo&quot;).innerHTML = obj.sites[1].name + &quot; &quot; + obj.sites[1].url;
</code></pre>
<hr>
<h2 id="JavaScript-void-0-含义-2"><a href="#JavaScript-void-0-含义-2" class="headerlink" title="JavaScript:void(0) 含义"></a>JavaScript:void(0) 含义</h2><p>javascript:void(0) 中最关键的是 void 关键字， void 是 JavaScript 中非常重要的关键字，该操作符指定要计算一个表达式但是不返回值</p>
<pre><code class="html">语法格式：
&lt;head&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
&lt;!--
void func()javascript:void func()

或者

void(func())
javascript:void(func())
//--&gt;
&lt;/script&gt;
&lt;/head&gt;

&lt;a href=&quot;javascript:void(0)&quot;&gt; 单击此处什么也不会发生 &lt;/a&gt;
// 当用户链接时，void(0) 计算为 0，但 Javascript 上没有任何效果

&lt;head&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
&lt;!--
//--&gt;
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;a href=&quot;javascript:void(alert(&#39;Warning!!!&#39;))&quot;&gt; 点我!&lt;/a&gt;
&lt;/body&gt;
// 在用户点击链接后显示警告信息

&lt;head&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
&lt;!--
function getValue(){
  var a,b,c;
  a = void (b = 5, c = 7);
  document.write(&#39;a =&#39; + a + &#39;b =&#39; + b +&#39;c =&#39; + c);
}
//--&gt;
&lt;/script&gt;
&lt;/head&gt;
// 参数 a 返回 undefined
</code></pre>
<h3 id="href-”-”-与-href-”javascript-void-0-”-的区别-2"><a href="#href-”-”-与-href-”javascript-void-0-”-的区别-2" class="headerlink" title="href=”#” 与 href=”javascript:void(0)” 的区别"></a>href=”#” 与 href=”javascript:void(0)” 的区别</h3><p># 包含了一个位置信息，默认的锚是 #top 也就是网页的上端<br>而 javascript:void(0), 仅仅表示一个死链接<br>在页面很长的时候会使用 # 来定位页面的具体位置，格式为：# + id<br>如果你要定义一个死链接请使用 javascript:void(0) </p>
<pre><code class="html">&lt;a href=&quot;javascript:void(0);&quot;&gt; 点我没有反应的!&lt;/a&gt;
&lt;a href=&quot;#pos&quot;&gt; 点我定位到指定位置!&lt;/a&gt;
&lt;br&gt;
...
&lt;br&gt;
&lt;p id=&quot;pos&quot;&gt; 尾部定位点 &lt;/p&gt;
</code></pre>
<hr>
<h2 id="JavaScript-代码规范-4"><a href="#JavaScript-代码规范-4" class="headerlink" title="JavaScript 代码规范"></a>JavaScript 代码规范</h2><p>所有的 JavaScript 项目都适用同一种规范</p>
<h3 id="JavaScript-代码规范-5"><a href="#JavaScript-代码规范-5" class="headerlink" title="JavaScript 代码规范"></a>JavaScript 代码规范</h3><p>代码规范通常包括以下几个方面：</p>
<ul>
<li>变量和函数的命名规则</li>
<li>空格，缩进，注释的使用规则</li>
<li>其他常用规范</li>
</ul>
<p>规范的代码更易于阅读与维护</p>
<h3 id="变量名-2"><a href="#变量名-2" class="headerlink" title="变量名"></a>变量名</h3><p>一般使用驼峰法来命名</p>
<pre><code class="js">firstName = &quot;John&quot;;
lastName = &quot;Doe&quot;;

price = 19.90;
tax = 0.20;

fullPrice = price + (price * tax);
</code></pre>
<h3 id="空格与运算符-2"><a href="#空格与运算符-2" class="headerlink" title="空格与运算符"></a>空格与运算符</h3><p>通常运算符（= + - * /）前后需要添加空格</p>
<h3 id="代码缩进-2"><a href="#代码缩进-2" class="headerlink" title="代码缩进"></a>代码缩进</h3><p>通常使用 4 个空格来缩进代码块</p>
<h3 id="语句规则-2"><a href="#语句规则-2" class="headerlink" title="语句规则"></a>语句规则</h3><p>简单语句</p>
<ul>
<li>一条语句通常以分号来作为结束符</li>
</ul>
<p>复杂语句</p>
<ul>
<li>将左花括号放在第一行的结尾</li>
<li>左花括号前添加一空格</li>
<li>将右花括号独立放在一行</li>
<li>不要以分号结束一个复杂的声明</li>
</ul>
<pre><code class="js">var values = [&quot;Volvo&quot;, &quot;Saab&quot;, &quot;Fiat&quot;];

var person = {
    firstName: &quot;John&quot;,
    lastName: &quot;Doe&quot;,
    age: 50,
    eyeColor: &quot;blue&quot;
};

function toCelsius(fahrenheit) {return (5 / 9) * (fahrenheit - 32);
}

for (i = 0; i &lt; 5; i++) {x += i;}

if (time &lt; 20) {greeting = &quot;Good day&quot;;} else {greeting = &quot;Good evening&quot;;}
</code></pre>
<h3 id="对象规则-2"><a href="#对象规则-2" class="headerlink" title="对象规则"></a>对象规则</h3><p>对象定义的规则：</p>
<ul>
<li>将左花括号与类名放在同一行</li>
<li>冒号与属性值间有个空格</li>
<li>字符串使用双引号，数字不需要</li>
<li>最后一个属性 - 值对后面不要添加逗号</li>
<li>将右花括号独立放在一行，并以分号作为结束符号</li>
</ul>
<pre><code class="js">var person = {
    firstName: &quot;John&quot;,
    lastName: &quot;Doe&quot;,
    age: 50,
    eyeColor: &quot;blue&quot;
};
//or
var person = {firstName:&quot;John&quot;, lastName:&quot;Doe&quot;, age:50, eyeColor:&quot;blue&quot;};
</code></pre>
<h3 id="命名规则-2"><a href="#命名规则-2" class="headerlink" title="命名规则"></a>命名规则</h3><p>一般很多代码语言的命名规则都是类似的，例如:</p>
<ul>
<li>变量和函数为小驼峰法标识, 即除第一个单词之外，其他单词首字母大写（ lowerCamelCase）</li>
<li>全局变量为大写 (UPPERCASE)</li>
<li>常量 (如 PI) 为大写 (UPPERCASE)</li>
</ul>
<p>HTML 和 CSS 的横杠 (-) 字符:<br>HTML5 属性可以以 data- (如：data-quantity, data-price) 作为前缀<br>CSS 使用 - 来连接属性名 (font-size)</p>
<ul>
<li>通常在 JavaScript 中被认为是减法，所以不允许使用</li>
</ul>
<p>下划线:<br>很多程序员比较喜欢使用下划线 (如：date_of_birth), 特别是在 SQL 数据库中<br>PHP 语言通常都使用下划线</p>
<p>帕斯卡拼写法 (PascalCase):<br>帕斯卡拼写法 (PascalCase) 在 C 语言中语言较多</p>
<p>驼峰法：<br>JavaScript 中通常推荐使用驼峰法，jQuery 及其他 JavaScript 库都使用驼峰法<br>变量名不要以 $ 作为开始标记，会与很多 JavaScript 库冲突</p>
<hr>
<h1 id="JS-函数-2"><a href="#JS-函数-2" class="headerlink" title="JS 函数"></a>JS 函数</h1><h2 id="JavaScript-函数定义-2"><a href="#JavaScript-函数定义-2" class="headerlink" title="JavaScript 函数定义"></a>JavaScript 函数定义</h2><p>JavaScript 使用关键字 function 定义函数<br>函数可以通过声明定义，也可以是一个表达式</p>
<h3 id="函数声明-2"><a href="#函数声明-2" class="headerlink" title="函数声明"></a>函数声明</h3><p>函数声明后不会立即执行，会在我们需要的时候调用到</p>
<pre><code class="js">function functionName(parameters) {执行的代码}

function myFunction(a, b) {return a * b;}
</code></pre>
<h3 id="函数表达式-2"><a href="#函数表达式-2" class="headerlink" title="函数表达式"></a>函数表达式</h3><p>JavaScript 函数可以通过一个表达式定义<br>函数表达式可以存储在变量中</p>
<pre><code class="JavaScript">var x = function (a, b) {return a * b};

在函数表达式存储在变量后，变量也可作为一个函数使用：
var x = function (a, b) {return a * b};
var z = x(4, 3);

实际上，以上函数实际上是一个 匿名函数 (函数没有名称)
函数存储在变量中，不需要函数名称，通常通过变量名来调用
上述函数以分号结尾，因为它是一个执行语句
</code></pre>
<h3 id="Function-构造函数-2"><a href="#Function-构造函数-2" class="headerlink" title="Function() 构造函数"></a>Function() 构造函数</h3><p>函数通过关键字 function 定义<br>函数同样可以通过内置的 JavaScript 函数构造器（Function()）定义</p>
<pre><code class="JavaScript">var myFunction = new Function(&quot;a&quot;, &quot;b&quot;, &quot;return a * b&quot;);
var x = myFunction(4, 3);

// 等同于
var myFunction = function (a, b) {return a * b};
var x = myFunction(4, 3);
</code></pre>
<h3 id="函数提升-2"><a href="#函数提升-2" class="headerlink" title="函数提升"></a>函数提升</h3><p>提升（Hoisting）是 JavaScript 默认将当前作用域提升到前面去的的行为<br>提升（Hoisting）应用在变量的声明与函数的声明<br>因此，函数可以在声明之前调用：</p>
<pre><code class="JavaScript">myFunction(5);
function myFunction(y) {return y * y;}
使用表达式定义函数时无法提升
</code></pre>
<h3 id="自调用函数-2"><a href="#自调用函数-2" class="headerlink" title="自调用函数"></a>自调用函数</h3><p>函数表达式可以 “自调用”<br>自调用表达式会自动调用<br>如果表达式后面紧跟 () ，则会自动调用<br>不能自调用声明的函数<br>通过添加括号，来说明它是一个函数表达式：</p>
<pre><code class="JavaScript">(function () {var x = &quot;Hello!!&quot;;      // 我将调用自己})();
</code></pre>
<h3 id="函数可以作为一个值使用-2"><a href="#函数可以作为一个值使用-2" class="headerlink" title="函数可以作为一个值使用"></a>函数可以作为一个值使用</h3><p>JavaScript 函数作为一个值使用：</p>
<pre><code class="JavaScript">function myFunction(a, b) {return a * b;}

var x = myFunction(4, 3);
</code></pre>
<p>JavaScript 函数可作为表达式使用：</p>
<pre><code class="JavaScript">function myFunction(a, b) {return a * b;}

var x = myFunction(4, 3) * 2;
</code></pre>
<h3 id="函数是对象-2"><a href="#函数是对象-2" class="headerlink" title="函数是对象"></a>函数是对象</h3><p>在 JavaScript 中使用 typeof 操作符判断函数类型将返回 “function”<br>但是 JavaScript 函数描述为一个对象更加准确<br>JavaScript 函数有 属性 和 方法<br>arguments.length 属性返回函数调用过程接收到的参数个数</p>
<pre><code class="JavaScript">function myFunction(a, b) {return arguments.length;}
</code></pre>
<p>toString() 方法将函数作为一个字符串返回：</p>
<pre><code class="JavaScript">function myFunction(a, b) {return a * b;} 
var txt = myFunction.toString();

// 函数定义作为对象的属性，称之为对象方法
// 函数如果用于创建新的对象，称之为对象的构造函数
</code></pre>
<h3 id="箭头函数-2"><a href="#箭头函数-2" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>ES6 新增<br>箭头函数表达式的语法比普通函数表达式更简洁</p>
<pre><code class="JavaScript">(参数 1, 参数 2, …, 参数 N) =&gt; {函数声明}
(参数 1, 参数 2, …, 参数 N) =&gt; 表达式 (单一)
// 相当于：(参数 1, 参数 2, …, 参数 N) =&gt;{return 表达式;}

(单一参数) =&gt; {函数声明}
单一参数 =&gt; {函数声明}
// 只有一个参数

()=&gt; { 函数声明}
// 无参数

// ES5
var x = function(x, y) {return x * y;}
// ES6
const x = (x, y) =&gt; x * y;
</code></pre>
<p>有的箭头函数都没有自己的 this，不适合顶一个对象的方法<br>当我们使用箭头函数的时候，箭头函数会默认帮我们绑定外层 this 的值，所以在箭头函数中 this 的值和外层的 this 是一样的<br>箭头函数是不能提升的，所以需要在使用之前定义<br>使用 const 比使用 var 更安全，因为函数表达式始终是一个常量<br>如果函数部分只是一个语句，则可以省略 return 关键字和大括号 {}，这样做是一个比较好的习惯</p>
<pre><code class="JavaScript">const x = (x, y) =&gt; x * y;
// 等同于
const x = (x, y) =&gt; {return x * y};
</code></pre>
<hr>
<h2 id="JavaScript-函数参数-2"><a href="#JavaScript-函数参数-2" class="headerlink" title="JavaScript 函数参数"></a>JavaScript 函数参数</h2><p>JavaScript 函数对参数的值没有进行任何的检查</p>
<h3 id="函数显式参数-Parameters-与隐式参数-Arguments-2"><a href="#函数显式参数-Parameters-与隐式参数-Arguments-2" class="headerlink" title="函数显式参数 (Parameters) 与隐式参数 (Arguments)"></a>函数显式参数 (Parameters) 与隐式参数 (Arguments)</h3><p>函数显式参数在函数定义时列出<br>函数隐式参数在函数调用时传递给函数真正的值</p>
<pre><code class="JavaScript">functionName(parameter1, parameter2, parameter3) {// 要执行的代码……}
</code></pre>
<h3 id="参数规则-2"><a href="#参数规则-2" class="headerlink" title="参数规则"></a>参数规则</h3><p>JavaScript 函数定义显式参数时没有指定数据类型<br>JavaScript 函数对隐式参数没有进行类型检测<br>JavaScript 函数对隐式参数的个数没有进行检测</p>
<h3 id="默认参数-2"><a href="#默认参数-2" class="headerlink" title="默认参数"></a>默认参数</h3><p>如果函数在调用时未提供隐式参数，参数会默认设置为： undefined<br>ES6 支持函数带有默认参数，就判断 undefined 和 || 的操作</p>
<pre><code class="JavaScript">function myFunction(x, y = 10) {
    // y is 10 if not passed or undefined
    return x + y;
}

myFunction(0, 2) // 输出 2
myFunction(5); // 输出 15, y 参数的默认值
</code></pre>
<h3 id="arguments-对象-2"><a href="#arguments-对象-2" class="headerlink" title="arguments 对象"></a>arguments 对象</h3><p>JavaScript 函数有个内置的对象 arguments 对象<br>argument 对象包含了函数调用的参数数组<br>通过这种方式可以很方便的找到最大的一个参数的值</p>
<pre><code class="JavaScript">x = findMax(1, 123, 500, 115, 44, 88);

function findMax(){var i, max = arguments[0];

    if(arguments.length &lt; 2) return max;

    for (i = 0; i &lt; arguments.length; i++) {if (arguments[i] &gt; max){max = arguments[i];
        }
    }
    return max;
}
</code></pre>
<p>或者创建一个函数用来统计所有数值的和：</p>
<pre><code class="JavaScript">x = sumAll(1, 123, 500, 115, 44, 88);

function sumAll() {
    var i, sum = 0;
    for (i = 0; i &lt; arguments.length; i++) {sum += arguments[i];
    }
    return sum;
}
</code></pre>
<h3 id="通过值传递参数-2"><a href="#通过值传递参数-2" class="headerlink" title="通过值传递参数"></a>通过值传递参数</h3><p>在函数中调用的参数是函数的隐式参数<br>JavaScript 隐式参数通过值来传递：函数仅仅只是获取值<br>如果函数修改参数的值，不会修改显式参数的初始值（在函数外定义）<br>隐式参数的改变在函数外是不可见的</p>
<h3 id="通过对象传递参数-2"><a href="#通过对象传递参数-2" class="headerlink" title="通过对象传递参数"></a>通过对象传递参数</h3><p>在 JavaScript 中，可以引用对象的值<br>因此我们在函数内部修改对象的属性就会修改其初始的值<br>修改对象属性可作用于函数外部（全局变量）<br>修改对象属性在函数外是可见的</p>
<hr>
<h2 id="JavaScript-函数调用-2"><a href="#JavaScript-函数调用-2" class="headerlink" title="JavaScript 函数调用"></a>JavaScript 函数调用</h2><p>JavaScript 函数有 4 种调用方式<br>每种方式的不同在于 this 的初始化</p>
<h3 id="this-关键字-2"><a href="#this-关键字-2" class="headerlink" title="this 关键字"></a>this 关键字</h3><p>一般而言，在 JavaScript 中，this 指向函数执行时的当前对象</p>
<h3 id="调用-JavaScript-函数-2"><a href="#调用-JavaScript-函数-2" class="headerlink" title="调用 JavaScript 函数"></a>调用 JavaScript 函数</h3><p>函数中的代码在函数被调用后执行</p>
<h3 id="作为一个函数调用-2"><a href="#作为一个函数调用-2" class="headerlink" title="作为一个函数调用 "></a>作为一个函数调用 </h3><pre><code class="JavaScript">function myFunction(a, b) {return a * b;}
myFunction(10, 2);           // myFunction(10, 2) 返回 20
</code></pre>
<p>以上函数不属于任何对象。但是在 JavaScript 中它始终是默认的全局对象<br>在 HTML 中默认的全局对象是 HTML 页面本身，所以函数是属于 HTML 页面<br>在浏览器中的页面对象是浏览器窗口 (window 对象)。以上函数会自动变为 window 对象的函数<br>myFunction()和 window.myFunction() 是一样的：</p>
<pre><code class="JavaScript">function myFunction(a, b) {return a * b;}
window.myFunction(10, 2);    // window.myFunction(10, 2) 返回 20
</code></pre>
<h3 id="全局对象-2"><a href="#全局对象-2" class="headerlink" title="全局对象"></a>全局对象</h3><p>当函数没有被自身的对象调用时 this 的值就会变成全局对象<br>在 web 浏览器中全局对象是浏览器窗口（window 对象）<br>该实例返回 this 的值是 window 对象：</p>
<pre><code class="JavaScript">function myFunction(){return this;}
myFunction();                // 返回 window 对象
// 函数作为全局对象调用，会使 this 的值成为全局对象
// 使用 window 对象作为一个变量容易造成程序崩溃
</code></pre>
<h3 id="函数作为方法调用-2"><a href="#函数作为方法调用-2" class="headerlink" title="函数作为方法调用"></a>函数作为方法调用</h3><p>在 JavaScript 中你可以将函数定义为对象的方法<br>以下实例创建了一个对象 (myObject), 对象有两个属性 (firstName 和 lastName), 及一个方法 (fullName)：</p>
<pre><code class="JavaScript">var myObject = {
    firstName:&quot;John&quot;,
    lastName: &quot;Doe&quot;,
    fullName: function (){return this.firstName + &quot; &quot; + this.lastName;}
}
myObject.fullName();         // 返回 &quot;John Doe&quot;
</code></pre>
<p>fullName 方法是一个函数，函数属于对象，myObject 是函数的所有者<br>this 对象，拥有 JavaScript 代码，实例中 this 的值为 myObject 对象<br>测试以下！修改 fullName 方法并返回 this 值：</p>
<pre><code class="JavaScript">var myObject = {
    firstName:&quot;John&quot;,
    lastName: &quot;Doe&quot;,
    fullName: function (){return this;}
}
myObject.fullName();          // 返回 [object Object] (所有者对象)
// 函数作为对象方法调用，会使得 this 的值成为对象本身
</code></pre>
<h3 id="使用构造函数调用函数-2"><a href="#使用构造函数调用函数-2" class="headerlink" title="使用构造函数调用函数"></a>使用构造函数调用函数</h3><p>如果函数调用前使用了 new 关键字, 则是调用了构造函数<br>这看起来就像创建了新的函数，但实际上 JavaScript 函数是重新创建的对象：</p>
<pre><code class="JavaScript">// 构造函数:
function myFunction(arg1, arg2) {
    this.firstName = arg1;
    this.lastName  = arg2;
}

// This    creates a new object
var x = new myFunction(&quot;John&quot;,&quot;Doe&quot;);
x.firstName;                             // 返回 &quot;John&quot;
// 构造函数的调用会创建一个新的对象。新对象会继承构造函数的属性和方法
// 构造函数中 this 关键字没有任何的值
//this 的值在函数调用实例化对象 (new object) 时创建
</code></pre>
<h3 id="作为函数方法调用函数-2"><a href="#作为函数方法调用函数-2" class="headerlink" title="作为函数方法调用函数"></a>作为函数方法调用函数</h3><p>在 JavaScript 中，函数是对象，JavaScript 函数有它的属性和方法<br>call()和 apply() 是预定义的函数方法，两个方法可用于调用函数，两个方法的第一个参数必须是对象本身</p>
<pre><code class="JavaScript">function myFunction(a, b) {return a * b;}
myObject = myFunction.call(myObject, 10, 2);     // 返回 20

function myFunction(a, b) {return a * b;}
myArray = [10, 2];
myObject = myFunction.apply(myObject, myArray);  // 返回 20
</code></pre>
<p>两个方法都使用了对象本身作为第一个参数，两者的区别在于第二个参数： apply 传入的是一个参数数组，也就是将多个参数组合成为一个数组传入，而 call 则作为 call 的参数传入（从第二个参数开始）<br>在 JavaScript 严格模式 (strict mode) 下, 在调用函数时第一个参数会成为 this 的值， 即使该参数不是一个对象<br>在 JavaScript 非严格模式 (non-strict mode) 下, 如果第一个参数的值是 null 或 undefined, 它将使用全局对象替代<br>通过 call()或 apply() 方法你可以设置 this 的值, 且作为已存在对象的新方法调用</p>
<hr>
<h2 id="JavaScript-闭包-4"><a href="#JavaScript-闭包-4" class="headerlink" title="JavaScript 闭包"></a>JavaScript 闭包</h2><p>JavaScript 变量可以是局部变量或全局变量<br>私有变量可以用到闭包</p>
<h3 id="全局变量-8"><a href="#全局变量-8" class="headerlink" title="全局变量"></a>全局变量</h3><p>函数可以访问由函数内部定义的变量</p>
<pre><code class="JavaScript">function myFunction() {
    var a = 4;
    return a * a;
}
</code></pre>
<p>函数也可以访问函数外部定义的变量</p>
<pre><code class="JavaScript">var a = 4;
function myFunction(){return a * a;}
</code></pre>
<p>后面一个实例中， a 是一个 全局 变量<br>在 web 页面中全局变量属于 window 对象<br>全局变量可应用于页面上的所有脚本<br>在第一个实例中， a 是一个 局部 变量<br>局部变量只能用于定义它函数内部，对于其他的函数或脚本代码是不可用的<br>全局和局部变量即便名称相同，它们也是两个不同的变量，修改其中一个，不会影响另一个的值<br>变量声明时如果不使用 var 关键字，那么它就是一个全局变量，即便它在函数内定义</p>
<h3 id="计数器困境-2"><a href="#计数器困境-2" class="headerlink" title="计数器困境"></a>计数器困境</h3><p>可以使用全局变量，函数设置计数器递增</p>
<pre><code class="JavaScript">var counter = 0;

function add(){return counter += 1;}

add();
add();
add();

// 计数器现在为 3
</code></pre>
<p>计数器数值在执行 add() 函数时发生变化<br>但问题来了，页面上的任何脚本都能改变计数器，即便没有调用 add() 函数<br>如果我在函数内声明计数器，如果没有调用函数将无法修改计数器的值：</p>
<pre><code class="JavaScript">function add() {
    var counter = 0;
    return counter += 1;
}

add();
add();
add();

// 本意是想输出 3, 但事与愿违，输出的都是 1 !
</code></pre>
<h3 id="JavaScript-内嵌函数-2"><a href="#JavaScript-内嵌函数-2" class="headerlink" title="JavaScript 内嵌函数"></a>JavaScript 内嵌函数</h3><p>所有函数都能访问全局变量<br>实际上，在 JavaScript 中，所有函数都能访问它们上一层的作用域<br>JavaScript 支持嵌套函数，嵌套函数可以访问上一层的函数变量<br>该实例中，内嵌函数 plus() 可以访问父函数的 counter 变量：</p>
<pre><code class="JavaScript">function add() {
    var counter = 0;
    function plus(){counter += 1;}
    plus();   
    return counter;
}
</code></pre>
<p>如果我们能在外部访问 plus() 函数，这样就能解决计数器的困境<br>我们同样需要确保 counter = 0 只执行一次<br>我们需要闭包</p>
<h3 id="JavaScript-闭包-5"><a href="#JavaScript-闭包-5" class="headerlink" title="JavaScript 闭包"></a>JavaScript 闭包</h3><p>自我调用</p>
<pre><code class="JavaScript">var add = (function () {
    var counter = 0;
    return function (){return counter += 1;}
})();

add();
add();
add();

// 计数器为 3
</code></pre>
<h3 id="实例解析-2"><a href="#实例解析-2" class="headerlink" title="实例解析"></a>实例解析</h3><p>变量 add 指定了函数自我调用的返回字值<br>自我调用函数只执行一次，设置计数器为 0，并返回函数表达式<br>add 变量可以作为一个函数使用，非常棒的部分是它可以访问函数上一层作用域的计数器<br>这个叫作 JavaScript 闭包，它使得函数拥有私有变量变成可能<br>计数器受匿名函数的作用域保护，只能通过 add 方法修改<br>闭包是一种保护私有变量的机制，在函数执行时形成私有的作用域，保护里面的私有变量不受外界干扰<br>直观的说就是形成一个不销毁的栈环境</p>
<hr>
<h1 id="JS-DOM-2"><a href="#JS-DOM-2" class="headerlink" title="JS DOM"></a>JS DOM</h1><h2 id="JavaScript-HTML-DOM-简介-2"><a href="#JavaScript-HTML-DOM-简介-2" class="headerlink" title="JavaScript HTML DOM 简介"></a>JavaScript HTML DOM 简介</h2><p>通过 HTML DOM，可访问 JavaScript HTML 文档的所有元素</p>
<h3 id="HTML-DOM（文档对象模型）-2"><a href="#HTML-DOM（文档对象模型）-2" class="headerlink" title="HTML DOM（文档对象模型）"></a>HTML DOM（文档对象模型）</h3><p>当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）<br>HTML DOM 模型被构造为对象的树：<br><img src="media/15859150613859/15861362970794.jpg" alt="-w517">通过可编程的对象模型，JavaScript 获得了足够的能力来创建动态的 HTML</p>
<ul>
<li>JavaScript 能够改变页面中的所有 HTML 元素</li>
<li>JavaScript 能够改变页面中的所有 HTML 属性</li>
<li>JavaScript 能够改变页面中的所有 CSS 样式</li>
<li>JavaScript 能够对页面中的所有事件作出反应</li>
</ul>
<h3 id="查找-HTML-元素-2"><a href="#查找-HTML-元素-2" class="headerlink" title="查找 HTML 元素"></a>查找 HTML 元素</h3><p>通常通过 JavaScript，操作 HTML 元素<br>必须首先找到元素</p>
<ul>
<li>通过 id getElementById</li>
<li>通过标签名 getElementByTagName</li>
<li>通过类名 getElementByClassName</li>
</ul>
<h3 id="通过-id-查找-HTML-元素-2"><a href="#通过-id-查找-HTML-元素-2" class="headerlink" title="通过 id 查找 HTML 元素"></a>通过 id 查找 HTML 元素</h3><p>在 DOM 中查找 HTML 元素的最简单的方法，是通过使用元素的 id</p>
<pre><code class="JavaScript">var x=document.getElementById(&quot;intro&quot;);
</code></pre>
<p>如果找到该元素，则该方法将以对象（在 x 中）的形式返回该元素<br>如果未找到该元素，则 x 将包含 null</p>
<h3 id="通过标签名查找-HTML-元素-2"><a href="#通过标签名查找-HTML-元素-2" class="headerlink" title="通过标签名查找 HTML 元素"></a>通过标签名查找 HTML 元素</h3><p>本例查找 id=”main” 的元素，然后查找 id=”main” 元素中的所有 </p><p> 元素：</p>
<pre><code class="JavaScript">var x=document.getElementById(&quot;main&quot;);
var y=x.getElementsByTagName(&quot;p&quot;);
</code></pre>
<h3 id="通过类名找到-HTML-元素-2"><a href="#通过类名找到-HTML-元素-2" class="headerlink" title="通过类名找到 HTML 元素"></a>通过类名找到 HTML 元素</h3><p>本例通过 getElementsByClassName 函数来查找 class=”intro” 的元素：</p>
<pre><code class="JavaScript">var x=document.getElementsByClassName(&quot;intro&quot;);
</code></pre>
<hr>
<h2 id="JavaScript-HTML-DOM-改变-HTML-2"><a href="#JavaScript-HTML-DOM-改变-HTML-2" class="headerlink" title="JavaScript HTML DOM - 改变 HTML"></a>JavaScript HTML DOM - 改变 HTML</h2><p>HTML DOM 允许 JavaScript 改变 HTML 元素的内容</p>
<h3 id="改变-HTML-输出流-2"><a href="#改变-HTML-输出流-2" class="headerlink" title="改变 HTML 输出流"></a>改变 HTML 输出流</h3><p>JavaScript 能够创建动态的 HTML 内容<br>在 JavaScript 中，<code>document.write()</code> 可用于直接向 HTML 输出流写内容</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;

&lt;script&gt;
document.write(Date());
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>绝对不要在文档 (DOM) 加载完成之后使用 document.write()，这会覆盖该文档</p>
<h3 id="改变-HTML-内容-2"><a href="#改变-HTML-内容-2" class="headerlink" title="改变 HTML 内容"></a>改变 HTML 内容</h3><p>修改 HTML 内容的最简单的方法是使用 <code>innerHTML</code> 属性</p>
<pre><code class="JavaScript">document.getElementById(id).innerHTML= 新的 HTML
</code></pre>
<pre><code class="html">&lt;html&gt;
&lt;body&gt;

&lt;p id=&quot;p1&quot;&gt;Hello World!&lt;/p&gt;

&lt;script&gt;
document.getElementById(&quot;p1&quot;).innerHTML=&quot;新文本!&quot;;
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;

&lt;h1 id=&quot;header&quot;&gt;Old Header&lt;/h1&gt;

&lt;script&gt;
var element=document.getElementById(&quot;header&quot;);
element.innerHTML=&quot;新标题&quot;;
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="改变-HTML-属性-2"><a href="#改变-HTML-属性-2" class="headerlink" title="改变 HTML 属性"></a>改变 HTML 属性</h3><p>语法</p>
<pre><code class="JavaScript">document.getElementById(id).attribute= 新属性值
</code></pre>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;

&lt;img id=&quot;image&quot; src=&quot;smiley.gif&quot;&gt;

&lt;script&gt;
document.getElementById(&quot;image&quot;).src=&quot;landscape.jpg&quot;;
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<hr>
<h2 id="JavaScript-HTML-DOM-改变-CSS-2"><a href="#JavaScript-HTML-DOM-改变-CSS-2" class="headerlink" title="JavaScript HTML DOM - 改变 CSS"></a>JavaScript HTML DOM - 改变 CSS</h2><p>HTML DOM 允许 JavaScript 改变 HTML 元素的样式</p>
<h3 id="改变-HTML-样式-2"><a href="#改变-HTML-样式-2" class="headerlink" title="改变 HTML 样式"></a>改变 HTML 样式</h3><p>语法</p>
<pre><code class="JavaScript">document.getElementById(id).style.property= 新样式
</code></pre>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt; 牛客教程 (nowcoder.com)&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;p id=&quot;p1&quot;&gt;Hello World!&lt;/p&gt;
    &lt;p id=&quot;p2&quot;&gt;Hello World!&lt;/p&gt;
    &lt;script&gt;
        document.getElementById(&quot;p2&quot;).style.color=&quot;blue&quot;;
        document.getElementById(&quot;p2&quot;).style.fontFamily=&quot;Arial&quot;;
        document.getElementById(&quot;p2&quot;).style.fontSize=&quot;larger&quot;;
    &lt;/script&gt;
    &lt;p&gt; 以上段落通过脚本修改。&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="使用事件-2"><a href="#使用事件-2" class="headerlink" title="使用事件"></a>使用事件</h3><p>HTML DOM 允许我们通过触发事件来执行代码</p>
<ul>
<li>元素被点击</li>
<li>页面加载完成</li>
<li>输入框被修改</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;

&lt;h1 id=&quot;id1&quot;&gt; 我的标题 1&lt;/h1&gt;
&lt;button type=&quot;button&quot;
onclick=&quot;document.getElementById(&#39;id1&#39;).style.color=&#39;red&#39;&quot;&gt;
点我!&lt;/button&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<hr>
<h2 id="JavaScript-HTML-DOM-事件-2"><a href="#JavaScript-HTML-DOM-事件-2" class="headerlink" title="JavaScript HTML DOM 事件"></a>JavaScript HTML DOM 事件</h2><p>HTML DOM 使 JavaScript 有能力对 HTML 事件做出反应</p>
<h3 id="对事件做出反应-2"><a href="#对事件做出反应-2" class="headerlink" title="对事件做出反应"></a>对事件做出反应</h3><p>我们可以在事件发生时执行 JavaScript，比如当用户在 HTML 元素上点击时<br>如需在用户点击某个元素时执行代码，请向一个 HTML 事件属性添加 JavaScript 代码：<br><code>onclick = JavaScript</code><br>HTML 事件的例子：</p>
<ul>
<li>当用户点击鼠标</li>
<li>当网页已加载</li>
<li>当图像已加载</li>
<li>当鼠标移动到元素上</li>
<li>当输入字段被改变</li>
<li>当提交 HTML 表单</li>
<li>当用户触发按键</li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
&lt;h1 onclick=&quot;this.innerHTML=&#39;Ooops!&#39;&quot;&gt; 点击文本!&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;script&gt;
function changetext(id) {id.innerHTML=&quot;Ooops!&quot;;}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1 onclick=&quot;changetext(this)&quot;&gt; 点击文本!&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="HTML-事件属性-2"><a href="#HTML-事件属性-2" class="headerlink" title="HTML 事件属性"></a>HTML 事件属性</h3><p>如需向 HTML 元素分配事件，可以使用事件属性</p>
<pre><code class="html">&lt;button onclick=&quot;displayDate()&quot;&gt; 点这里 &lt;/button&gt;
// 在上面的例子中，名为 displayDate 的函数将在按钮被点击时执行
</code></pre>
<h3 id="使用-HTML-DOM-来分配事件-2"><a href="#使用-HTML-DOM-来分配事件-2" class="headerlink" title="使用 HTML DOM 来分配事件"></a>使用 HTML DOM 来分配事件</h3><p>HTML DOM 允许使用 JavaScript 来向 HTML 元素分配事件</p>
<pre><code class="html">&lt;script&gt;
    document.getElementById(&quot;myBtn&quot;).onclick=function(){displayDate()};
&lt;/script&gt;
// 在上面的例子中，名为 displayDate 的函数被分配给 id=&quot;myBtn&quot; 的 HTML 元素
按钮点击时 Javascript 函数将会被执行
</code></pre>
<h3 id="onload-和-onunload-事件-2"><a href="#onload-和-onunload-事件-2" class="headerlink" title="onload 和 onunload 事件"></a>onload 和 onunload 事件</h3><p>onload 和 onunload 事件会在用户进入或离开页面时被触发<br>onload 事件可用于检测访问者的浏览器类型和浏览器版本，并基于这些信息来加载网页的正确版本<br>onload 和 onunload 事件可用于处理 cookie</p>
<pre><code class="html">&lt;body onload = &quot;checkCookies()&quot;
</code></pre>
<h3 id="onchange-事件-2"><a href="#onchange-事件-2" class="headerlink" title="onchange 事件"></a>onchange 事件</h3><p>onchange 事件常结合对输入字段的验证来使用<br>下面是一个如何使用 onchange 的例子，当用户改变输入字段的内容时，会调用 upperCae() 函数</p>
<pre><code class="html">&lt;input type = &quot;text&quot; id = &quot;fname&quot; onchange = &quot;upperCase()&quot;&gt;
</code></pre>
<h3 id="onmouseover-和-onmouseout-事件-2"><a href="#onmouseover-和-onmouseout-事件-2" class="headerlink" title="onmouseover 和 onmouseout 事件"></a>onmouseover 和 onmouseout 事件</h3><p>onmouseover 和 onmouseout 事件可用于在用户的鼠标移动至 HTMl 元素上方或者移动出元素时触发函数</p>
<pre><code class="html">&lt;div onmouseover = &quot;mOver(this)&quot; onmouseout = &quot;mOut(this)&quot;&gt;Mouse Over Me&lt;/div&gt;
</code></pre>
<h3 id="onmousedown、onmouseup-以及-onclick-事件-2"><a href="#onmousedown、onmouseup-以及-onclick-事件-2" class="headerlink" title="onmousedown、onmouseup 以及 onclick 事件"></a>onmousedown、onmouseup 以及 onclick 事件</h3><p>onmousedownm，onmouseup 以及 onclick 构成了鼠标点击事件的所有部分，首先当点击鼠标摁钮时，会触发 onmousedown 事件，当释放鼠标摁钮时，会触发 onmouseup 事件，最后，当完成鼠标点击时，会触发 onclick 事件</p>
<hr>
<h2 id="JavaScript-HTML-DOM-EventListener-2"><a href="#JavaScript-HTML-DOM-EventListener-2" class="headerlink" title="JavaScript HTML DOM EventListener"></a>JavaScript HTML DOM EventListener</h2><h3 id="addEventListener-方法-2"><a href="#addEventListener-方法-2" class="headerlink" title="addEventListener() 方法"></a>addEventListener() 方法</h3><p>在用户点击按钮时触发监听事件：</p>
<pre><code class="JavaScript">document.getElementById(&quot;myBtn&quot;).addEventListener(&quot;click&quot;, displayDate);
</code></pre>
<p>addEventListener() 方法用于向指定元素添加事件句柄<br>addEventListener() 方法添加的事件句柄不会覆盖已存在的事件句柄<br>你可以向一个元素添加多个事件句柄<br>你可以向同个元素添加多个同类型的事件句柄，如：两个 “click” 事件<br>你可以向任何 DOM 对象添加事件监听，不仅仅是 HTML 元素。如： window 对象<br>addEventListener() 方法可以更简单的控制事件（冒泡与捕获）<br>当你使用 addEventListener() 方法时, JavaScript 从 HTML 标记中分离开来，可读性更强， 在没有控制 HTML 标记时也可以添加事件监听<br>你可以使用 removeEventListener() 方法来移除事件的监听</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code class="JavaScript">element.addEventListener(event, function, useCapture);
</code></pre>
<p>第一个参数是事件的类型 (如 “click” 或 “mousedown”)<br>第二个参数是事件触发后调用的函数<br>第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的<br>注意: 不要使用 “on” 前缀。 例如，使用 “click” , 而不是使用 “onclick”</p>
<h3 id="向原元素添加事件句柄"><a href="#向原元素添加事件句柄" class="headerlink" title="向原元素添加事件句柄"></a>向原元素添加事件句柄</h3><p>当用户点击元素时弹出“Hello World!”</p>
<pre><code class="JavaScript">element.addEventListener(&quot;click&quot;, function(){alert(&quot;Hello World!&quot;); });
// 或
element.addEventListener(&quot;click&quot;, myFunction);
function myFunction(){alert (&quot;Hello World!&quot;);
}
</code></pre>
<h3 id="向同一个元素中添加多个事件句柄"><a href="#向同一个元素中添加多个事件句柄" class="headerlink" title="向同一个元素中添加多个事件句柄"></a>向同一个元素中添加多个事件句柄</h3><p>addEventListener() 方法允许向同一个元素添加多个事件，且不会覆盖已存在的事件：</p>
<pre><code class="JavaScript">element.addEventListener(&quot;click&quot;, myFunction);
element.addEventListener(&quot;click&quot;, mySecondFunction);
// 可以向同个元素添加不同类型的事件
element.addEventListener(&quot;mouseover&quot;, myFunction);
element.addEventListener(&quot;click&quot;, mySecondFunction);
element.addEventListener(&quot;mouseout&quot;, myThirdFunction);
</code></pre>
<h3 id="向-Window-对象添加事件句柄"><a href="#向-Window-对象添加事件句柄" class="headerlink" title="向 Window 对象添加事件句柄"></a>向 Window 对象添加事件句柄</h3><p>addEventListener() 方法允许你在 HTML DOM 对象添加事件监听， HTML DOM 对象如： HTML 元素, HTML 文档, window 对象。或者其他支出的事件对象如: xmlHttpRequest 对象</p>
<pre><code class="JavaScript">window.addEventListener(&quot;resize&quot;, function(){document.getElementById(&quot;demo&quot;).innerHTML = sometext;
});
</code></pre>
<h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>当传递参数值时，使用“匿名函数”调用带参数的函数</p>
<pre><code class="JavaScript">element.addEventListener(&quot;click&quot;, function(){myFunction(p1, p2); });
</code></pre>
<h3 id="事件冒泡或事件捕获"><a href="#事件冒泡或事件捕获" class="headerlink" title="事件冒泡或事件捕获"></a>事件冒泡或事件捕获</h3><p>事件传递有两种方式：冒泡与捕获<br>事件传递定义了元素事件触发的顺序。 如果你将 <code>&lt;p&gt;</code> 元素插入到 <code>&lt;div&gt;</code> 元素中，用户点击 <code>&lt;p&gt;</code> 元素, 哪个元素的 “click” 事件先被触发呢<br>在 冒泡 中，内部元素的事件会先被触发，然后再触发外部元素，即： <code>&lt;p&gt;</code> 元素的点击事件先触发，然后会触发 <code>&lt;div&gt;</code> 元素的点击事件<br>在 捕获 中，外部元素的事件会先被触发，然后才会触发内部元素的事件，即：<code>&lt;div&gt;</code> 元素的点击事件先触发 ，然后再触发 <code>&lt;p&gt;</code> 元素的点击事件<br>addEventListener() 方法可以指定 “useCapture” 参数来设置传递类型：</p>
<pre><code class="JavaScript">addEventListener(event, function, useCapture);
</code></pre>
<p>默认值为 false, 即冒泡传递，当值为 true 时, 事件使用捕获传递</p>
<pre><code class="JavaScript">document.getElementById(&quot;myDiv&quot;).addEventListener(&quot;click&quot;, myFunction, true);
</code></pre>
<h3 id="removeEventListener-方法"><a href="#removeEventListener-方法" class="headerlink" title="removeEventListener() 方法"></a>removeEventListener() 方法</h3><p>removeEventListener()方法移除由 addEventListener() 方法添加的事件句柄：</p>
<pre><code class="JavaScript">element.removeEventListener(&quot;mousemove&quot;, myFunction);
</code></pre>
<hr>
<h2 id="JavaScript-HTML-DOM-元素-节点"><a href="#JavaScript-HTML-DOM-元素-节点" class="headerlink" title="JavaScript HTML DOM 元素 (节点)"></a>JavaScript HTML DOM 元素 (节点)</h2><h3 id="创建新的-HTML-元素-节点-appendChild-要创建新的-HTML-元素-节点-需要先创建一个元素，然后在已存在的元素中添加它"><a href="#创建新的-HTML-元素-节点-appendChild-要创建新的-HTML-元素-节点-需要先创建一个元素，然后在已存在的元素中添加它" class="headerlink" title="创建新的 HTML 元素 (节点) - appendChild()要创建新的 HTML 元素 ( 节点) 需要先创建一个元素，然后在已存在的元素中添加它"></a>创建新的 HTML 元素 (节点) - appendChild()要创建新的 HTML 元素 ( 节点) 需要先创建一个元素，然后在已存在的元素中添加它</h3><pre><code class="html">&lt;div id=&quot;div1&quot;&gt;
&lt;p id=&quot;p1&quot;&gt; 这是一个段落。&lt;/p&gt;
&lt;p id=&quot;p2&quot;&gt; 这是另外一个段落。&lt;/p&gt;
&lt;/div&gt;

&lt;script&gt;
    var para = document.createElement(&quot;p&quot;);
    var node = document.createTextNode(&quot;这是一个新的段落。&quot;);
    para.appendChild(node);

    var element = document.getElementById(&quot;div1&quot;);
    element.appendChild(para);
&lt;/script&gt;
</code></pre>
<h3 id="创建新的-HTML-元素-节点-insertBefore-以上的实例我们使用了-appendChild-方法，它用于添加新元素到尾部"><a href="#创建新的-HTML-元素-节点-insertBefore-以上的实例我们使用了-appendChild-方法，它用于添加新元素到尾部" class="headerlink" title="创建新的 HTML 元素 (节点) - insertBefore()以上的实例我们使用了 appendChild() 方法，它用于添加新元素到尾部"></a>创建新的 HTML 元素 (节点) - insertBefore()以上的实例我们使用了 appendChild() 方法，它用于添加新元素到尾部</h3><p>如果我们需要将新元素添加到开始位置，可以使用 insertBefore() 方法：</p>
<pre><code class="html">&lt;div id=&quot;div1&quot;&gt;
&lt;p id=&quot;p1&quot;&gt; 这是一个段落。&lt;/p&gt;
&lt;p id=&quot;p2&quot;&gt; 这是另外一个段落。&lt;/p&gt;
&lt;/div&gt;

&lt;script&gt;
    var para = document.createElement(&quot;p&quot;);
    var node = document.createTextNode(&quot;这是一个新的段落。&quot;);
    para.appendChild(node);

    var element = document.getElementById(&quot;div1&quot;);
    var child = document.getElementById(&quot;p1&quot;);
    element.insertBefore(para, child);
&lt;/script&gt;
</code></pre>
<h3 id="移除已存在的元素"><a href="#移除已存在的元素" class="headerlink" title="移除已存在的元素"></a>移除已存在的元素</h3><p>要移除一个元素，你需要知道该元素的父元素</p>
<pre><code class="html">&lt;div id=&quot;div1&quot;&gt;
&lt;p id=&quot;p1&quot;&gt; 这是一个段落。&lt;/p&gt;
&lt;p id=&quot;p2&quot;&gt; 这是另外一个段落。&lt;/p&gt;
&lt;/div&gt;

&lt;script&gt;
    var parent = document.getElementById(&quot;div1&quot;);
    var child = document.getElementById(&quot;p1&quot;);
    parent.removeChild(child);
&lt;/script&gt;
</code></pre>
<h3 id="替换-HTML-元素-replaceChild-我们可以使用-replaceChild-方法来替换-HTML-DOM-中的元素"><a href="#替换-HTML-元素-replaceChild-我们可以使用-replaceChild-方法来替换-HTML-DOM-中的元素" class="headerlink" title="替换 HTML 元素 - replaceChild()我们可以使用 replaceChild() 方法来替换 HTML DOM 中的元素"></a>替换 HTML 元素 - replaceChild()我们可以使用 replaceChild() 方法来替换 HTML DOM 中的元素</h3><pre><code class="html">&lt;div id=&quot;div1&quot;&gt;
&lt;p id=&quot;p1&quot;&gt; 这是一个段落。&lt;/p&gt;
&lt;p id=&quot;p2&quot;&gt; 这是另外一个段落。&lt;/p&gt;
&lt;/div&gt;

&lt;script&gt;
    var para = document.createElement(&quot;p&quot;);
    var node = document.createTextNode(&quot;这是一个新的段落。&quot;);
    para.appendChild(node);

    var parent = document.getElementById(&quot;div1&quot;);
    var child = document.getElementById(&quot;p1&quot;);
    parent.replaceChild(para, child);
&lt;/script&gt;
</code></pre>
<hr>
<h2 id="JavaScript-HTML-DOM-集合-Collection"><a href="#JavaScript-HTML-DOM-集合-Collection" class="headerlink" title="JavaScript HTML DOM 集合 (Collection)"></a>JavaScript HTML DOM 集合 (Collection)</h2><h3 id="HTMLCollection-对象"><a href="#HTMLCollection-对象" class="headerlink" title="HTMLCollection 对象"></a>HTMLCollection 对象</h3><p>getElementsByTagName() 方法返回 HTMLCollection 对象<br>HTMLCollection 对象类似包含 HTML 元素的一个数组<br>以下代码获取文档所有的 <code>&lt;p&gt;</code> 元素：<br><code>var x = document.getElementsByTagName(&quot;p&quot;);</code><br>集合中的元素可以通过索引 (以 0 为起始位置) 来访问<br>访问第二个 <code>&lt;p&gt;</code> 元素可以是以下代码：<br><code>y = x[1];</code></p>
<h3 id="HTMLCollection-对象-length-属性"><a href="#HTMLCollection-对象-length-属性" class="headerlink" title="HTMLCollection 对象 length 属性"></a>HTMLCollection 对象 length 属性</h3><pre><code class="JavaScript">var myCollection = document.getElementsByTagName(&quot;p&quot;);
document.getElementById(&quot;demo&quot;).innerHTML = myCollection.length;
</code></pre>
<p>修改所有 <code>&lt;p&gt;</code> 元素的背景颜色</p>
<pre><code class="JavaScript">var myCollection = document.getElementsByTagName(&quot;p&quot;);
var i;
for (i = 0; i &lt; myCollection.length; i++) {myCollection[i].style.backgroundColor = &quot;red&quot;;
}
</code></pre>
<h3 id="JavaScript-HTML-DOM-节点列表"><a href="#JavaScript-HTML-DOM-节点列表" class="headerlink" title="JavaScript HTML DOM 节点列表"></a>JavaScript HTML DOM 节点列表</h3><p>NodeList 对象是一个从文档中获取的节点列表 (集合)<br>NodeList 对象类似 HTMLCollection 对象<br>一些旧版本浏览器中的方法（如：getElementsByClassName()）返回的是 NodeList 对象，而不是 HTMLCollection 对象<br>所有浏览器的 childNodes 属性返回的是 NodeList 对象<br>大部分浏览器的 querySelectorAll() 返回 NodeList 对象</p>
<h3 id="HTMLCollection-与-NodeList-的区别"><a href="#HTMLCollection-与-NodeList-的区别" class="headerlink" title="HTMLCollection 与 NodeList 的区别"></a>HTMLCollection 与 NodeList 的区别</h3><p>HTMLCollection 是 HTML 元素的集合<br>NodeList 是一个文档节点的集合<br>NodeList 与 HTMLCollection 有很多类似的地方<br>NodeList 与 HTMLCollection 都与数组对象有点类似，可以使用索引 (0, 1, 2, 3, 4, …) 来获取元素<br>NodeList 与 HTMLCollection 都有 length 属性<br>HTMLCollection 元素可以通过 name，id 或索引来获取<br>NodeList 只能通过索引来获取<br>只有 NodeList 对象有包含属性节点和文本节点</p>
<hr>
<h1 id="JS-高级教程"><a href="#JS-高级教程" class="headerlink" title="JS 高级教程"></a>JS 高级教程</h1><h2 id="JavaScript-对象-6"><a href="#JavaScript-对象-6" class="headerlink" title="JavaScript 对象"></a>JavaScript 对象</h2><p>JavaScript 中的所有事物都是对象：字符串、数值、数组、函数…<br>此外，JavaScript 允许自定义对象</p>
<h3 id="所有事物都是对象"><a href="#所有事物都是对象" class="headerlink" title="所有事物都是对象"></a>所有事物都是对象</h3><p>JavaScript 提供多个内建对象，比如 String、Date、Array 等等。 对象只是带有属性和方法的特殊数据类型</p>
<ul>
<li>布尔型可以是一个对象</li>
<li>数字型可以是一个对象</li>
<li>字符串也可以是一个对象</li>
<li>日期是一个对象</li>
<li>数学和正则表达式也是对象</li>
<li>数组是一个对象</li>
<li>甚至函数也可以是对象</li>
</ul>
<h3 id="JavaScript-对象-7"><a href="#JavaScript-对象-7" class="headerlink" title="JavaScript 对象"></a>JavaScript 对象</h3><p>对象只是一种特殊的数据。对象拥有属性和方法</p>
<h3 id="访问对象的属性"><a href="#访问对象的属性" class="headerlink" title="访问对象的属性"></a>访问对象的属性</h3><p>属性是与对象相关的值<br>访问对象属性的语法<br><code>objectName.propertyName</code><br>这个例子使用了 String 对象的 length 属性来获取字符串的长度</p>
<pre><code class="JavaScript">var message=&quot;Hello World!&quot;;
var x=message.length;
//12
</code></pre>
<h3 id="访问对象的方法"><a href="#访问对象的方法" class="headerlink" title="访问对象的方法"></a>访问对象的方法</h3><p>方法是能够在对象上执行的动作<br>语法<br><code>objectName.methodName()</code><br>这个例子使用了 String 对象的 toUpperCase() 方法来将文本转换为大写</p>
<pre><code class="JavaScript">var message=&quot;Hello world!&quot;;
var x=message.toUpperCase();
//HELLO WORLD!
</code></pre>
<h3 id="创建-JavaScript-对象"><a href="#创建-JavaScript-对象" class="headerlink" title="创建 JavaScript 对象"></a>创建 JavaScript 对象</h3><p>通过 JavaScript，您能够定义并创建自己的对象<br>创建新对象有两种不同的方法：</p>
<ul>
<li>定义并创建对象的实例</li>
<li>使用函数来定义对象，然后创建新的对象实例</li>
</ul>
<h3 id="创建直接的实例"><a href="#创建直接的实例" class="headerlink" title="创建直接的实例"></a>创建直接的实例</h3><p>这个例子创建了对象的一个新实例，并向其添加了四个属性：</p>
<pre><code class="JavaScript">person=new Object();
person.firstname=&quot;John&quot;;
person.lastname=&quot;Doe&quot;;
person.age=50;
person.eyecolor=&quot;blue&quot;;
</code></pre>
<h3 id="使用对象构造器"><a href="#使用对象构造器" class="headerlink" title="使用对象构造器"></a>使用对象构造器</h3><pre><code class="JavaScript">function person(firstname,lastname,age,eyecolor) {
    this.firstname=firstname;
    this.lastname=lastname;
    this.age=age;
    this.eyecolor=eyecolor;
}
</code></pre>
<h3 id="创建-JavaScript-对象实例"><a href="#创建-JavaScript-对象实例" class="headerlink" title="创建 JavaScript 对象实例"></a>创建 JavaScript 对象实例</h3><p>一旦您有了对象构造器，就可以创建新的对象实例，就像这样：</p>
<pre><code class="JavaScript">var myFather=new person(&quot;John&quot;,&quot;Doe&quot;,50,&quot;blue&quot;);
var myMother=new person(&quot;Sally&quot;,&quot;Rally&quot;,48,&quot;green&quot;);
</code></pre>
<h3 id="把属性添加到-JavaScript-对象"><a href="#把属性添加到-JavaScript-对象" class="headerlink" title="把属性添加到 JavaScript 对象"></a>把属性添加到 JavaScript 对象</h3><p>您可以通过为对象赋值，向已有对象添加新属性<br>假设 personObj 已存在 - 您可以为其添加这些新属性：firstname、lastname、age 以及 eyecolor</p>
<h3 id="把方法添加到-JavaScript-对象"><a href="#把方法添加到-JavaScript-对象" class="headerlink" title="把方法添加到 JavaScript 对象"></a>把方法添加到 JavaScript 对象</h3><p>方法只不过是附加在对象上的函数<br>在构造器函数内部定义对象的方法：</p>
<pre><code class="JavaScript">function person(firstname,lastname,age,eyecolor) {
    this.firstname=firstname;
    this.lastname=lastname;
    this.age=age;
    this.eyecolor=eyecolor;

    this.changeName=changeName;
    function changeName(name) {this.lastname=name;}
}
</code></pre>
<h3 id="JavaScript-类"><a href="#JavaScript-类" class="headerlink" title="JavaScript 类"></a>JavaScript 类</h3><p>JavaScript 是面向对象的语言，但 JavaScript 不使用类<br>在 JavaScript 中，不会创建类，也不会通过类来创建对象（就像在其他面向对象的语言中那样）<br>JavaScript 基于 prototype，而不是基于类的</p>
<hr>
<h2 id="JavaScript-prototype（原型对象）"><a href="#JavaScript-prototype（原型对象）" class="headerlink" title="JavaScript prototype（原型对象）"></a>JavaScript prototype（原型对象）</h2><p>所有的 JavaScript 对象都会从一个 prototype（原型对象）中继承属性和方法<br>在前面的章节中我们学会了如何使用对象的构造器（constructor）<br>要添加一个新的属性需要在在构造器函数中添加</p>
<pre><code class="JavaScript">function Person(first, last, age, eyecolor) {
  this.firstName = first;
  this.lastName = last;
  this.age = age;
  this.eyeColor = eyecolor;

  this.nationality = &quot;English&quot;;
}
</code></pre>
<h3 id="prototype-继承"><a href="#prototype-继承" class="headerlink" title="prototype 继承"></a>prototype 继承</h3><p>所有的 JavaScript 对象都会从一个 prototype（原型对象）中继承属性和方法：</p>
<ul>
<li>Date 对象从 Date.prototype 继承</li>
<li>Array 对象从 Array.prototype 继承</li>
<li>Person 对象从 Person.prototype 继承</li>
</ul>
<p>所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例<br>JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾<br>Date 对象, Array 对象, 以及 Person 对象从 Object.prototype 继承</p>
<p>有的时候我们想要在所有已经存在的对象添加新的属性或方法<br>另外，有时候我们想要在对象的构造函数中添加属性或方法<br>使用 prototype 属性就可以给对象的构造函数添加新的属性：</p>
<pre><code class="JavaScript">function Person(first, last, age, eyecolor) {
  this.firstName = first;
  this.lastName = last;
  this.age = age;
  this.eyeColor = eyecolor;
}

Person.prototype.nationality = &quot;English&quot;;
// 或
function Person(first, last, age, eyecolor) {
  this.firstName = first;
  this.lastName = last;
  this.age = age;
  this.eyeColor = eyecolor;
}

Person.prototype.name = function(){return this.firstName + &quot; &quot; + this.lastName;};
</code></pre>
<hr>
<h2 id="JavaScript-Number-对象"><a href="#JavaScript-Number-对象" class="headerlink" title="JavaScript Number 对象"></a>JavaScript Number 对象</h2><p>JavaScript 只有一种数字类型<br>可以使用也可以不使用小数点来书写数字</p>
<h3 id="JavaScript-数字"><a href="#JavaScript-数字" class="headerlink" title="JavaScript 数字"></a>JavaScript 数字</h3><pre><code class="JavaScript">var pi=3.14;    // 使用小数点
var x=34;       // 不使用小数点
var y=123e5;    // 12300000
var z=123e-5;   // 0.00123
</code></pre>
<h3 id="所有-JavaScript-数字均为-64-位"><a href="#所有-JavaScript-数字均为-64-位" class="headerlink" title="所有 JavaScript 数字均为 64 位"></a>所有 JavaScript 数字均为 64 位</h3><p>JavaScript 不是类型语言。与许多其他编程语言不同，JavaScript 不定义不同类型的数字，比如整数、短、长、浮点等等<br>在 JavaScript 中，数字不分为整数类型和浮点型类型，所有的数字都是由 浮点型类型。JavaScript 采用 IEEE754 标准定义的 64 位浮点格式表示数字，它能表示最大值为±1.7976931348623157 x 10308，最小值为±5 x 10 -324</p>
<h3 id="精度"><a href="#精度" class="headerlink" title="精度"></a>精度</h3><p>整数（不使用小数点或指数计数法）最多为 15 位</p>
<pre><code class="JavaScript">var x = 999999999999999;   // x 为 999999999999999
var y = 9999999999999999;  // y 为 10000000000000000
// 小数的最大位数是 17，但是浮点运算并不总是 100% 准确：
var x = 0.2+0.1; // 输出结果为 0.30000000000000004
</code></pre>
<h3 id="八进制和十六进制"><a href="#八进制和十六进制" class="headerlink" title="八进制和十六进制"></a>八进制和十六进制</h3><p>如果前缀为 0，则 JavaScript 会把数值常量解释为八进制数，如果前缀为 0 和 “x”，则解释为十六进制数<br>绝不要在数字前面写零，除非您需要进行八进制转换<br>默认情况下，JavaScript 数字为十进制显示<br>但是你可以使用 toString() 方法 输出 16 进制、8 进制、2 进制</p>
<pre><code class="JavaScript">var y = 0377;
var z = 0xFF;
var myNumber=128;
myNumber.toString(16);   // 返回 80
myNumber.toString(8);    // 返回 200
myNumber.toString(2);    // 返回 10000000
</code></pre>
<h3 id="无穷大（Infinity）"><a href="#无穷大（Infinity）" class="headerlink" title="无穷大（Infinity）"></a>无穷大（Infinity）</h3><p>当数字运算结果超过了 JavaScript 所能表示的数字上限（溢出），结果为一个特殊的无穷大（infinity）值，在 JavaScript 中以 Infinity 表示。同样地，当负数的值超过了 JavaScript 所能表示的负数范围，结果为负无穷大，在 JavaScript 中以 -Infinity 表示。无穷大值的行为特性和我们所期望的是一致的：基于它们的加、减、乘和除运算结果还是无穷大（当然还保留它们的正负号）</p>
<pre><code class="JavaScript">myNumber=2;
while (myNumber!=Infinity) {myNumber=myNumber*myNumber; // 重复计算直到 myNumber 等于 Infinity}
</code></pre>
<p>除以 0 也产生了无穷大</p>
<pre><code class="JavaScript">var x = 2/0; //Infinity
var y = -2/0; //-Infinity
</code></pre>
<h3 id="NaN-非数字值"><a href="#NaN-非数字值" class="headerlink" title="NaN - 非数字值"></a>NaN - 非数字值</h3><p>NaN 属性是代表非数字值的特殊值。该属性用于指示某个值不是数字。可以把 Number 对象设置为该值，来指示其不是数字值<br>你可以使用 isNaN() 全局函数来判断一个值是否是 NaN 值</p>
<pre><code class="JavaScript">var x = 1000 / &quot;Apple&quot;;
isNaN(x); // 返回 true
var y = 100 / &quot;1000&quot;;
isNaN(y); // 返回 false
</code></pre>
<p>除以 0 是无穷大，无穷大是一个数字：</p>
<pre><code class="JavaScript">var x = 1000 / 0;
isNaN(x); // 返回 false
</code></pre>
<h3 id="数字可以是数字或者对象"><a href="#数字可以是数字或者对象" class="headerlink" title="数字可以是数字或者对象"></a>数字可以是数字或者对象</h3><pre><code class="JavaScript">var x = 123;
var y = new Number(123);
typeof(x) // 返回 Number
typeof(y) // 返回 Object
(x === y) // 为 false，因为 x 是一个数字，y 是一个对象
</code></pre>
<hr>
<h2 id="JavaScript-字符串（String）-对象"><a href="#JavaScript-字符串（String）-对象" class="headerlink" title="JavaScript 字符串（String） 对象"></a>JavaScript 字符串（String） 对象</h2><p>String 对象用于处理已有的字符块</p>
<h3 id="JavaScript-字符串-6"><a href="#JavaScript-字符串-6" class="headerlink" title="JavaScript 字符串"></a>JavaScript 字符串</h3><p>一个字符串用于存储一系列字符就像 “John Doe”<br>一个字符串可以使用单引号或双引号</p>
<pre><code class="JavaScript">var carname=&quot;Volvo XC60&quot;;
var carname=&#39;Volvo XC60&#39;;
</code></pre>
<p>字符串的索引从零开始, 所以字符串第一字符为 [0], 第二个字符为 [1], 等等</p>
<pre><code class="JavaScript">var character=carname[7];
</code></pre>
<p>字符串（String）使用长度属性 length 来计算字符串的长度：</p>
<pre><code class="JavaScript">var txt=&quot;Hello World!&quot;;
document.write(txt.length); //12

var txt=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;
document.write(txt.length); //26
</code></pre>
<p>字符串使用 indexOf() 来定位字符串中某一个指定的字符首次出现的位置：</p>
<pre><code class="JavaScript">var str=&quot;Hello world, welcome to the universe.&quot;;
var n=str.indexOf(&quot;welcome&quot;);
// 如果没找到对应的字符函数返回 -1
//lastIndexOf() 方法在字符串末尾开始查找字符串出现的位置。
</code></pre>
<p>match() 函数用来查找字符串中特定的字符，并且如果找到的话，则返回这个字符</p>
<pre><code class="JavaScript">var str=&quot;Hello world!&quot;;
document.write(str.match(&quot;world&quot;) + &quot;&lt;br&gt;&quot;);
document.write(str.match(&quot;World&quot;) + &quot;&lt;br&gt;&quot;);
document.write(str.match(&quot;world!&quot;));
</code></pre>
<p>replace() 方法在字符串中用某些字符替换另一些字符</p>
<pre><code class="JavaScript">str=&quot;Please visit Microsoft!&quot;
var n=str.replace(&quot;Microsoft&quot;,&quot;Nowcoder&quot;);
</code></pre>
<p>字符串大小写转换使用函数 toUpperCase()/ toLowerCase()：</p>
<pre><code class="JavaScript">var txt=&quot;Hello World!&quot;;       // String
var txt1=txt.toUpperCase();   // txt1 文本会转换为大写
var txt2=txt.toLowerCase();   // txt2 文本会转换为小写
</code></pre>
<p>字符串使用 split() 函数转为数组：</p>
<pre><code class="JavaScript">txt=&quot;a,b,c,d,e&quot;   // String
txt.split(&quot;,&quot;);   // 使用逗号分隔
txt.split(&quot; &quot;);   // 使用空格分隔
txt.split(&quot;|&quot;);   // 使用竖线分隔
</code></pre>
<hr>
<h2 id="JavaScript-Date（日期）-对象"><a href="#JavaScript-Date（日期）-对象" class="headerlink" title="JavaScript Date（日期） 对象"></a>JavaScript Date（日期） 对象</h2><p>使用 getFullYear() 获取年份<br>getTime() 返回从 1970 年 1 月 1 日至今的毫秒数<br>使用 setFullYear() 设置具体的日期<br>使用 toUTCString() 将当日的日期（根据 UTC）转换为字符串<br>使用 getDay() 和数组来显示星期，而不仅仅是数字<br>Display a clock 在网页上显示一个钟表</p>
<h3 id="创建日期"><a href="#创建日期" class="headerlink" title="创建日期"></a>创建日期</h3><p>Date 对象用于处理日期和时间<br>可以通过 new 关键词来定义 Date 对象。以下代码定义了名为 myDate 的 Date 对象<br>有四种方式初始化日期：</p>
<pre><code class="JavaScript">new Date() // 当前日期和时间
new Date(milliseconds) // 返回从 1970 年 1 月 1 日至今的毫秒数
new Date(dateString)
new Date(year, month, day, hours, minutes, seconds, milliseconds)

var today = new Date()var d1 = new Date(&quot;October 13, 1975 11:13:00&quot;)
var d2 = new Date(79,5,24)
var d3 = new Date(79,5,24,11,33,0)
</code></pre>
<h3 id="设置日期"><a href="#设置日期" class="headerlink" title="设置日期"></a>设置日期</h3><p>通过使用针对日期对象的方法，我们可以很容易地对日期进行操作<br>在下面的例子中，我们为日期对象设置了一个特定的日期 (2010 年 1 月 14 日)：</p>
<pre><code class="JavaScript">var myDate=new Date();
myDate.setFullYear(2010,0,14);
</code></pre>
<p>在下面的例子中，我们将日期对象设置为 5 天后的日期：</p>
<pre><code class="JavaScript">var myDate=new Date();
myDate.setDate(myDate.getDate()+5);
</code></pre>
<p>注意: 如果增加天数会改变月份或者年份，那么日期对象会自动完成这种转换</p>
<h3 id="两个日期比较"><a href="#两个日期比较" class="headerlink" title="两个日期比较"></a>两个日期比较</h3><p>日期对象也可用于比较两个日期<br>下面的代码将当前日期与 2100 年 1 月 14 日做了比较：</p>
<pre><code class="JavaScript">var x=new Date();
x.setFullYear(2100,0,14);
var today = new Date();

if (x&gt;today) {alert(&quot;今天是 2100 年 1 月 14 日之前&quot;);
}
else {alert(&quot;今天是 2100 年 1 月 14 日之后&quot;);
}
</code></pre>
<hr>
<h2 id="JavaScript-Array（数组）-对象"><a href="#JavaScript-Array（数组）-对象" class="headerlink" title="JavaScript Array（数组） 对象"></a>JavaScript Array（数组） 对象</h2><p>数组对象的作用是：使用单独的变量名来存储一系列的值</p>
<h3 id="什么是数组"><a href="#什么是数组" class="headerlink" title="什么是数组"></a>什么是数组</h3><p>数组对象是使用单独的变量名来存储一系列的值<br>如果你有一组数据（例如：车名字），存在单独变量如下所示：</p>
<pre><code class="JavaScript">var car1=&quot;Saab&quot;;
var car2=&quot;Volvo&quot;;
var car3=&quot;BMW&quot;;
</code></pre>
<p>然而，如果你想从中找出某一辆车？并且不是 3 辆，而是 300 辆呢？这将不是一件容易的事<br>最好的方法就是用数组<br>数组可以用一个变量名存储所有的值，并且可以用变量名访问任何一个值<br>数组中的每个元素都有自己的的 ID，以便它可以很容易地被访问到</p>
<h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><p>创建一个数组，有三种方法<br>下面的代码定义了一个名为 myCars 的数组对象：</p>
<pre><code class="JavaScript">var myCars=new Array();
myCars[0]=&quot;Saab&quot;;     
myCars[1]=&quot;Volvo&quot;;
myCars[2]=&quot;BMW&quot;;
//or
var myCars=new Array(&quot;Saab&quot;,&quot;Volvo&quot;,&quot;BMW&quot;);
//or
var myCars=[&quot;Saab&quot;,&quot;Volvo&quot;,&quot;BMW&quot;];
</code></pre>
<h3 id="访问数组"><a href="#访问数组" class="headerlink" title="访问数组"></a>访问数组</h3><p>通过指定数组名以及索引号码，你可以访问某个特定的元素</p>
<pre><code class="JavaScript">var name=myCars[0];
// 改变
myCars[0]=&quot;Opel&quot;;
</code></pre>
<h3 id="在一个数组中你可以有不同的对象"><a href="#在一个数组中你可以有不同的对象" class="headerlink" title="在一个数组中你可以有不同的对象"></a>在一个数组中你可以有不同的对象</h3><p>所有的 JavaScript 变量都是对象。数组元素是对象。函数是对象<br>因此，你可以在数组中有不同的变量类型<br>你可以在一个数组中包含对象元素、函数、数组：</p>
<pre><code class="JavaScript">myArray[0]=Date.now;
myArray[1]=myFunction;
myArray[2]=myCars;
</code></pre>
<h3 id="数组方法和属性"><a href="#数组方法和属性" class="headerlink" title="数组方法和属性"></a>数组方法和属性</h3><pre><code class="JavaScript">var x=myCars.length             // myCars 中元素的数量
var y=myCars.indexOf(&quot;Volvo&quot;)   // &quot;Volvo&quot; 值的索引值
</code></pre>
<h3 id="创建新方法"><a href="#创建新方法" class="headerlink" title="创建新方法"></a>创建新方法</h3><p>原型是 JavaScript 全局构造函数。它可以构建新 Javascript 对象的属性和方法</p>
<pre><code class="JavaScript">Array.prototype.myUcase=function(){for (i=0;i&lt;this.length;i++){this[i]=this[i].toUpperCase();}
}
// 用于将数组小写字符转为大写字符
</code></pre>
<hr>
<h2 id="JavaScript-Boolean（布尔）-对象"><a href="#JavaScript-Boolean（布尔）-对象" class="headerlink" title="JavaScript Boolean（布尔） 对象"></a>JavaScript Boolean（布尔） 对象</h2><p>Boolean（布尔）对象用于将非布尔值转换为布尔值（true 或者 false）<br>如果布尔对象无初始值或者其值为:</p>
<ul>
<li>0</li>
<li>-0</li>
<li>null</li>
<li>“”</li>
<li>false</li>
<li>undefined</li>
<li>NaN</li>
</ul>
<p>那么对象的值为 false。否则，其值为 true（即使当变量值为字符串 “false” 时）</p>
<hr>
<h1 id="JS-BOM"><a href="#JS-BOM" class="headerlink" title="JS BOM"></a>JS BOM</h1><h2 id="JavaScript-Window-浏览器对象模型"><a href="#JavaScript-Window-浏览器对象模型" class="headerlink" title="JavaScript Window - 浏览器对象模型"></a>JavaScript Window - 浏览器对象模型</h2><p>浏览器对象模型 (BOM) 使 JavaScript 有能力与浏览器 “对话”</p>
<h3 id="浏览器对象模型-BOM"><a href="#浏览器对象模型-BOM" class="headerlink" title="浏览器对象模型 (BOM)"></a>浏览器对象模型 (BOM)</h3><p>浏览器对象模型（Browser Object Model (BOM)）尚无正式标准<br>由于现代浏览器已经（几乎）实现了 JavaScript 交互性方面的相同方法和属性，因此常被认为是 BOM 的方法和属性</p>
<h3 id="Window-对象"><a href="#Window-对象" class="headerlink" title="Window 对象"></a>Window 对象</h3><p>所有浏览器都支持 window 对象。它表示浏览器窗口<br>所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员<br>全局变量是 window 对象的属性<br>全局函数是 window 对象的方法<br>甚至 HTML DOM 的 document 也是 window 对象的属性之一：</p>
<pre><code class="JavaScript">window.document.getElementById(&quot;header&quot;);
document.getElementById(&quot;header&quot;);
</code></pre>
<h3 id="Window-尺寸"><a href="#Window-尺寸" class="headerlink" title="Window 尺寸"></a>Window 尺寸</h3><pre><code class="JavaScript">var w=window.innerWidth
|| document.documentElement.clientWidth
|| document.body.clientWidth;
// 浏览器窗口的内部宽度 (包括滚动条)

var h=window.innerHeight
|| document.documentElement.clientHeight
|| document.body.clientHeight;
// 浏览器窗口的内部高度 (包括滚动条)
</code></pre>
<hr>
<h2 id="JavaScript-Window-Screen"><a href="#JavaScript-Window-Screen" class="headerlink" title="JavaScript Window Screen"></a>JavaScript Window Screen</h2><p>window.screen 对象包含有关用户屏幕的信息<br>window.screen 对象在编写时可以不使用 window 这个前缀</p>
<ul>
<li>screen.availWidth  可用的屏幕宽度</li>
<li>screen.availHeight  可用的屏幕高度</li>
</ul>
<p>以像素计，减去界面特性，比如窗口任务栏</p>
<hr>
<h2 id="JavaScript-Window-Location"><a href="#JavaScript-Window-Location" class="headerlink" title="JavaScript Window Location"></a>JavaScript Window Location</h2><p>window.location 对象用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面<br>window.location 对象在编写时可不使用 window 这个前缀。 一些例子</p>
<ul>
<li>location.hostname 返回 web 主机的域名</li>
<li>location.pathname 返回当前页面的路径和文件名</li>
<li>location.port 返回 web 主机的端口 （80 或 443）</li>
<li>location.protocol 返回所使用的 web 协议（http: 或 https:）</li>
</ul>
<h3 id="Window-Location-Href"><a href="#Window-Location-Href" class="headerlink" title="Window Location Href"></a>Window Location Href</h3><p>location.href 属性返回当前页面的 URL</p>
<h3 id="Window-Location-Assign"><a href="#Window-Location-Assign" class="headerlink" title="Window Location Assign"></a>Window Location Assign</h3><p>location.assign() 方法加载新的文档</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;(nowcoder.com)&lt;/title&gt;
&lt;/head&gt;
&lt;head&gt;
    &lt;script&gt;
        function newDoc(){window.location.assign(&quot;https://www.nowcoder.com&quot;)
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;input type=&quot;button&quot; value=&quot;加载新文档&quot; onclick=&quot;newDoc()&quot;&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<hr>
<h2 id="JavaScript-Window-History"><a href="#JavaScript-Window-History" class="headerlink" title="JavaScript Window History"></a>JavaScript Window History</h2><p>window.history 对象包含浏览器的历史</p>
<h3 id="Window-History"><a href="#Window-History" class="headerlink" title="Window History"></a>Window History</h3><p>window.history 对象在编写时可不使用 window 这个前缀<br>为了保护用户隐私，对 JavaScript 访问该对象的方法做出了限制</p>
<ul>
<li>history.back() - 与在浏览器点击后退按钮相同</li>
<li>history.forward() - 与在浏览器中点击向前按钮相同</li>
</ul>
<h3 id="Window-history-back-history-back-方法加载历史列表中的前一个-URL"><a href="#Window-history-back-history-back-方法加载历史列表中的前一个-URL" class="headerlink" title="Window history.back()history.back() 方法加载历史列表中的前一个 URL"></a>Window history.back()history.back() 方法加载历史列表中的前一个 URL</h3><p>这与在浏览器中点击后退按钮是相同的：<br>在页面上创建后退按钮：</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;head&gt;
    &lt;script&gt;
        function goBack() {window.history.back();
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;input type=&quot;button&quot; value=&quot;Back&quot; onclick=&quot;goBack()&quot;&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="Window-history-forward"><a href="#Window-history-forward" class="headerlink" title="Window history.forward()"></a>Window history.forward()</h3><p>在页面上创建一个向前的按钮：</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;script&gt;
        function goForward() {window.history.forward()；
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;input type=&quot;button&quot; value=&quot;Forward&quot; onclick=&quot;goForward()&quot;&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<hr>
<h2 id="JavaScript-Window-Navigator"><a href="#JavaScript-Window-Navigator" class="headerlink" title="JavaScript Window Navigator"></a>JavaScript Window Navigator</h2><p>window.navigator 对象包含有关访问者浏览器的信息</p>
<pre><code class="html">&lt;div id=&quot;example&quot;&gt;&lt;/div&gt;
&lt;script&gt;
    txt = &quot;&lt;p&gt; 浏览器代号:&quot; + navigator.appCodeName + &quot;&lt;/p&gt;&quot;;
    txt+= &quot;&lt;p&gt; 浏览器名称:&quot; + navigator.appName + &quot;&lt;/p&gt;&quot;;
    txt+= &quot;&lt;p&gt; 浏览器版本:&quot; + navigator.appVersion + &quot;&lt;/p&gt;&quot;;
    txt+= &quot;&lt;p&gt; 启用 Cookies:&quot; + navigator.cookieEnabled + &quot;&lt;/p&gt;&quot;;
    txt+= &quot;&lt;p&gt; 硬件平台:&quot; + navigator.platform + &quot;&lt;/p&gt;&quot;;
    txt+= &quot;&lt;p&gt; 用户代理:&quot; + navigator.userAgent + &quot;&lt;/p&gt;&quot;;
    txt+= &quot;&lt;p&gt; 用户代理语言:&quot; + navigator.systemLanguage + &quot;&lt;/p&gt;&quot;;
    document.getElementById(&quot;example&quot;).innerHTML=txt;
&lt;/script&gt;
</code></pre>
<p>注：来自 navigator 对象的信息具有误导性，不应该被用于检测浏览器版本，这是因为：</p>
<ul>
<li>navigator 数据可被浏览器使用者更改</li>
<li>一些浏览器对测试站点会识别错误</li>
<li>浏览器无法报告晚于浏览器发布的新操作系统</li>
</ul>
<p>所以由于 navigator 可误导浏览器检测，使用对象检测可用来嗅探不同的浏览器</p>
<hr>
<h2 id="JavaScript-弹窗"><a href="#JavaScript-弹窗" class="headerlink" title="JavaScript 弹窗"></a>JavaScript 弹窗</h2><p>可以在 JavaScript 中创建三种消息框：警告框、确认框、提示框</p>
<h3 id="警告框"><a href="#警告框" class="headerlink" title="警告框"></a>警告框</h3><p>警告框经常用于确保用户可以得到某些信息<br>当警告框出现后，用户需要点击确定按钮才能继续进行操作</p>
<pre><code class="JavaScript">window.alert(&quot;sometext&quot;);
</code></pre>
<h3 id="确认框"><a href="#确认框" class="headerlink" title="确认框"></a>确认框</h3><p>确认框通常用于验证是否接受用户操作<br>当确认卡弹出时，用户可以点击 “确认” 或者 “取消” 来确定用户操作<br>当你点击 “确认”, 确认框返回 true， 如果点击 “取消”, 确认框返回 false</p>
<pre><code class="JavaScript">window.confirm(&quot;sometext&quot;);
</code></pre>
<h3 id="提示框"><a href="#提示框" class="headerlink" title="提示框"></a>提示框</h3><p>提示框经常用于提示用户在进入页面前输入某个值<br>当提示框出现后，用户需要输入某个值，然后点击确认或取消按钮才能继续操纵<br>如果用户点击确认，那么返回值为输入的值。如果用户点击取消，那么返回值为 null</p>
<pre><code class="JavaScript">window.prompt(&quot;sometext&quot;,&quot;defaultvalue&quot;);
</code></pre>
<hr>
<h2 id="JavaScript-计时事件"><a href="#JavaScript-计时事件" class="headerlink" title="JavaScript 计时事件"></a>JavaScript 计时事件</h2><p>JavaScript 一个设定的时间间隔之后来执行代码，我们称之为计时事件<br>通过使用 JavaScript，我们有能力做到在一个设定的时间间隔之后来执行代码，而不是在函数被调用后立即执行。我们称之为计时事件<br>在 JavaScritp 中使用计时事件是很容易的，两个关键方法是:</p>
<ul>
<li>setInterval() - 间隔指定的毫秒数不停地执行指定的代码</li>
<li>setTimeout() - 在指定的毫秒数后执行指定代码</li>
</ul>
<h3 id="setInterval-方法"><a href="#setInterval-方法" class="headerlink" title="setInterval() 方法"></a>setInterval() 方法</h3><p>setInterval() 间隔指定的毫秒数不停地执行指定的代码</p>
<pre><code class="JavaScript">window.setInterval(&quot;javascript function&quot;,milliseconds);
</code></pre>
<p>window.setInterval()方法可以不使用 window 前缀，直接使用函数 setInterval()<br>setInterval() 第一个参数是函数（function）<br>第二个参数间隔的毫秒数<br>注意: 1000 毫秒是一秒</p>
<pre><code class="JavaScript">setInterval(function(){alert(&quot;Hello&quot;)},3000);
// 每三秒弹出 hello

// 显示当前时间
var myVar=setInterval(function(){myTimer()},1000);

function myTimer() {var d=new Date();
    var t=d.toLocaleTimeString();
    document.getElementById(&quot;demo&quot;).innerHTML=t;
}
</code></pre>
<h3 id="停止执行"><a href="#停止执行" class="headerlink" title="停止执行"></a>停止执行</h3><p>clearInterval()方法用于停止 setInterval() 方法执行的函数代码</p>
<pre><code class="JavaScript">window.clearInterval(intervalVariable)
</code></pre>
<p>要使用 clearInterval() 方法, 在创建计时方法时你必须使用全局变量</p>
<pre><code class="JavaScript">myVar=setInterval(&quot;javascript function&quot;,milliseconds);
</code></pre>
<pre><code class="html">&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;
&lt;button onclick=&quot;myStopFunction()&quot;&gt; 停止 &lt;/button&gt;
&lt;script&gt;
    var myVar=setInterval(function(){myTimer()},1000);
    function myTimer(){var d=new Date();
        var t=d.toLocaleTimeString();
        document.getElementById(&quot;demo&quot;).innerHTML=t;
    }
    function myStopFunction(){clearInterval(myVar);
    }
&lt;/script&gt;
</code></pre>
<h3 id="setTimeout-方法"><a href="#setTimeout-方法" class="headerlink" title="setTimeout() 方法"></a>setTimeout() 方法</h3><pre><code class="JavaScript">myVar= window.setTimeout(&quot;javascript function&quot;, milliseconds);
</code></pre>
<p>setTimeout()方法会返回某个值。在上面的语句中，值被储存在名为 myVar 的变量中。假如你希望取消这个 setTimeout()，你可以使用这个变量名来指定它<br>setTimeout()的第一个参数是含有 JavaScript 语句的字符串。这个语句可能诸如 “alert(‘5 seconds!’)”，或者对函数的调用，诸如 alertMsg<br>第二个参数指示从当前起多少毫秒后执行第一个参数<br>提示：1000 毫秒等于一秒</p>
<pre><code class="JavaScript">setTimeout(function(){alert(&quot;Hello&quot;)},3000);
// 等待 3s 后，出现 hello
</code></pre>
<h3 id="停止执行-1"><a href="#停止执行-1" class="headerlink" title="停止执行"></a>停止执行</h3><p>clearTimeout()方法用于停止执行 setTimeout() 方法的函数代码</p>
<pre><code class="JavaScript">var myVar;

function myFunction() {myVar=setTimeout(function(){alert(&quot;Hello&quot;)},3000);}

function myStopFunction() {clearTimeout(myVar);
}
</code></pre>
<hr>
<h2 id="JavaScript-Cookie"><a href="#JavaScript-Cookie" class="headerlink" title="JavaScript Cookie"></a>JavaScript Cookie</h2><p>Cookie 用于存储 web 页面的用户信息</p>
<h3 id="什么是-Cookie"><a href="#什么是-Cookie" class="headerlink" title="什么是 Cookie"></a>什么是 Cookie</h3><p>Cookie 是一些数据, 存储于你电脑上的文本文件中<br>当 web 服务器向浏览器发送 web 页面时，在连接关闭后，服务端不会记录用户的信息<br>Cookie 的作用就是用于解决 “如何记录客户端的用户信息”:</p>
<ul>
<li>当用户访问 web 页面时，他的名字可以记录在 cookie 中</li>
<li>在用户下一次访问该页面时，可以在 cookie 中读取用户访问记录</li>
</ul>
<p>Cookie 以名 / 值对形式存储<br><code>username=John Doe</code><br>当浏览器从服务器上请求 web 页面时， 属于该页面的 cookie 会被添加到该请求中。服务端通过这种方式来获取用户的信息</p>
<h3 id="使用-JavaScript-创建-Cookie"><a href="#使用-JavaScript-创建-Cookie" class="headerlink" title="使用 JavaScript 创建 Cookie"></a>使用 JavaScript 创建 Cookie</h3><p>JavaScript 可以使用 document.cookie 属性来创建 、读取、及删除 cookie</p>
<pre><code class="JavaScript">document.cookie=&quot;username=John Doe&quot;;
</code></pre>
<p>您还可以为 cookie 添加一个过期时间（以 UTC 或 GMT 时间）。默认情况下，cookie 在浏览器关闭时删除：</p>
<pre><code class="JavaScript">document.cookie=&quot;username=John Doe; expires=Thu, 18 Dec 2043 12:00:00 GMT&quot;;
</code></pre>
<p>您可以使用 path 参数告诉浏览器 cookie 的路径。默认情况下，cookie 属于当前页面</p>
<pre><code class="JavaScript">document.cookie=&quot;username=John Doe; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/&quot;;
</code></pre>
<h3 id="使用-JavaScript-读取-Cookie"><a href="#使用-JavaScript-读取-Cookie" class="headerlink" title="使用 JavaScript 读取 Cookie"></a>使用 JavaScript 读取 Cookie</h3><pre><code class="JavaScript">var x = document.cookie;
//document.cookie 将以字符串的方式返回所有的 cookie，类型格式： cookie1=value; cookie2=value; cookie3=value;
</code></pre>
<h3 id="使用-JavaScript-修改-Cookie"><a href="#使用-JavaScript-修改-Cookie" class="headerlink" title="使用 JavaScript 修改 Cookie"></a>使用 JavaScript 修改 Cookie</h3><p>在 JavaScript 中，修改 cookie 类似于创建 cookie，如下所示：</p>
<pre><code class="JavaScript">document.cookie=&quot;username=John Smith; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/&quot;;
// 则旧的 cookie 被覆盖
</code></pre>
<h3 id="使用-JavaScript-删除-Cookie"><a href="#使用-JavaScript-删除-Cookie" class="headerlink" title="使用 JavaScript 删除 Cookie"></a>使用 JavaScript 删除 Cookie</h3><p>删除 cookie 非常简单。您只需要设置 expires 参数为以前的时间即可，如下所示，设置为 Thu, 01 Jan 1970 00:00:00 GMT</p>
<h3 id="Cookie-字符串"><a href="#Cookie-字符串" class="headerlink" title="Cookie 字符串"></a>Cookie 字符串</h3><p>document.cookie 属性看起来像一个普通的文本字符串，其实它不是<br>即使您在 document.cookie 中写入一个完整的 cookie 字符串, 当您重新读取该 cookie 信息时，cookie 信息是以名 / 值对的形式展示的<br>如果您设置了新的 cookie，旧的 cookie 不会被覆盖。 新 cookie 将添加到 document.cookie 中<br>如果您需要查找一个指定 cookie 值，您必须创建一个 JavaScript 函数在 cookie 字符串中查找 cookie 值</p>
<h3 id="JavaScript-Cookie-实例"><a href="#JavaScript-Cookie-实例" class="headerlink" title="JavaScript Cookie 实例"></a>JavaScript Cookie 实例</h3><p>首先，我们创建一个函数用于存储访问者的名字：</p>
<pre><code class="JavaScript">function setCookie(cname,cvalue,exdays) {var d = new Date();
  d.setTime(d.getTime()+(exdays*24*60*60*1000));
  var expires = &quot;expires=&quot;+d.toGMTString();
  document.cookie = cname + &quot;=&quot; + cvalue + &quot;;&quot; + expires;
}
// 以上的函数参数中，cookie 的名称为 cname，cookie 的值为 cvalue，并设置了 cookie 的过期时间 expires
// 该函数设置了 cookie 名、cookie 值、cookie 过期时间
</code></pre>
<p>然后，我们创建一个函数用户返回指定 cookie 的值：</p>
<pre><code class="JavaScript">function getCookie(cname) {
  var name = cname + &quot;=&quot;;
  var ca = document.cookie.split(&#39;;&#39;);
  for(var i=0; i&lt;ca.length; i++)  {var c = ca[i].trim();
    if (c.indexOf(name)==0)return c.substring(name.length,c.length);
  }
  return &quot;&quot;;
}
//cookie 名的参数为 cname
// 创建一个文本变量用于检索指定 cookie :cname + &quot;=&quot;
// 使用分号来分割 document.cookie 字符串，并将分割后的字符串数组赋值给 ca (ca = document.cookie.split(&#39;;&#39;))
// 循环 ca 数组 (i=0;i&lt;ca.length;i++)，然后读取数组中的每个值，并去除前后空格 (c=ca[i].trim())// 如果找到 cookie(c.indexOf(name) == 0)，返回 cookie 的值 (c.substring(name.length,c.length)
// 如果没有找到 cookie, 返回 &quot;&quot;
</code></pre>
<p>最后，我们可以创建一个检测 cookie 是否创建的函数<br>如果设置了 cookie，将显示一个问候信息<br>如果没有设置 cookie，将会显示一个弹窗用于询问访问者的名字，并调用 setCookie 函数将访问者的名字存储 365 天：</p>
<pre><code class="JavaScript">function checkCookie() {var username=getCookie(&quot;username&quot;);
  if (username!=&quot;&quot;) {alert(&quot;Welcome again&quot; + username);
  }
  else {username = prompt(&quot;Please enter your name:&quot;,&quot;&quot;);
    if (username!=&quot;&quot; &amp;&amp; username!=null) {setCookie(&quot;username&quot;,username,365);
    }
  }
}
</code></pre>
<h3 id="完整实例"><a href="#完整实例" class="headerlink" title="完整实例"></a>完整实例</h3><pre><code class="JavaScript">function setCookie(cname,cvalue,exdays){var d = new Date();
    d.setTime(d.getTime()+(exdays*24*60*60*1000));
    var expires = &quot;expires=&quot;+d.toGMTString();
    document.cookie = cname+&quot;=&quot;+cvalue+&quot;;&quot;+expires;
}
function getCookie(cname){
    var name = cname + &quot;=&quot;;
    var ca = document.cookie.split(&#39;;&#39;);
    for(var i=0; i&lt;ca.length; i++) {var c = ca[i].trim();
        if (c.indexOf(name)==0){ return c.substring(name.length,c.length); }
    }
    return &quot;&quot;;
}
function checkCookie(){var user=getCookie(&quot;username&quot;);
    if (user!=&quot;&quot;){alert(&quot;欢迎&quot; + user + &quot;再次访问&quot;);
    }
    else {user = prompt(&quot;请输入你的名字:&quot;,&quot;&quot;);
          if (user!=&quot;&quot; &amp;&amp; user!=null){setCookie(&quot;username&quot;,user,30);
        }
    }
}
</code></pre>
<hr>
<h1 id="JS-库"><a href="#JS-库" class="headerlink" title="JS 库"></a>JS 库</h1><h2 id="JavaScript-库"><a href="#JavaScript-库" class="headerlink" title="JavaScript 库"></a>JavaScript 库</h2><p>JavaScript 库 - jQuery、Prototype、MooTools</p>
<h3 id="JavaScript-框架（库）"><a href="#JavaScript-框架（库）" class="headerlink" title="JavaScript 框架（库）"></a>JavaScript 框架（库）</h3><p>JavaScript 高级程序设计（特别是对浏览器差异的复杂处理），通常很困难也很耗时<br>为了应对这些调整，许多的 JavaScript (helper) 库应运而生<br>这些 JavaScript 库常被称为 JavaScript 框架<br>所有这些框架都提供针对常见 JavaScript 任务的函数，包括动画、DOM 操作以及 Ajax 处理</p>
]]></content>
      <categories>
        <category>面试汇总</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
